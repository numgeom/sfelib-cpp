//
// Academic License - for use in teaching, academic research, and meeting
// course requirements at degree granting institutions only.  Not for
// government, commercial, or other organizational use.
//
// sfe_internal.cpp
//
// Code generation for function 'sfe_internal'
//

// Include files
#include "sfe_internal.h"
#include "coder_array.h"
#include "m2c_lib.h"
#include "omp.h"
#include "sfe_internal_types.h"
#include "sfe_quadrules_rowmajor.h"
#include "sfe_shapefuncs_rowmajor.h"
#include <algorithm>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <omp.h #ifdef _OPENMP>
#include <stdexcept>
#include <vector>

// Variable Definitions
namespace sfe {
omp_nest_lock_t sfe_bnd_init1_nestLockGlobal;

static const int16_T iv[250]{
    1,  0,   0,   0,  0,  0,   0,   0,   0,   0,   0,   0,   0,  0,  0,  0,  0,
    0,  0,   0,   0,  0,  0,   0,   0,   0,   0,   0,   0,   0,  0,  0,  0,  0,
    0,  2,   0,   0,  0,  3,   0,   0,   0,   4,   4,   0,   0,  5,  5,  0,  0,
    6,  6,   0,   0,  7,  7,   0,   0,   0,   0,   0,   0,   0,  0,  0,  0,  3,
    0,  0,   0,   6,  0,  0,   0,   10,  10,  0,   0,   15,  15, 15, 0,  21, 21,
    21, 0,   28,  28, 28, 0,   0,   0,   0,   0,   0,   0,   0,  0,  4,  0,  0,
    0,  9,   0,   0,  0,  16,  16,  0,   0,   25,  25,  0,   0,  36, 36, 0,  0,
    49, 49,  0,   0,  0,  0,   0,   0,   0,   0,   0,   0,   4,  0,  0,  0,  10,
    0,  0,   0,   20, 20, 0,   0,   35,  35,  35,  0,   56,  56, 56, 0,  84, 84,
    84, 0,   0,   0,  0,  0,   0,   0,   0,   0,   5,   0,   0,  0,  14, 0,  0,
    0,  30,  30,  0,  0,  55,  55,  55,  0,   91,  0,   0,   0,  0,  0,  0,  0,
    0,  0,   0,   0,  0,  0,   0,   0,   6,   0,   0,   0,   18, 0,  0,  0,  40,
    40, 0,   0,   75, 75, 75,  0,   126, 126, 0,   0,   196, 0,  0,  0,  0,  0,
    0,  0,   0,   0,  0,  0,   8,   0,   0,   0,   27,  0,   0,  0,  64, 64, 0,
    0,  125, 125, 0,  0,  216, 216, 0,   0,   343, 343, -1};

} // namespace sfe

// Function Declarations
namespace sfe {
static void b_sfe_init(SfeObject *b_sfe, const ::coder::array<real_T, 2U> &xs);

static void bar_quadrules(int32_T degree, ::coder::array<real_T, 2U> &cs,
                          ::coder::array<real_T, 1U> &ws);

static void hexa_125(real_T xi, real_T eta, real_T zeta, real_T sfvals[125],
                     real_T sdvals[375]);

static void hexa_216(real_T xi, real_T eta, real_T zeta, real_T sfvals[216],
                     real_T sdvals[648]);

static void hexa_343(real_T xi, real_T eta, real_T zeta, real_T sfvals[343],
                     real_T sdvals[1029]);

static void hexa_64(real_T xi, real_T eta, real_T zeta, real_T sfvals[64],
                    real_T sdvals[192]);

static void hexa_gl_125(real_T xi, real_T eta, real_T zeta, real_T sfvals[125],
                        real_T sdvals[375]);

static void hexa_gl_216(real_T xi, real_T eta, real_T zeta, real_T sfvals[216],
                        real_T sdvals[648]);

static void hexa_gl_343(real_T xi, real_T eta, real_T zeta, real_T sfvals[343],
                        real_T sdvals[1029]);

static void hexa_gl_64(real_T xi, real_T eta, real_T zeta, real_T sfvals[64],
                       real_T sdvals[192]);

static void obtain_facets(int32_T etype, int8_T facetid, uint8_T *ret,
                          int16_T lids_data[], int32_T *lids_size);

static uint8_T obtain_facets(int32_T etype);

static uint8_T obtain_facets(int32_T etype, int8_T facetid);

static void obtain_facets(int32_T etype, uint8_T facetid, uint8_T *ret,
                          int16_T lids_data[], int32_T *lids_size);

static void obtain_natcoords(uint8_T etype,
                             ::coder::array<real_T, 2U> &natcoords);

static void obtain_natcoords(int32_T etype,
                             ::coder::array<real_T, 2U> &natcoords);

static void prism_126(real_T xi, real_T eta, real_T zeta, real_T sfvals[126],
                      real_T sdvals[378]);

static void prism_196(real_T xi, real_T eta, real_T zeta, real_T sfvals[196],
                      real_T sdvals[588]);

static void prism_40(real_T xi, real_T eta, real_T zeta, real_T sfvals[40],
                     real_T sdvals[120]);

static void prism_75(real_T xi, real_T eta, real_T zeta, real_T sfvals[75],
                     real_T sdvals[225]);

static void prism_gl_126(real_T xi, real_T eta, real_T zeta, real_T sfvals[126],
                         real_T sdvals[378]);

static void prism_gl_40(real_T xi, real_T eta, real_T zeta, real_T sfvals[40],
                        real_T sdvals[120]);

static void prism_gl_75(real_T xi, real_T eta, real_T zeta, real_T sfvals[75],
                        real_T sdvals[225]);

static void pyra_30(real_T xi, real_T eta, real_T zeta, real_T sfvals[30],
                    real_T sdvals[90]);

static void pyra_55(real_T xi, real_T eta, real_T zeta, real_T sfvals[55],
                    real_T sdvals[165]);

static void pyra_gl_30(real_T xi, real_T eta, real_T zeta, real_T sfvals[30],
                       real_T sdvals[90]);

static void pyra_gl_55(real_T xi, real_T eta, real_T zeta, real_T sfvals[55],
                       real_T sdvals[165]);

static void pyra_quadrules(int32_T degree, ::coder::array<real_T, 2U> &cs,
                           ::coder::array<real_T, 1U> &ws);

static void quad_25(real_T xi, real_T eta, real_T sfvals[25],
                    real_T sdvals[50]);

static void quad_36(real_T xi, real_T eta, real_T sfvals[36],
                    real_T sdvals[72]);

static void quad_49(real_T xi, real_T eta, real_T sfvals[49],
                    real_T sdvals[98]);

static void quad_gl_25(real_T xi, real_T eta, real_T sfvals[25],
                       real_T sdvals[50]);

static void quad_gl_36(real_T xi, real_T eta, real_T sfvals[36],
                       real_T sdvals[72]);

static void quad_gl_49(real_T xi, real_T eta, real_T sfvals[49],
                       real_T sdvals[98]);

static void sfe1_tabulate_shapefuncs(int32_T etype,
                                     const ::coder::array<real_T, 2U> &cs,
                                     ::coder::array<real_T, 2U> &sfvals,
                                     ::coder::array<real_T, 3U> &sdvals);

static void sfe2_tabulate_equi_quad(int32_T etype,
                                    const ::coder::array<real_T, 2U> &cs,
                                    ::coder::array<real_T, 2U> &sfvals,
                                    ::coder::array<real_T, 3U> &sdvals);

static void sfe2_tabulate_equi_tri(int32_T etype,
                                   const ::coder::array<real_T, 2U> &cs,
                                   ::coder::array<real_T, 2U> &sfvals,
                                   ::coder::array<real_T, 3U> &sdvals);

static void sfe2_tabulate_fek_tri(int32_T etype,
                                  const ::coder::array<real_T, 2U> &cs,
                                  ::coder::array<real_T, 2U> &sfvals,
                                  ::coder::array<real_T, 3U> &sdvals);

static void sfe2_tabulate_gl_quad(int32_T etype,
                                  const ::coder::array<real_T, 2U> &cs,
                                  ::coder::array<real_T, 2U> &sfvals,
                                  ::coder::array<real_T, 3U> &sdvals);

static void sfe2_tabulate_gl_tri(int32_T etype,
                                 const ::coder::array<real_T, 2U> &cs,
                                 ::coder::array<real_T, 2U> &sfvals,
                                 ::coder::array<real_T, 3U> &sdvals);

static void sfe2_tabulate_shapefuncs(int32_T etype,
                                     const ::coder::array<real_T, 2U> &cs,
                                     ::coder::array<real_T, 2U> &sfvals,
                                     ::coder::array<real_T, 3U> &sdvals);

static void sfe3_tabulate_equi_hexa(int32_T etype,
                                    const ::coder::array<real_T, 2U> &cs,
                                    ::coder::array<real_T, 2U> &sfvals,
                                    ::coder::array<real_T, 3U> &sdvals);

static void sfe3_tabulate_equi_prism(int32_T etype,
                                     const ::coder::array<real_T, 2U> &cs,
                                     ::coder::array<real_T, 2U> &sfvals,
                                     ::coder::array<real_T, 3U> &sdvals);

static void sfe3_tabulate_equi_pyra(int32_T etype,
                                    const ::coder::array<real_T, 2U> &cs,
                                    ::coder::array<real_T, 2U> &sfvals,
                                    ::coder::array<real_T, 3U> &sdvals);

static void sfe3_tabulate_equi_tet(int32_T etype,
                                   const ::coder::array<real_T, 2U> &cs,
                                   ::coder::array<real_T, 2U> &sfvals,
                                   ::coder::array<real_T, 3U> &sdvals);

static void sfe3_tabulate_gl_hexa(int32_T etype,
                                  const ::coder::array<real_T, 2U> &cs,
                                  ::coder::array<real_T, 2U> &sfvals,
                                  ::coder::array<real_T, 3U> &sdvals);

static void sfe3_tabulate_gl_prism(int32_T etype,
                                   const ::coder::array<real_T, 2U> &cs,
                                   ::coder::array<real_T, 2U> &sfvals,
                                   ::coder::array<real_T, 3U> &sdvals);

static void sfe3_tabulate_gl_pyra(int32_T etype,
                                  const ::coder::array<real_T, 2U> &cs,
                                  ::coder::array<real_T, 2U> &sfvals,
                                  ::coder::array<real_T, 3U> &sdvals);

static void sfe3_tabulate_gl_tet(int32_T etype,
                                 const ::coder::array<real_T, 2U> &cs,
                                 ::coder::array<real_T, 2U> &sfvals,
                                 ::coder::array<real_T, 3U> &sdvals);

static void sfe3_tabulate_shapefuncs(int32_T etype,
                                     const ::coder::array<real_T, 2U> &cs,
                                     ::coder::array<real_T, 2U> &sfvals,
                                     ::coder::array<real_T, 3U> &sdvals);

static void sfe_init(SfeObject *b_sfe, int32_T etypes,
                     const ::coder::array<real_T, 2U> &xs,
                     const ::coder::array<real_T, 2U> &qd_or_natcoords);

static void sfe_init(SfeObject *b_sfe, const uint8_T etypes[2],
                     const ::coder::array<real_T, 2U> &xs,
                     int32_T qd_or_natcoords);

static void sfe_init(SfeObject *b_sfe, const uint8_T etypes[2],
                     const ::coder::array<real_T, 2U> &xs);

static void sfe_init(SfeObject *b_sfe, const uint8_T etypes[2],
                     const ::coder::array<real_T, 2U> &xs,
                     const ::coder::array<real_T, 2U> &qd_or_natcoords);

static void sfe_init(SfeObject *b_sfe, const ::coder::array<real_T, 2U> &xs);

static void sfe_init(SfeObject *b_sfe,
                     const ::coder::array<int32_T, 1U> &etypes,
                     const real_T xs_data[], const int32_T xs_size[2],
                     const ::coder::array<real_T, 2U> &qd_or_natcoords);

static void sfe_init(SfeObject *b_sfe, const uint8_T etypes[2],
                     const ::coder::array<real_T, 2U> &xs,
                     int32_T qd_or_natcoords,
                     const ::coder::array<real_T, 2U> &userquad);

static void sfe_init_grad(SfeObject *b_sfe, int32_T q);

static boolean_T solve_sq(real_T J[9], int32_T n,
                          ::coder::array<real_T, 2U> &b1);

static void tabulate_quadratures(int32_T etype, int32_T qd,
                                 ::coder::array<real_T, 2U> &cs,
                                 ::coder::array<real_T, 1U> &ws);

static void tabulate_quadratures_deg_1(int32_T etype,
                                       ::coder::array<real_T, 2U> &cs,
                                       ::coder::array<real_T, 1U> &ws);

static void tabulate_shapefuncs(int32_T etype,
                                const ::coder::array<real_T, 2U> &cs,
                                ::coder::array<real_T, 2U> &sfvals,
                                ::coder::array<real_T, 3U> &sdvals);

static void tabulate_shapefuncs_deg_1(int32_T etype,
                                      const ::coder::array<real_T, 2U> &cs,
                                      ::coder::array<real_T, 2U> &sfvals,
                                      ::coder::array<real_T, 3U> &sdvals);

static void tet_20(real_T xi, real_T eta, real_T zeta, real_T sfvals[20],
                   real_T sdvals[60]);

static void tet_35(real_T xi, real_T eta, real_T zeta, real_T sfvals[35],
                   real_T sdvals[105]);

static void tet_56(real_T xi, real_T eta, real_T zeta, real_T sfvals[56],
                   real_T sdvals[168]);

static void tet_84(real_T xi, real_T eta, real_T zeta, real_T sfvals[84],
                   real_T sdvals[252]);

static void tet_gl_20(real_T xi, real_T eta, real_T zeta, real_T sfvals[20],
                      real_T sdvals[60]);

static void tet_gl_35(real_T xi, real_T eta, real_T zeta, real_T sfvals[35],
                      real_T sdvals[105]);

static void tri_21(real_T xi, real_T eta, real_T sfvals[21], real_T sdvals[42]);

static void tri_28(real_T xi, real_T eta, real_T sfvals[28], real_T sdvals[56]);

static void tri_fek_15(real_T xi, real_T eta, real_T sfvals[15],
                       real_T sdvals[30]);

static void tri_fek_21(real_T xi, real_T eta, real_T sfvals[21],
                       real_T sdvals[42]);

static void tri_fek_28(real_T xi, real_T eta, real_T sfvals[28],
                       real_T sdvals[56]);

static void tri_gl_21(real_T xi, real_T eta, real_T sfvals[21],
                      real_T sdvals[42]);

static void tri_quadrules(int32_T degree, ::coder::array<real_T, 2U> &cs,
                          ::coder::array<real_T, 1U> &ws);

} // namespace sfe

// Function Definitions
namespace sfe {
static void b_sfe_init(SfeObject *b_sfe, const ::coder::array<real_T, 2U> &xs)
{
  int32_T sfe_idx_0_tmp_tmp;
  boolean_T cond;
  // sfe_init - Initialize/reinitialize an sfe object for non-boundary element
  //
  //    sfe = sfe_init(sfe, etypes, xs)
  //    sfe = sfe_init(sfe, etypes, xs, natcoords)
  //    sfe = sfe_init(sfe, etypes, xs, qd)
  //    sfe = sfe_init(sfe, etypes, xs, qd, userquad)
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An SfeObject instance
  //    etypes:     Element type(s), which can be a 2-vector, scalar, or [].
  //                A 2-vector specifies the solution and geometric element
  //                types, and it supports iso-, sub- and super-parametric
  //                elements. If two element types are equal, then one can use a
  //                scalar. An empty array ([]) instructs the function to reuse
  //                the element type and the tabulation stored in the `sfe`
  //                object (typically from a previous call).
  //    xs:         Physical coordinates of the element, which is defined in
  //                the geometric space
  //    qd:         Quadrature degree, a zero value indicate the use of default
  //                quadrature rules based on the element types. If `-1` is
  //                passed in, then the code will assume user-provided
  //                quadrature rule information
  //    userquad:   This field is only accessed if qd=-1. If provided, then
  //    userquad
  //                must be a nqp-by-(1+dim) array, where the first column
  //                vector is is the quadrature weights while the rest are their
  //                corresponding quadrature points, defined in the reference
  //                element.
  //
  //  In particular, the user can pass in specific natural coordinates on which
  //  we will compute shape functions and derivatives. In this situation, we
  //  will skip the computation of Jacobian.
  //
  //    natcoords:  List of natural coordinates defined by the user
  //
  //  EXAMPLES
  //  --------
  //  The following initializes a linear triangular element
  //
  //    >> sfe = sfe_init(SfeObject(0), SFE_TRI_3, xs);
  //
  //  The following initializes a quadratic tetrahedral element but with linear
  //  geometry
  //
  //    >> etypes = [SFE_TET_10; SFE_TET_4];
  //    >> sfe = sfe_init(SfeObject(0), etypes, xs);
  //
  //  The following initializes a bi-linear quadrilateral element with
  //  user-provided gravity quadrature rule
  //
  //    >> gravrule = [1, 0.5, 0.5];
  //    >> sfe = sfe_init(SfeObject(0), SFE_QUAD_4, xs, int32(-1), gravrule);
  //
  //  See also SfeObject, ElementTypes, sfe_init_grad
  //  For clarity
  if ((b_sfe->etypes[0] > 0) && (iv[b_sfe->etypes[0] - 1] != 0)) {
    // obtain_elemnnodes - Obtain number of nodes per element given etype
    //
    //     nnodes = obtain_elemnnodes(etype)
    //
    //  This file was generated from update_nnodes_table
    //         % SFE_NODE_1
    //         % SFE_BAR_GL_2
    //         % SFE_BAR_GL_3
    //         % SFE_BAR_4
    //         % SFE_BAR_GL_4
    //         % SFE_BAR_5
    //         % SFE_BAR_GL_5
    //         % SFE_BAR_6
    //         % SFE_BAR_GL_6
    //         % SFE_BAR_7
    //         % SFE_BAR_GL_7
    //         % SFE_TRI_GL_3
    //         % SFE_TRI_GL_6
    //         % SFE_TRI_10
    //         % SFE_TRI_GL_10
    //         % SFE_TRI_15
    //         % SFE_TRI_GL_15
    //         % SFE_TRI_FEK_15
    //         % SFE_TRI_21
    //         % SFE_TRI_GL_21
    //         % SFE_TRI_FEK_21
    //         % SFE_TRI_28
    //         % SFE_TRI_GL_28
    //         % SFE_TRI_FEK_28
    //         % SFE_QUAD_GL_4
    //         % SFE_QUAD_GL_9
    //         % SFE_QUAD_16
    //         % SFE_QUAD_GL_16
    //         % SFE_QUAD_25
    //         % SFE_QUAD_GL_25
    //         % SFE_QUAD_36
    //         % SFE_QUAD_GL_36
    //         % SFE_QUAD_49
    //         % SFE_QUAD_GL_49
    //         % SFE_TET_GL_4
    //         % SFE_TET_GL_10
    //         % SFE_TET_20
    //         % SFE_TET_GL_20
    //         % SFE_TET_35
    //         % SFE_TET_GL_35
    //         % SFE_TET_FEK_35
    //         % SFE_TET_56
    //         % SFE_TET_GL_56
    //         % SFE_TET_FEK_56
    //         % SFE_TET_84
    //         % SFE_TET_GL_84
    //         % SFE_TET_FEK_84
    //         % SFE_PYRA_GL_5
    //         % SFE_PYRA_GL_14
    //         % SFE_PYRA_30
    //         % SFE_PYRA_GL_30
    //         % SFE_PYRA_55
    //         % SFE_PYRA_GL_55
    //         % SFE_PYRA_FEK_55
    //         % SFE_PYRA_91
    //         % SFE_PRISM_GL_6
    //         % SFE_PRISM_GL_18
    //         % SFE_PRISM_40
    //         % SFE_PRISM_GL_40
    //         % SFE_PRISM_75
    //         % SFE_PRISM_GL_75
    //         % SFE_PRISM_FEK_75
    //         % SFE_PRISM_126
    //         % SFE_PRISM_GL_126
    //         % SFE_PRISM_196
    //         % SFE_HEXA_GL_8
    //         % SFE_HEXA_GL_27
    //         % SFE_HEXA_64
    //         % SFE_HEXA_GL_64
    //         % SFE_HEXA_125
    //         % SFE_HEXA_GL_125
    //         % SFE_HEXA_216
    //         % SFE_HEXA_GL_216
    //         % SFE_HEXA_343
    //         % SFE_HEXA_GL_343
    cond = true;
  } else {
    cond = false;
  }
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(cond, "");
  //  potentially skip re-tabulating
  //  Compute phy. coordinates of qpoints
  sfe_idx_0_tmp_tmp = b_sfe->nqp;
  b_sfe->cs_phy.set_size(sfe_idx_0_tmp_tmp, xs.size(1));
  for (int32_T q{0}; q < sfe_idx_0_tmp_tmp; q++) {
    int32_T i;
    //  NOTE The following can be optimized efficiently due to the the upper
    //  bound of dimension (i.e., size(xs,2)) is known.
    i = xs.size(1);
    for (int32_T k{0}; k < i; k++) {
      real_T v;
      int32_T m;
      // interpolate_shape - Interpolate f with q-th shape function in the table
      //
      //    v = interpolate_shape(shapes, q, f)
      //    v = interpolate_shape(shapes, q, f, k)
      m = b_sfe->shapes_geom.size(1);
      v = b_sfe->shapes_geom[b_sfe->shapes_geom.size(1) * q] * xs[k];
      for (int32_T b_i{2}; b_i <= m; b_i++) {
        v += b_sfe->shapes_geom[(b_i + b_sfe->shapes_geom.size(1) * q) - 1] *
             xs[k + xs.size(1) * (b_i - 1)];
      }
      b_sfe->cs_phy[k + b_sfe->cs_phy.size(1) * q] = v;
    }
  }
  //  Compute Jacobian
}

static void bar_quadrules(int32_T degree, ::coder::array<real_T, 2U> &cs,
                          ::coder::array<real_T, 1U> &ws)
{
  //  bar_quadrules - Obtain quadrature points and weights of a bar element.
  //
  //     [cs, ws] = bar_quadrules
  //     [cs, ws] = bar_quadrules(degree)
  //
  //  Parameters
  //  ----------
  //   degree: the desired degree of accuracy of integration. Default is 1.
  //
  //  Returns
  //  -------
  //   cs: the natural coordinates of quadrature points (nqp-by-1).
  //   ws: weights for quadrature points (nqp-by-1).
  //
  //  Notes
  //  -----
  //  We normalize the natural coordinates to be between 0 and 1, instead
  //  of between -1 and 1. All the rules have positive weights.
  //
  //  See also tri_quadrules, quad_quadrules, tet_quadrules, prism_quadrules,
  //  hexa_quadrules, pyra_quadrules
  if (degree <= 1) {
    int32_T nqp;
    nqp = ::sfe_qrules::bar_deg1_qrule();
    cs.set_size(nqp, 1);
    ws.set_size(nqp);
    ::sfe_qrules::bar_deg1_qrule(&cs[0], &(ws.data())[0]);
  } else if (degree <= 3) {
    int32_T nqp;
    nqp = ::sfe_qrules::bar_deg3_qrule();
    cs.set_size(nqp, 1);
    ws.set_size(nqp);
    ::sfe_qrules::bar_deg3_qrule(&cs[0], &(ws.data())[0]);
  } else if (degree <= 5) {
    int32_T nqp;
    nqp = ::sfe_qrules::bar_deg5_qrule();
    cs.set_size(nqp, 1);
    ws.set_size(nqp);
    ::sfe_qrules::bar_deg5_qrule(&cs[0], &(ws.data())[0]);
  } else if (degree <= 7) {
    int32_T nqp;
    nqp = ::sfe_qrules::bar_deg7_qrule();
    cs.set_size(nqp, 1);
    ws.set_size(nqp);
    ::sfe_qrules::bar_deg7_qrule(&cs[0], &(ws.data())[0]);
  } else if (degree <= 9) {
    int32_T nqp;
    nqp = ::sfe_qrules::bar_deg9_qrule();
    cs.set_size(nqp, 1);
    ws.set_size(nqp);
    ::sfe_qrules::bar_deg9_qrule(&cs[0], &(ws.data())[0]);
  } else if (degree <= 11) {
    int32_T nqp;
    nqp = ::sfe_qrules::bar_deg11_qrule();
    cs.set_size(nqp, 1);
    ws.set_size(nqp);
    ::sfe_qrules::bar_deg11_qrule(&cs[0], &(ws.data())[0]);
  } else if (degree <= 13) {
    int32_T nqp;
    nqp = ::sfe_qrules::bar_deg13_qrule();
    cs.set_size(nqp, 1);
    ws.set_size(nqp);
    ::sfe_qrules::bar_deg13_qrule(&cs[0], &(ws.data())[0]);
  } else {
    int32_T nqp;
    if (degree > 15) {
      //  m2cWarning  Display warning message
      //
      //     m2cWarning(msg)
      //     m2cWarning(msg,A1,...,An)
      //     m2cWarning(warnID,___)
      //
      //  This function performs similar to MATLAB's built-in `warning` but it
      //  supports code generation in both MEX and LIB mode.
      //
      //  Notes
      //  -----
      //  The format must be a constant string during code-generation time.
      //
      //  See also warning, m2cError, m2cAssert
      m2cWarnMsgIdAndTxt("bar_quadrules:UnsupportedDegree",
                         "Only support up to degree 15");
    }
    nqp = ::sfe_qrules::bar_deg15_qrule();
    cs.set_size(nqp, 1);
    ws.set_size(nqp);
    ::sfe_qrules::bar_deg15_qrule(&cs[0], &(ws.data())[0]);
  }
}

static void hexa_125(real_T xi, real_T eta, real_T zeta, real_T sfvals[125],
                     real_T sdvals[375])
{
  // hexa_125 - Triquartic hexahedral element with equidistant points
  //     [sfvals,sdvals] = hexa_125(xi,eta,zeta)
  //
  //   Input:
  //      xi, eta, zeta: range between 0 and 1.
  //   Output:
  //      sfvals: vector of size 125-by-1
  //      sdvals: vector of size 125-by-3
  //
  //     nodes_nat_coors = hexa_125
  //   If no input argument, return natural coordinates of nodes
  //
  //   See also hexa_8, hexa_27, hexa_64, hexa_gl_64, hexa_gl_125, hexa_216,
  //   hexa_gl_216
  ::sfe_sfuncs::hexa_125_sfunc(xi, eta, zeta, &sfvals[0], &sdvals[0]);
}

static void hexa_216(real_T xi, real_T eta, real_T zeta, real_T sfvals[216],
                     real_T sdvals[648])
{
  // hexa_216 - Triquintic hexahedral element with equidistant points
  //     [sfvals,sdvals] = hexa_216(xi,eta,zeta)
  //
  //   Input:
  //      xi, eta, zeta: range between 0 and 1.
  //   Output:
  //      sfvals: vector of size 216-by-1
  //      sdvals: vector of size 216-by-3
  //
  //     nodes_nat_coors = hexa_216
  //   If no input argument, return natural coordinates of nodes
  //
  //   See also hexa_8, hexa_27, hexa_64, hexa_gl_64, hexa_125, hexa_gl_125,
  //   hexa_gl_216
  ::sfe_sfuncs::hexa_216_sfunc(xi, eta, zeta, &sfvals[0], &sdvals[0]);
}

static void hexa_343(real_T xi, real_T eta, real_T zeta, real_T sfvals[343],
                     real_T sdvals[1029])
{
  // hexa_343 - Trisextic hexahedral element with equidistant points
  //     [sfvals,sdvals] = hexa_343(xi,eta,zeta)
  //
  //   Input:
  //      xi, eta, zeta: range between 0 and 1.
  //   Output:
  //      sfvals: vector of size 343-by-1
  //      sdvals: vector of size 343-by-3
  //
  //     nodes_nat_coors = hexa_34
  //   If no input argument, return natural coordinates of nodes
  //
  //   See also hexa_8, hexa_27, hexa_64, hexa_gl_64, hexa_125, hexa_gl_125,
  //   hexa_gl_343
  ::sfe_sfuncs::hexa_343_sfunc(xi, eta, zeta, &sfvals[0], &sdvals[0]);
}

static void hexa_64(real_T xi, real_T eta, real_T zeta, real_T sfvals[64],
                    real_T sdvals[192])
{
  // hexa_64 - Tricubic hexahedral element with equidistant nodes
  //     [sfvals,sdvals] = hexa_64(xi,eta,zeta)
  //
  //   Input:
  //      xi, eta, zeta: range between 0 and 1.
  //   Output:
  //      sfvals: vector of size 64-by-1
  //      sdvals: vector of size 64-by-3
  //
  //     nodes_nat_coors = hexa_64
  //   If no input argument, return natural coordinates of nodes
  //
  //   See also hexa_8, hexa_27, hexa_gl_64, hexa_125, hexa_gl_125
  ::sfe_sfuncs::hexa_64_sfunc(xi, eta, zeta, &sfvals[0], &sdvals[0]);
}

static void hexa_gl_125(real_T xi, real_T eta, real_T zeta, real_T sfvals[125],
                        real_T sdvals[375])
{
  // hexa_gl_125 - Triquartic hexahedral element with Gauss-Lobatto points
  //     [sfvals,sdvals] = hexa_gl_125(xi,eta,zeta)
  //
  //   Input:
  //      xi, eta, zeta: range between 0 and 1.
  //   Output:
  //      sfvals: vector of size 125-by-1
  //      sdvals: vector of size 125-by-3
  //
  //     nodes_nat_coors = hexa_gl_125
  //   If no input argument, return natural coordinates of nodes
  //
  //   See also hexa_8, hexa_27, hexa_64, hexa_gl_64, hexa_125
  ::sfe_sfuncs::hexa_gl_125_sfunc(xi, eta, zeta, &sfvals[0], &sdvals[0]);
}

static void hexa_gl_216(real_T xi, real_T eta, real_T zeta, real_T sfvals[216],
                        real_T sdvals[648])
{
  // hexa_gl_216 - Triquintic hexahedral element with equidistant points
  //     [sfvals,sdvals] = hexa_gl_216(xi,eta,zeta)
  //
  //   Input:
  //      xi, eta, zeta: range between 0 and 1.
  //   Output:
  //      sfvals: vector of size 216-by-1
  //      sdvals: vector of size 216-by-3
  //
  //     nodes_nat_coors = hexa_gl_216
  //   If no input argument, return natural coordinates of nodes
  //
  //   See also hexa_8, hexa_27, hexa_64, hexa_gl_64, hexa_125, hexa_gl_125,
  //   hexa_216
  ::sfe_sfuncs::hexa_gl_216_sfunc(xi, eta, zeta, &sfvals[0], &sdvals[0]);
}

static void hexa_gl_343(real_T xi, real_T eta, real_T zeta, real_T sfvals[343],
                        real_T sdvals[1029])
{
  // hexa_gl_343 - Trisextic hexahedral element with equidistant points
  //     [sfvals,sdvals] = hexa_gl_343(xi,eta,zeta)
  //
  //   Input:
  //      xi, eta, zeta: range between 0 and 1.
  //   Output:
  //      sfvals: vector of size 343-by-1
  //      sdvals: vector of size 343-by-3
  //
  //     nodes_nat_coors = hexa_gl_343
  //   If no input argument, return natural coordinates of nodes
  //
  //   See also hexa_8, hexa_27, hexa_64, hexa_gl_64, hexa_125, hexa_gl_125,
  //   hexa_343
  ::sfe_sfuncs::hexa_gl_343_sfunc(xi, eta, zeta, &sfvals[0], &sdvals[0]);
}

static void hexa_gl_64(real_T xi, real_T eta, real_T zeta, real_T sfvals[64],
                       real_T sdvals[192])
{
  // hexa_gl_64 - Tricubic hexahedral element with Gauss-Lobatto nodes
  //     [sfvals,sdvals] = hexa_gl_64(xi,eta,zeta)
  //
  //   Input:
  //      xi, eta, zeta: range between 0 and 1.
  //   Output:
  //      sfvals: vector of size 64-by-1
  //      sdvals: vector of size 64-by-3
  //
  //     nodes_nat_coors = hexa_gl_64
  //   If no input argument, return natural coordinates of nodes
  //
  //   See also hexa_8, hexa_27, hexa_64, hexa_125, hexa_gl_125
  ::sfe_sfuncs::hexa_gl_64_sfunc(xi, eta, zeta, &sfvals[0], &sdvals[0]);
}

static uint8_T obtain_facets(int32_T etype, int8_T facetid)
{
  // obtain_facets - Query facet information
  //
  //     nfacets = obtain_facets(etype)
  //     facettype = obtain_facets(etype, facetid)
  //     [facettype, lids] = obtain_facets(etype, facetid)
  //
  //  PARAMETERS
  //  ----------
  //     etype:          Element type enums
  //     facetid:        Local facet IDs
  //
  //  RETURNS
  //  -------
  //  If only etype is provided, then this function returns
  //  a single number `nfacets`, which is the number
  //  of facets of an element.
  //
  //  If facet ID is provided (1:nfacets), then this function
  //  returns the facet element type of `facetid`. Optionally,
  //  it can also return the local IDs of the requested facet
  //
  //  This file was generated from update_facets_table
  //  MATLAB code ends
  const static std::vector<std::vector<uint8_T>> FACETS{
      //();
      {1, 1},                         // SFE_BAR_2();
      {},                             // 37();
      {},                             // 38();
      {},                             // 39();
      {1, 1},                         // SFE_BAR_3();
      {},                             // 41();
      {},                             // 42();
      {},                             // 43();
      {1, 1},                         // SFE_BAR_4();
      {1, 1},                         // SFE_BAR_FEK_4();
      {},                             // 46();
      {},                             // 47();
      {1, 1},                         // SFE_BAR_5();
      {1, 1},                         // SFE_BAR_FEK_5();
      {},                             // 50();
      {},                             // 51();
      {1, 1},                         // SFE_BAR_6();
      {1, 1},                         // SFE_BAR_FEK_6();
      {},                             // 54();
      {},                             // 55();
      {1, 1},                         // SFE_BAR_7();
      {1, 1},                         // SFE_BAR_FEK_7();
      {},                             // 58();
      {},                             // 59();
      {},                             // 60();
      {},                             // 61();
      {},                             // 62();
      {},                             // 63();
      {},                             // 64();
      {},                             // 65();
      {},                             // 66();
      {},                             // 67();
      {36, 36, 36},                   // SFE_TRI_3();
      {},                             // 69();
      {},                             // 70();
      {},                             // 71();
      {40, 40, 40},                   // SFE_TRI_6();
      {},                             // 73();
      {},                             // 74();
      {},                             // 75();
      {44, 44, 44},                   // SFE_TRI_10();
      {45, 45, 45},                   // SFE_TRI_FEK_10();
      {},                             // 78();
      {},                             // 79();
      {48, 48, 48},                   // SFE_TRI_15();
      {49, 49, 49},                   // SFE_TRI_GL_15();
      {48, 48, 48},                   // SFE_TRI_FEK_15();
      {},                             // 83();
      {52, 52, 52},                   // SFE_TRI_21();
      {53, 53, 53},                   // SFE_TRI_GL_21();
      {52, 52, 52},                   // SFE_TRI_FEK_21();
      {},                             // 87();
      {56, 56, 56},                   // SFE_TRI_28();
      {57, 57, 57},                   // SFE_TRI_GL_28();
      {56, 56, 56},                   // SFE_TRI_FEK_28();
      {},                             // 91();
      {},                             // 92();
      {},                             // 93();
      {},                             // 94();
      {},                             // 95();
      {},                             // 96();
      {},                             // 97();
      {},                             // 98();
      {},                             // 99();
      {36, 36, 36, 36},               // SFE_QUAD_4();
      {},                             // 101();
      {},                             // 102();
      {},                             // 103();
      {40, 40, 40, 40},               // SFE_QUAD_9();
      {},                             // 105();
      {},                             // 106();
      {},                             // 107();
      {44, 44, 44, 44},               // SFE_QUAD_16();
      {45, 45, 45, 45},               // SFE_QUAD_FEK_16();
      {},                             // 110();
      {},                             // 111();
      {48, 48, 48, 48},               // SFE_QUAD_25();
      {49, 49, 49, 49},               // SFE_QUAD_FEK_25();
      {},                             // 114();
      {},                             // 115();
      {52, 52, 52, 52},               // SFE_QUAD_36();
      {53, 53, 53, 53},               // SFE_QUAD_FEK_36();
      {},                             // 118();
      {},                             // 119();
      {56, 56, 56, 56},               // SFE_QUAD_49();
      {57, 57, 57, 57},               // SFE_QUAD_FEK_49();
      {},                             // 122();
      {},                             // 123();
      {},                             // 124();
      {},                             // 125();
      {},                             // 126();
      {},                             // 127();
      {},                             // 128();
      {},                             // 129();
      {},                             // 130();
      {},                             // 131();
      {68, 68, 68, 68},               // SFE_TET_4();
      {},                             // 133();
      {},                             // 134();
      {},                             // 135();
      {72, 72, 72, 72},               // SFE_TET_10();
      {},                             // 137();
      {},                             // 138();
      {},                             // 139();
      {76, 76, 76, 76},               // SFE_TET_20();
      {77, 77, 77, 77},               // SFE_TET_FEK_20();
      {},                             // 142();
      {},                             // 143();
      {80, 80, 80, 80},               // SFE_TET_35();
      {81, 81, 81, 81},               // SFE_TET_GL_35();
      {82, 82, 82, 82},               // SFE_TET_FEK_35();
      {},                             // 147();
      {84, 84, 84, 84},               // SFE_TET_56();
      {85, 85, 85, 85},               // SFE_TET_GL_56();
      {86, 86, 86, 86},               // SFE_TET_FEK_56();
      {},                             // 151();
      {88, 88, 88, 88},               // SFE_TET_84();
      {89, 89, 89, 89},               // SFE_TET_GL_84();
      {90, 90, 90, 90},               // SFE_TET_FEK_84();
      {},                             // 155();
      {},                             // 156();
      {},                             // 157();
      {},                             // 158();
      {},                             // 159();
      {},                             // 160();
      {},                             // 161();
      {},                             // 162();
      {},                             // 163();
      {100, 68, 68, 68, 68},          // SFE_PYRA_5();
      {},                             // 165();
      {},                             // 166();
      {},                             // 167();
      {104, 72, 72, 72, 72},          // SFE_PYRA_14();
      {},                             // 169();
      {},                             // 170();
      {},                             // 171();
      {108, 76, 76, 76, 76},          // SFE_PYRA_30();
      {109, 77, 77, 77, 77},          // SFE_PYRA_FEK_30();
      {},                             // 174();
      {},                             // 175();
      {112, 80, 80, 80, 80},          // SFE_PYRA_55();
      {113, 81, 81, 81, 81},          // SFE_PYRA_GL_55();
      {112, 82, 82, 82, 82},          // SFE_PYRA_FEK_55();
      {},                             // 179();
      {116, 84, 84, 84, 84},          // SFE_PYRA_91();
      {},                             // 181();
      {},                             // 182();
      {},                             // 183();
      {},                             // 184();
      {},                             // 185();
      {},                             // 186();
      {},                             // 187();
      {},                             // 188();
      {},                             // 189();
      {},                             // 190();
      {},                             // 191();
      {},                             // 192();
      {},                             // 193();
      {},                             // 194();
      {},                             // 195();
      {100, 100, 100, 68, 68},        // SFE_PRISM_6();
      {},                             // 197();
      {},                             // 198();
      {},                             // 199();
      {104, 104, 104, 72, 72},        // SFE_PRISM_18();
      {},                             // 201();
      {},                             // 202();
      {},                             // 203();
      {108, 108, 108, 76, 76},        // SFE_PRISM_40();
      {109, 109, 109, 77, 77},        // SFE_PRISM_FEK_40();
      {},                             // 206();
      {},                             // 207();
      {112, 112, 112, 80, 80},        // SFE_PRISM_75();
      {113, 113, 113, 81, 81},        // SFE_PRISM_GL_75();
      {112, 112, 112, 82, 82},        // SFE_PRISM_FEK_75();
      {},                             // 211();
      {116, 116, 116, 84, 84},        // SFE_PRISM_126();
      {117, 117, 117, 85, 85},        // SFE_PRISM_GL_126();
      {},                             // 214();
      {},                             // 215();
      {120, 120, 120, 88, 88},        // SFE_PRISM_196();
      {},                             // 217();
      {},                             // 218();
      {},                             // 219();
      {},                             // 220();
      {},                             // 221();
      {},                             // 222();
      {},                             // 223();
      {},                             // 224();
      {},                             // 225();
      {},                             // 226();
      {},                             // 227();
      {100, 100, 100, 100, 100, 100}, // SFE_HEXA_8();
      {},                             // 229();
      {},                             // 230();
      {},                             // 231();
      {104, 104, 104, 104, 104, 104}, // SFE_HEXA_27();
      {},                             // 233();
      {},                             // 234();
      {},                             // 235();
      {108, 108, 108, 108, 108, 108}, // SFE_HEXA_64();
      {109, 109, 109, 109, 109, 109}, // SFE_HEXA_FEK_64();
      {},                             // 238();
      {},                             // 239();
      {112, 112, 112, 112, 112, 112}, // SFE_HEXA_125();
      {113, 113, 113, 113, 113, 113}, // SFE_HEXA_FEK_125();
      {},                             // 242();
      {},                             // 243();
      {116, 116, 116, 116, 116, 116}, // SFE_HEXA_216();
      {117, 117, 117, 117, 117, 117}, // SFE_HEXA_FEK_216();
      {},                             // 246();
      {},                             // 247();
      {120, 120, 120, 120, 120, 120}, // SFE_HEXA_343();
      {121, 121, 121, 121, 121, 121}, // SFE_HEXA_FEK_343();
  };                                  //();
  const static std::vector<std::vector<std::vector<int16_T>>> LIDS{
      //();
      {{1}, {2}},                                 // SFE_BAR_2();
      {{}},                                       // 37();
      {{}},                                       // 38();
      {{}},                                       // 39();
      {{1}, {2}},                                 // SFE_BAR_3();
      {{}},                                       // 41();
      {{}},                                       // 42();
      {{}},                                       // 43();
      {{1}, {2}},                                 // SFE_BAR_4();
      {{1}, {2}},                                 // SFE_BAR_FEK_4();
      {{}},                                       // 46();
      {{}},                                       // 47();
      {{1}, {2}},                                 // SFE_BAR_5();
      {{1}, {2}},                                 // SFE_BAR_FEK_5();
      {{}},                                       // 50();
      {{}},                                       // 51();
      {{1}, {2}},                                 // SFE_BAR_6();
      {{1}, {2}},                                 // SFE_BAR_FEK_6();
      {{}},                                       // 54();
      {{}},                                       // 55();
      {{1}, {2}},                                 // SFE_BAR_7();
      {{1}, {2}},                                 // SFE_BAR_FEK_7();
      {{}},                                       // 58();
      {{}},                                       // 59();
      {{}},                                       // 60();
      {{}},                                       // 61();
      {{}},                                       // 62();
      {{}},                                       // 63();
      {{}},                                       // 64();
      {{}},                                       // 65();
      {{}},                                       // 66();
      {{}},                                       // 67();
      {{1, 2}, {2, 3}, {3, 1}},                   // SFE_TRI_3();
      {{}},                                       // 69();
      {{}},                                       // 70();
      {{}},                                       // 71();
      {{1, 2, 4}, {2, 3, 5}, {3, 1, 6}},          // SFE_TRI_6();
      {{}},                                       // 73();
      {{}},                                       // 74();
      {{}},                                       // 75();
      {{1, 2, 4, 5}, {2, 3, 6, 7}, {3, 1, 8, 9}}, // SFE_TRI_10();
      {{1, 2, 4, 5}, {2, 3, 6, 7}, {3, 1, 8, 9}}, // SFE_TRI_FEK_10();
      {{}},                                       // 78();
      {{}},                                       // 79();
      {{1, 2, 4, 5, 6}, {2, 3, 7, 8, 9}, {3, 1, 10, 11, 12}}, // SFE_TRI_15();
      {{1, 2, 4, 5, 6},
       {2, 3, 7, 8, 9},
       {3, 1, 10, 11, 12}}, // SFE_TRI_GL_15();
      {{1, 2, 4, 5, 6},
       {2, 3, 7, 8, 9},
       {3, 1, 10, 11, 12}}, // SFE_TRI_FEK_15();
      {{}},                 // 83();
      {{1, 2, 4, 5, 6, 7},
       {2, 3, 8, 9, 10, 11},
       {3, 1, 12, 13, 14, 15}}, // SFE_TRI_21();
      {{1, 2, 4, 5, 6, 7},
       {2, 3, 8, 9, 10, 11},
       {3, 1, 12, 13, 14, 15}}, // SFE_TRI_GL_21();
      {{1, 2, 4, 5, 6, 7},
       {2, 3, 8, 9, 10, 11},
       {3, 1, 12, 13, 14, 15}}, // SFE_TRI_FEK_21();
      {{}},                     // 87();
      {{1, 2, 4, 5, 6, 7, 8},
       {2, 3, 9, 10, 11, 12, 13},
       {3, 1, 14, 15, 16, 17, 18}}, // SFE_TRI_28();
      {{1, 2, 4, 5, 6, 7, 8},
       {2, 3, 9, 10, 11, 12, 13},
       {3, 1, 14, 15, 16, 17, 18}}, // SFE_TRI_GL_28();
      {{1, 2, 4, 5, 6, 7, 8},
       {2, 3, 9, 10, 11, 12, 13},
       {3, 1, 14, 15, 16, 17, 18}},                 // SFE_TRI_FEK_28();
      {{}},                                         // 91();
      {{}},                                         // 92();
      {{}},                                         // 93();
      {{}},                                         // 94();
      {{}},                                         // 95();
      {{}},                                         // 96();
      {{}},                                         // 97();
      {{}},                                         // 98();
      {{}},                                         // 99();
      {{1, 2}, {2, 3}, {3, 4}, {4, 1}},             // SFE_QUAD_4();
      {{}},                                         // 101();
      {{}},                                         // 102();
      {{}},                                         // 103();
      {{1, 2, 5}, {2, 3, 6}, {3, 4, 7}, {4, 1, 8}}, // SFE_QUAD_9();
      {{}},                                         // 105();
      {{}},                                         // 106();
      {{}},                                         // 107();
      {{1, 2, 5, 6},
       {2, 3, 7, 8},
       {3, 4, 9, 10},
       {4, 1, 11, 12}}, // SFE_QUAD_16();
      {{1, 2, 5, 6},
       {2, 3, 7, 8},
       {3, 4, 9, 10},
       {4, 1, 11, 12}}, // SFE_QUAD_FEK_16();
      {{}},             // 110();
      {{}},             // 111();
      {{1, 2, 5, 6, 7},
       {2, 3, 8, 9, 10},
       {3, 4, 11, 12, 13},
       {4, 1, 14, 15, 16}}, // SFE_QUAD_25();
      {{1, 2, 5, 6, 7},
       {2, 3, 8, 9, 10},
       {3, 4, 11, 12, 13},
       {4, 1, 14, 15, 16}}, // SFE_QUAD_FEK_25();
      {{}},                 // 114();
      {{}},                 // 115();
      {{1, 2, 5, 6, 7, 8},
       {2, 3, 9, 10, 11, 12},
       {3, 4, 13, 14, 15, 16},
       {4, 1, 17, 18, 19, 20}}, // SFE_QUAD_36();
      {{1, 2, 5, 6, 7, 8},
       {2, 3, 9, 10, 11, 12},
       {3, 4, 13, 14, 15, 16},
       {4, 1, 17, 18, 19, 20}}, // SFE_QUAD_FEK_36();
      {{}},                     // 118();
      {{}},                     // 119();
      {{1, 2, 5, 6, 7, 8, 9},
       {2, 3, 10, 11, 12, 13, 14},
       {3, 4, 15, 16, 17, 18, 19},
       {4, 1, 20, 21, 22, 23, 24}}, // SFE_QUAD_49();
      {{1, 2, 5, 6, 7, 8, 9},
       {2, 3, 10, 11, 12, 13, 14},
       {3, 4, 15, 16, 17, 18, 19},
       {4, 1, 20, 21, 22, 23, 24}},                 // SFE_QUAD_FEK_49();
      {{}},                                         // 122();
      {{}},                                         // 123();
      {{}},                                         // 124();
      {{}},                                         // 125();
      {{}},                                         // 126();
      {{}},                                         // 127();
      {{}},                                         // 128();
      {{}},                                         // 129();
      {{}},                                         // 130();
      {{}},                                         // 131();
      {{1, 3, 2}, {1, 2, 4}, {2, 3, 4}, {3, 1, 4}}, // SFE_TET_4();
      {{}},                                         // 133();
      {{}},                                         // 134();
      {{}},                                         // 135();
      {{1, 3, 2, 7, 6, 5},
       {1, 2, 4, 5, 9, 8},
       {2, 3, 4, 6, 10, 9},
       {3, 1, 4, 7, 8, 10}}, // SFE_TET_10();
      {{}},                  // 137();
      {{}},                  // 138();
      {{}},                  // 139();
      {{1, 3, 2, 10, 9, 8, 7, 6, 5, 17},
       {1, 2, 4, 5, 6, 13, 14, 12, 11, 18},
       {2, 3, 4, 7, 8, 15, 16, 14, 13, 19},
       {3, 1, 4, 9, 10, 11, 12, 16, 15, 20}}, // SFE_TET_20();
      {{1, 3, 2, 10, 9, 8, 7, 6, 5, 17},
       {1, 2, 4, 5, 6, 13, 14, 12, 11, 18},
       {2, 3, 4, 7, 8, 15, 16, 14, 13, 19},
       {3, 1, 4, 9, 10, 11, 12, 16, 15, 20}}, // SFE_TET_FEK_20();
      {{}},                                   // 142();
      {{}},                                   // 143();
      {{1, 3, 2, 13, 12, 11, 10, 9, 8, 7, 6, 5, 23, 25, 24},
       {1, 2, 4, 5, 6, 7, 17, 18, 19, 16, 15, 14, 26, 27, 28},
       {2, 3, 4, 8, 9, 10, 20, 21, 22, 19, 18, 17, 29, 30, 31},
       {3, 1, 4, 11, 12, 13, 14, 15, 16, 22, 21, 20, 32, 33,
        34}}, // SFE_TET_35();
      {{1, 3, 2, 13, 12, 11, 10, 9, 8, 7, 6, 5, 23, 25, 24},
       {1, 2, 4, 5, 6, 7, 17, 18, 19, 16, 15, 14, 26, 27, 28},
       {2, 3, 4, 8, 9, 10, 20, 21, 22, 19, 18, 17, 29, 30, 31},
       {3, 1, 4, 11, 12, 13, 14, 15, 16, 22, 21, 20, 32, 33,
        34}}, // SFE_TET_GL_35();
      {{1, 3, 2, 13, 12, 11, 10, 9, 8, 7, 6, 5, 23, 25, 24},
       {1, 2, 4, 5, 6, 7, 17, 18, 19, 16, 15, 14, 26, 27, 28},
       {2, 3, 4, 8, 9, 10, 20, 21, 22, 19, 18, 17, 29, 30, 31},
       {3, 1, 4, 11, 12, 13, 14, 15, 16, 22, 21, 20, 32, 33,
        34}}, // SFE_TET_FEK_35();
      {{}},   // 147();
      {{1, 3, 2, 16, 15, 14, 13, 12, 11, 10, 9,
        8, 7, 6, 5,  29, 34, 33, 32, 31, 30},
       {1,  2,  4,  5,  6,  7,  8,  21, 22, 23, 24,
        20, 19, 18, 17, 35, 36, 37, 38, 39, 40},
       {2,  3,  4,  9,  10, 11, 12, 25, 26, 27, 28,
        24, 23, 22, 21, 41, 42, 43, 44, 45, 46},
       {3,  1,  4,  13, 14, 15, 16, 17, 18, 19, 20,
        28, 27, 26, 25, 47, 48, 49, 50, 51, 52}}, // SFE_TET_56();
      {{1, 3, 2, 16, 15, 14, 13, 12, 11, 10, 9,
        8, 7, 6, 5,  29, 34, 33, 32, 31, 30},
       {1,  2,  4,  5,  6,  7,  8,  21, 22, 23, 24,
        20, 19, 18, 17, 35, 36, 37, 38, 39, 40},
       {2,  3,  4,  9,  10, 11, 12, 25, 26, 27, 28,
        24, 23, 22, 21, 41, 42, 43, 44, 45, 46},
       {3,  1,  4,  13, 14, 15, 16, 17, 18, 19, 20,
        28, 27, 26, 25, 47, 48, 49, 50, 51, 52}}, // SFE_TET_GL_56();
      {{1, 3, 2, 16, 15, 14, 13, 12, 11, 10, 9,
        8, 7, 6, 5,  29, 34, 33, 32, 31, 30},
       {1,  2,  4,  5,  6,  7,  8,  21, 22, 23, 24,
        20, 19, 18, 17, 35, 36, 37, 38, 39, 40},
       {2,  3,  4,  9,  10, 11, 12, 25, 26, 27, 28,
        24, 23, 22, 21, 41, 42, 43, 44, 45, 46},
       {3,  1,  4,  13, 14, 15, 16, 17, 18, 19, 20,
        28, 27, 26, 25, 47, 48, 49, 50, 51, 52}}, // SFE_TET_FEK_56();
      {{}},                                       // 151();
      {{1, 3, 2, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9,
        8, 7, 6, 5,  35, 43, 42, 41, 40, 39, 38, 37, 36, 44},
       {1,  2,  4,  5,  6,  7,  8,  9,  25, 26, 27, 28, 29, 24,
        23, 22, 21, 20, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54},
       {2,  3,  4,  10, 11, 12, 13, 14, 30, 31, 32, 33, 34, 29,
        28, 27, 26, 25, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64},
       {3,  1,  4,  15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 34, 33,
        32, 31, 30, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74}}, // SFE_TET_84();
      {{1, 3, 2, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9,
        8, 7, 6, 5,  35, 43, 42, 41, 40, 39, 38, 37, 36, 44},
       {1,  2,  4,  5,  6,  7,  8,  9,  25, 26, 27, 28, 29, 24,
        23, 22, 21, 20, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54},
       {2,  3,  4,  10, 11, 12, 13, 14, 30, 31, 32, 33, 34, 29,
        28, 27, 26, 25, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64},
       {3,  1,  4,  15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 34, 33,
        32, 31, 30, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74}}, // SFE_TET_GL_84();
      {{1, 3, 2, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9,
        8, 7, 6, 5,  35, 43, 42, 41, 40, 39, 38, 37, 36, 44},
       {1,  2,  4,  5,  6,  7,  8,  9,  25, 26, 27, 28, 29, 24,
        23, 22, 21, 20, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54},
       {2,  3,  4,  10, 11, 12, 13, 14, 30, 31, 32, 33, 34, 29,
        28, 27, 26, 25, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64},
       {3,  1,  4,  15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 34, 33,
        32, 31, 30, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74}}, // SFE_TET_FEK_84();
      {{}},                                                   // 155();
      {{}},                                                   // 156();
      {{}},                                                   // 157();
      {{}},                                                   // 158();
      {{}},                                                   // 159();
      {{}},                                                   // 160();
      {{}},                                                   // 161();
      {{}},                                                   // 162();
      {{}},                                                   // 163();
      {{1, 4, 3, 2},
       {1, 2, 5, 0},
       {2, 3, 5, 0},
       {3, 4, 5, 0},
       {4, 1, 5, 0}}, // SFE_PYRA_5();
      {{}},           // 165();
      {{}},           // 166();
      {{}},           // 167();
      {{1, 4, 3, 2, 9, 8, 7, 6, 14},
       {1, 2, 5, 6, 11, 10, 0, 0, 0},
       {2, 3, 5, 7, 12, 11, 0, 0, 0},
       {3, 4, 5, 8, 13, 12, 0, 0, 0},
       {4, 1, 5, 9, 10, 13, 0, 0, 0}}, // SFE_PYRA_14();
      {{}},                            // 169();
      {{}},                            // 170();
      {{}},                            // 171();
      {{1, 4, 3, 2, 13, 12, 11, 10, 9, 8, 7, 6, 22, 25, 24, 23},
       {1, 2, 5, 6, 7, 16, 17, 15, 14, 26, 0, 0, 0, 0, 0, 0},
       {2, 3, 5, 8, 9, 18, 19, 17, 16, 27, 0, 0, 0, 0, 0, 0},
       {3, 4, 5, 10, 11, 20, 21, 19, 18, 28, 0, 0, 0, 0, 0, 0},
       {4, 1, 5, 12, 13, 14, 15, 21, 20, 29, 0, 0, 0, 0, 0,
        0}}, // SFE_PYRA_30();
      {{1, 4, 3, 2, 13, 12, 11, 10, 9, 8, 7, 6, 22, 25, 24, 23},
       {1, 2, 5, 6, 7, 16, 17, 15, 14, 26, 0, 0, 0, 0, 0, 0},
       {2, 3, 5, 8, 9, 18, 19, 17, 16, 27, 0, 0, 0, 0, 0, 0},
       {3, 4, 5, 10, 11, 20, 21, 19, 18, 28, 0, 0, 0, 0, 0, 0},
       {4, 1, 5, 12, 13, 14, 15, 21, 20, 29, 0, 0, 0, 0, 0,
        0}}, // SFE_PYRA_FEK_30();
      {{}},  // 174();
      {{}},  // 175();
      {{1, 4, 3, 2,  17, 16, 15, 14, 13, 12, 11, 10, 9,
        8, 7, 6, 30, 37, 36, 35, 34, 33, 32, 31, 38},
       {1,  2,  5, 6, 7, 8, 21, 22, 23, 20, 19, 18, 39,
        40, 41, 0, 0, 0, 0, 0,  0,  0,  0,  0,  0},
       {2,  3,  5, 9, 10, 11, 24, 25, 26, 23, 22, 21, 42,
        43, 44, 0, 0, 0,  0,  0,  0,  0,  0,  0,  0},
       {3,  4,  5, 12, 13, 14, 27, 28, 29, 26, 25, 24, 45,
        46, 47, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0},
       {4,  1,  5, 15, 16, 17, 18, 19, 20, 29, 28, 27, 48,
        49, 50, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0}}, // SFE_PYRA_55();
      {{1, 4, 3, 2,  17, 16, 15, 14, 13, 12, 11, 10, 9,
        8, 7, 6, 30, 37, 36, 35, 34, 33, 32, 31, 38},
       {1,  2,  5, 6, 7, 8, 21, 22, 23, 20, 19, 18, 39,
        40, 41, 0, 0, 0, 0, 0,  0,  0,  0,  0,  0},
       {2,  3,  5, 9, 10, 11, 24, 25, 26, 23, 22, 21, 42,
        43, 44, 0, 0, 0,  0,  0,  0,  0,  0,  0,  0},
       {3,  4,  5, 12, 13, 14, 27, 28, 29, 26, 25, 24, 45,
        46, 47, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0},
       {4,  1,  5, 15, 16, 17, 18, 19, 20, 29, 28, 27, 48,
        49, 50, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0}}, // SFE_PYRA_GL_55();
      {{1, 4, 3, 2,  17, 16, 15, 14, 13, 12, 11, 10, 9,
        8, 7, 6, 30, 37, 36, 35, 34, 33, 32, 31, 38},
       {1,  2,  5, 6, 7, 8, 21, 22, 23, 20, 19, 18, 39,
        40, 41, 0, 0, 0, 0, 0,  0,  0,  0,  0,  0},
       {2,  3,  5, 9, 10, 11, 24, 25, 26, 23, 22, 21, 42,
        43, 44, 0, 0, 0,  0,  0,  0,  0,  0,  0,  0},
       {3,  4,  5, 12, 13, 14, 27, 28, 29, 26, 25, 24, 45,
        46, 47, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0},
       {4,  1,  5, 15, 16, 17, 18, 19, 20, 29, 28, 27, 48,
        49, 50, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0}}, // SFE_PYRA_FEK_55();
      {{}},                                             // 179();
      {{1, 4, 3,  2,  21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9,  8,
        7, 6, 38, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 50, 53, 52, 51},
       {1,  2,  5,  6, 7, 8, 9, 26, 27, 28, 29, 25, 24, 23, 22, 54, 55, 56,
        57, 58, 59, 0, 0, 0, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
       {2,  3,  5,  10, 11, 12, 13, 30, 31, 32, 33, 29, 28, 27, 26, 60, 61, 62,
        63, 64, 65, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
       {3,  4,  5,  14, 15, 16, 17, 34, 35, 36, 37, 33, 32, 31, 30, 66, 67, 68,
        69, 70, 71, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
       {4,  1,  5,  18, 19, 20, 21, 22, 23, 24, 25, 37,
        36, 35, 34, 72, 73, 74, 75, 76, 77, 0,  0,  0,
        0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0}}, // SFE_PYRA_91();
      {{}},                                              // 181();
      {{}},                                              // 182();
      {{}},                                              // 183();
      {{}},                                              // 184();
      {{}},                                              // 185();
      {{}},                                              // 186();
      {{}},                                              // 187();
      {{}},                                              // 188();
      {{}},                                              // 189();
      {{}},                                              // 190();
      {{}},                                              // 191();
      {{}},                                              // 192();
      {{}},                                              // 193();
      {{}},                                              // 194();
      {{}},                                              // 195();
      {{1, 2, 5, 4},
       {2, 3, 6, 5},
       {3, 1, 4, 6},
       {1, 3, 2, 0},
       {4, 5, 6, 0}}, // SFE_PRISM_6();
      {{}},           // 197();
      {{}},           // 198();
      {{}},           // 199();
      {{1, 2, 5, 4, 7, 11, 13, 10, 16},
       {2, 3, 6, 5, 8, 12, 14, 11, 17},
       {3, 1, 4, 6, 9, 10, 15, 12, 18},
       {1, 3, 2, 9, 8, 7, 0, 0, 0},
       {4, 5, 6, 13, 14, 15, 0, 0, 0}}, // SFE_PRISM_18();
      {{}},                             // 201();
      {{}},                             // 202();
      {{}},                             // 203();
      {{1, 2, 5, 4, 7, 8, 15, 16, 20, 19, 14, 13, 26, 27, 28, 29},
       {2, 3, 6, 5, 9, 10, 17, 18, 22, 21, 16, 15, 30, 31, 32, 33},
       {3, 1, 4, 6, 11, 12, 13, 14, 24, 23, 18, 17, 34, 35, 36, 37},
       {1, 3, 2, 12, 11, 10, 9, 8, 7, 25, 0, 0, 0, 0, 0, 0},
       {4, 5, 6, 19, 20, 21, 22, 23, 24, 38, 0, 0, 0, 0, 0,
        0}}, // SFE_PRISM_40();
      {{1, 2, 5, 4, 7, 8, 15, 16, 20, 19, 14, 13, 26, 27, 28, 29},
       {2, 3, 6, 5, 9, 10, 17, 18, 22, 21, 16, 15, 30, 31, 32, 33},
       {3, 1, 4, 6, 11, 12, 13, 14, 24, 23, 18, 17, 34, 35, 36, 37},
       {1, 3, 2, 12, 11, 10, 9, 8, 7, 25, 0, 0, 0, 0, 0, 0},
       {4, 5, 6, 19, 20, 21, 22, 23, 24, 38, 0, 0, 0, 0, 0,
        0}}, // SFE_PRISM_FEK_40();
      {{}},  // 206();
      {{}},  // 207();
      {{1,  2,  5,  4,  7,  8,  9,  19, 20, 21, 27, 26, 25,
        18, 17, 16, 37, 38, 39, 40, 41, 42, 43, 44, 45},
       {2,  3,  6,  5,  10, 11, 12, 22, 23, 24, 30, 29, 28,
        21, 20, 19, 46, 47, 48, 49, 50, 51, 52, 53, 54},
       {3,  1,  4,  6,  13, 14, 15, 16, 17, 18, 33, 32, 31,
        24, 23, 22, 55, 56, 57, 58, 59, 60, 61, 62, 63},
       {1,  3,  2, 15, 14, 13, 12, 11, 10, 9, 8, 7, 34,
        36, 35, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0},
       {4,  5,  6, 25, 26, 27, 28, 29, 30, 31, 32, 33, 64,
        65, 66, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0}}, // SFE_PRISM_75();
      {{1,  2,  5,  4,  7,  8,  9,  19, 20, 21, 27, 26, 25,
        18, 17, 16, 37, 38, 39, 40, 41, 42, 43, 44, 45},
       {2,  3,  6,  5,  10, 11, 12, 22, 23, 24, 30, 29, 28,
        21, 20, 19, 46, 47, 48, 49, 50, 51, 52, 53, 54},
       {3,  1,  4,  6,  13, 14, 15, 16, 17, 18, 33, 32, 31,
        24, 23, 22, 55, 56, 57, 58, 59, 60, 61, 62, 63},
       {1,  3,  2, 15, 14, 13, 12, 11, 10, 9, 8, 7, 34,
        36, 35, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0},
       {4,  5,  6, 25, 26, 27, 28, 29, 30, 31, 32, 33, 64,
        65, 66, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0}}, // SFE_PRISM_GL_75();
      {{1,  2,  5,  4,  7,  8,  9,  19, 20, 21, 27, 26, 25,
        18, 17, 16, 37, 38, 39, 40, 41, 42, 43, 44, 45},
       {2,  3,  6,  5,  10, 11, 12, 22, 23, 24, 30, 29, 28,
        21, 20, 19, 46, 47, 48, 49, 50, 51, 52, 53, 54},
       {3,  1,  4,  6,  13, 14, 15, 16, 17, 18, 33, 32, 31,
        24, 23, 22, 55, 56, 57, 58, 59, 60, 61, 62, 63},
       {1,  3,  2, 15, 14, 13, 12, 11, 10, 9, 8, 7, 34,
        36, 35, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0},
       {4,  5,  6, 25, 26, 27, 28, 29, 30, 31, 32, 33, 64,
        65, 66, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0}}, // SFE_PRISM_FEK_75();
      {{}},                                             // 211();
      {{1,  2,  5,  4,  7,  8,  9,  10, 23, 24, 25, 26, 34, 33, 32, 31, 24, 23,
        22, 21, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58},
       {2,  3,  6,  5,  11, 12, 13, 14, 27, 28, 29, 30, 38, 37, 36, 35, 26, 25,
        24, 23, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74},
       {3,  1,  4,  6,  15, 16, 17, 18, 19, 20, 21, 22, 42, 41, 40, 39, 30, 29,
        28, 27, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90},
       {1,  3,  2,  18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 91, 96, 95,
        94, 93, 92, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 0, 0, 0,  0,  0},
       {4,  5,  6,  31, 32, 33, 34,  35,  36,  37, 38, 39,
        40, 41, 42, 97, 98, 99, 100, 101, 102, 0,  0,  0,
        0,  0,  0,  0,  0,  0,  0,   0,   0,   0,  0,  0}}, // SFE_PRISM_126();
      {{1,  2,  5,  4,  7,  8,  9,  10, 23, 24, 25, 26, 34, 33, 32, 31, 24, 23,
        22, 21, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58},
       {2,  3,  6,  5,  11, 12, 13, 14, 27, 28, 29, 30, 38, 37, 36, 35, 26, 25,
        24, 23, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74},
       {3,  1,  4,  6,  15, 16, 17, 18, 19, 20, 21, 22, 42, 41, 40, 39, 30, 29,
        28, 27, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90},
       {1,  3,  2,  18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 91, 96, 95,
        94, 93, 92, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 0, 0, 0,  0,  0},
       {4,  5,  6,  31, 32, 33,  34,  35,  36, 37, 38, 39, 40,
        41, 42, 97, 98, 99, 100, 101, 102, 0,  0,  0,  0,  0,
        0,  0,  0,  0,  0,  0,   0,   0,   0,  0}}, // SFE_PRISM_GL_126();
      {{}},                                         // 214();
      {{}},                                         // 215();
      {{1,  2,  5,  4,  7,  8,  9,  10, 11, 27, 28, 29, 30, 31, 41, 40, 39,
        38, 37, 26, 25, 24, 23, 22, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61,
        62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76},
       {2,  3,  6,  5,  12, 13, 14, 15, 16, 32, 33, 34, 35, 36,  46, 45, 44,
        43, 42, 31, 30, 29, 28, 27, 77, 78, 79, 80, 81, 82, 83,  84, 85, 86,
        87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101},
       {3,   1,   4,   6,   17,  18,  19,  20,  21,  22,  23,  24,  25,
        26,  51,  50,  49,  48,  47,  26,  25,  24,  23,  22,  102, 103,
        104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116,
        117, 118, 119, 120, 121, 122, 123, 124, 125, 126},
       {1,   3,   2, 21, 20, 19,  18,  17,  16,  15,  14,  13,  12,
        11,  10,  9, 8,  7,  127, 135, 134, 133, 132, 131, 130, 129,
        128, 136, 0, 0,  0,  0,   0,   0,   0,   0,   0,   0,   0,
        0,   0,   0, 0,  0,  0,   0,   0,   0,   0},
       {4,   5,   6,  37, 38, 39,  40,  41,  42,  43,  44,  45,  46,
        47,  48,  49, 50, 51, 137, 138, 139, 140, 141, 142, 143, 144,
        145, 146, 0,  0,  0,  0,   0,   0,   0,   0,   0,   0,   0,
        0,   0,   0,  0,  0,  0,   0,   0,   0,   0}}, // SFE_PRISM_196();
      {{}},                                            // 217();
      {{}},                                            // 218();
      {{}},                                            // 219();
      {{}},                                            // 220();
      {{}},                                            // 221();
      {{}},                                            // 222();
      {{}},                                            // 223();
      {{}},                                            // 224();
      {{}},                                            // 225();
      {{}},                                            // 226();
      {{}},                                            // 227();
      {{1, 4, 3, 2},
       {1, 2, 6, 5},
       {2, 3, 7, 6},
       {3, 4, 8, 7},
       {1, 5, 8, 4},
       {5, 6, 7, 8}}, // SFE_HEXA_8();
      {{}},           // 229();
      {{}},           // 230();
      {{}},           // 231();
      {{1, 4, 3, 2, 12, 11, 10, 9, 21},
       {1, 2, 6, 5, 9, 14, 17, 13, 22},
       {2, 3, 7, 6, 10, 15, 18, 14, 23},
       {3, 4, 8, 7, 11, 16, 19, 15, 24},
       {1, 5, 8, 4, 13, 20, 16, 12, 25},
       {5, 6, 7, 8, 17, 18, 19, 20, 26}}, // SFE_HEXA_27();
      {{}},                               // 233();
      {{}},                               // 234();
      {{}},                               // 235();
      {{1, 4, 3, 2, 16, 15, 14, 13, 12, 11, 10, 9, 33, 36, 35, 34},
       {1, 2, 6, 5, 9, 10, 19, 20, 26, 25, 18, 17, 37, 38, 39, 40},
       {2, 3, 7, 6, 11, 12, 21, 22, 28, 27, 20, 19, 41, 42, 43, 44},
       {3, 4, 8, 7, 13, 14, 23, 24, 30, 29, 22, 21, 45, 46, 47, 48},
       {1, 5, 8, 4, 17, 18, 32, 31, 24, 23, 15, 16, 50, 51, 52, 49},
       {5, 6, 7, 8, 25, 26, 27, 28, 29, 30, 31, 32, 53, 54, 55,
        56}}, // SFE_HEXA_64();
      {{1, 4, 3, 2, 16, 15, 14, 13, 12, 11, 10, 9, 33, 36, 35, 34},
       {1, 2, 6, 5, 9, 10, 19, 20, 26, 25, 18, 17, 37, 38, 39, 40},
       {2, 3, 7, 6, 11, 12, 21, 22, 28, 27, 20, 19, 41, 42, 43, 44},
       {3, 4, 8, 7, 13, 14, 23, 24, 30, 29, 22, 21, 45, 46, 47, 48},
       {1, 5, 8, 4, 17, 18, 32, 31, 24, 23, 15, 16, 50, 51, 52, 49},
       {5, 6, 7, 8, 25, 26, 27, 28, 29, 30, 31, 32, 53, 54, 55,
        56}}, // SFE_HEXA_FEK_64();
      {{}},   // 238();
      {{}},   // 239();
      {{1,  4,  3, 2,  20, 19, 18, 17, 16, 15, 14, 13, 12,
        11, 10, 9, 45, 52, 51, 50, 49, 48, 47, 46, 53},
       {1,  2,  6,  5,  9,  10, 11, 24, 25, 26, 35, 34, 33,
        23, 22, 21, 54, 55, 56, 57, 58, 59, 60, 61, 62},
       {2,  3,  7,  6,  12, 13, 14, 27, 28, 29, 38, 37, 36,
        26, 25, 24, 63, 64, 65, 66, 67, 68, 69, 70, 71},
       {3,  4,  8,  7,  15, 16, 17, 30, 31, 32, 40, 40, 39,
        29, 28, 27, 72, 73, 74, 75, 76, 77, 78, 79, 80},
       {1,  5,  8,  4,  21, 22, 23, 44, 43, 42, 32, 31, 30,
        18, 19, 20, 83, 84, 85, 86, 87, 88, 81, 82, 89},
       {5,  6,  7,  8,  33, 34, 35, 36, 37, 38, 39, 40, 41,
        42, 43, 44, 90, 91, 92, 93, 94, 95, 96, 97, 98}}, // SFE_HEXA_125();
      {{1,  4,  3, 2,  20, 19, 18, 17, 16, 15, 14, 13, 12,
        11, 10, 9, 45, 52, 51, 50, 49, 48, 47, 46, 53},
       {1,  2,  6,  5,  9,  10, 11, 24, 25, 26, 35, 34, 33,
        23, 22, 21, 54, 55, 56, 57, 58, 59, 60, 61, 62},
       {2,  3,  7,  6,  12, 13, 14, 27, 28, 29, 38, 37, 36,
        26, 25, 24, 63, 64, 65, 66, 67, 68, 69, 70, 71},
       {3,  4,  8,  7,  15, 16, 17, 30, 31, 32, 40, 40, 39,
        29, 28, 27, 72, 73, 74, 75, 76, 77, 78, 79, 80},
       {1,  5,  8,  4,  21, 22, 23, 44, 43, 42, 32, 31, 30,
        18, 19, 20, 83, 84, 85, 86, 87, 88, 81, 82, 89},
       {5,  6,  7,  8,  33, 34, 35, 36, 37, 38, 39, 40, 41,
        42, 43, 44, 90, 91, 92, 93, 94, 95, 96, 97, 98}}, // SFE_HEXA_FEK_125();
      {{}},                                               // 242();
      {{}},                                               // 243();
      {{1,  4, 3,  2,  24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11,
        10, 9, 57, 68, 67, 66, 65, 64, 63, 62, 61, 60, 59, 58, 69, 72, 71, 70},
       {1,  2,  6,  5,  9,  10, 11, 12, 29, 30, 31, 32, 44, 43, 42, 41, 28, 27,
        26, 25, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88},
       {2,  3,  7,  6,  13, 14, 15, 16,  33,  34,  35,  36,
        48, 47, 46, 45, 32, 31, 30, 29,  89,  90,  91,  92,
        93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104},
       {3,   4,   8,   7,   17,  18,  19,  20,  37,  38,  39,  40,
        52,  51,  50,  49,  36,  35,  34,  33,  105, 106, 107, 108,
        109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120},
       {1,   5,   8,   4,   25,  26,  27,  28,  56,  55,  54,  53,
        40,  39,  38,  37,  21,  22,  23,  24,  124, 125, 126, 127,
        128, 129, 130, 131, 132, 121, 122, 123, 134, 135, 136, 133},
       {5,   6,   7,   8,   41,  42,  43,  44,  45,  46,  47,  48,  49,
        50,  51,  52,  53,  54,  55,  56,  137, 138, 139, 140, 141, 142,
        143, 144, 145, 146, 147, 148, 149, 150, 151, 152}}, // SFE_HEXA_216();
      {{1,  4, 3,  2,  24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11,
        10, 9, 57, 68, 67, 66, 65, 64, 63, 62, 61, 60, 59, 58, 69, 72, 71, 70},
       {1,  2,  6,  5,  9,  10, 11, 12, 29, 30, 31, 32, 44, 43, 42, 41, 28, 27,
        26, 25, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88},
       {2,  3,  7,  6,  13, 14, 15, 16,  33,  34,  35,  36,
        48, 47, 46, 45, 32, 31, 30, 29,  89,  90,  91,  92,
        93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104},
       {3,   4,   8,   7,   17,  18,  19,  20,  37,  38,  39,  40,
        52,  51,  50,  49,  36,  35,  34,  33,  105, 106, 107, 108,
        109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120},
       {1,   5,   8,   4,   25,  26,  27,  28,  56,  55,  54,  53,
        40,  39,  38,  37,  21,  22,  23,  24,  124, 125, 126, 127,
        128, 129, 130, 131, 132, 121, 122, 123, 134, 135, 136, 133},
       {5,   6,   7,   8,   41,  42,  43,  44,  45,  46,  47,  48,  49,
        50,  51,  52,  53,  54,  55,  56,  137, 138, 139, 140, 141, 142,
        143, 144, 145, 146, 147, 148, 149, 150, 151, 152}}, // SFE_HEXA_FEK_216();
      {{}},                                                 // 246();
      {{}},                                                 // 247();
      {{1,  4,  3,  2,  28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16,
        15, 14, 13, 12, 11, 10, 9,  69, 84, 83, 82, 81, 80, 79, 78, 77, 76,
        75, 74, 73, 72, 71, 70, 85, 92, 91, 90, 89, 88, 87, 86, 93},
       {1,   2,   6,   5,   9,   10,  11,  12,  13,  34,  35,  36,  37,
        38,  53,  52,  51,  50,  49,  33,  32,  31,  30,  29,  94,  95,
        96,  97,  98,  99,  100, 101, 102, 103, 104, 105, 106, 107, 108,
        109, 110, 111, 112, 113, 114, 115, 116, 117, 118},
       {2,   3,   7,   6,   14,  15,  16,  17,  18,  39,  40,  41,  42,
        43,  58,  57,  56,  55,  54,  38,  37,  36,  35,  34,  119, 120,
        121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133,
        134, 135, 136, 137, 138, 139, 140, 141, 142, 143},
       {3,   4,   8,   7,   19,  20,  21,  22,  23,  44,  45,  46,  47,
        48,  63,  62,  61,  60,  59,  43,  42,  41,  40,  39,  144, 145,
        146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158,
        159, 160, 161, 162, 163, 164, 165, 166, 167, 168},
       {4,   1,   5,   8,   24,  25,  26,  27,  28,  29,  30,  31,  32,
        33,  68,  67,  66,  65,  64,  48,  47,  46,  45,  44,  169, 170,
        171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183,
        184, 185, 186, 187, 188, 189, 190, 191, 192, 193},
       {5,   6,   7,   8,   49,  50,  51,  52,  53,  54,  55,  56,  57,
        58,  59,  60,  61,  62,  63,  64,  65,  66,  67,  68,  194, 195,
        196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208,
        209, 210, 211, 212, 213, 214, 215, 216, 217, 218}}, // SFE_HEXA_343();
      {{1,  4,  3,  2,  28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16,
        15, 14, 13, 12, 11, 10, 9,  69, 84, 83, 82, 81, 80, 79, 78, 77, 76,
        75, 74, 73, 72, 71, 70, 85, 92, 91, 90, 89, 88, 87, 86, 93},
       {1,   2,   6,   5,   9,   10,  11,  12,  13,  34,  35,  36,  37,
        38,  53,  52,  51,  50,  49,  33,  32,  31,  30,  29,  94,  95,
        96,  97,  98,  99,  100, 101, 102, 103, 104, 105, 106, 107, 108,
        109, 110, 111, 112, 113, 114, 115, 116, 117, 118},
       {2,   3,   7,   6,   14,  15,  16,  17,  18,  39,  40,  41,  42,
        43,  58,  57,  56,  55,  54,  38,  37,  36,  35,  34,  119, 120,
        121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133,
        134, 135, 136, 137, 138, 139, 140, 141, 142, 143},
       {3,   4,   8,   7,   19,  20,  21,  22,  23,  44,  45,  46,  47,
        48,  63,  62,  61,  60,  59,  43,  42,  41,  40,  39,  144, 145,
        146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158,
        159, 160, 161, 162, 163, 164, 165, 166, 167, 168},
       {4,   1,   5,   8,   24,  25,  26,  27,  28,  29,  30,  31,  32,
        33,  68,  67,  66,  65,  64,  48,  47,  46,  45,  44,  169, 170,
        171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183,
        184, 185, 186, 187, 188, 189, 190, 191, 192, 193},
       {5,   6,   7,   8,   49,  50,  51,  52,  53,  54,  55,  56,  57,
        58,  59,  60,  61,  62,  63,  64,  65,  66,  67,  68,  194, 195,
        196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208,
        209, 210, 211, 212, 213, 214, 215, 216, 217, 218}}, // SFE_HEXA_FEK_343();
  };                                                        //();
  return [&](int et, uint8_T fid) {
    return FACETS[et - 36][fid];
  }(etype, static_cast<int8_T>(facetid - 1));
}

static uint8_T obtain_facets(int32_T etype)
{
  // obtain_facets - Query facet information
  //
  //     nfacets = obtain_facets(etype)
  //     facettype = obtain_facets(etype, facetid)
  //     [facettype, lids] = obtain_facets(etype, facetid)
  //
  //  PARAMETERS
  //  ----------
  //     etype:          Element type enums
  //     facetid:        Local facet IDs
  //
  //  RETURNS
  //  -------
  //  If only etype is provided, then this function returns
  //  a single number `nfacets`, which is the number
  //  of facets of an element.
  //
  //  If facet ID is provided (1:nfacets), then this function
  //  returns the facet element type of `facetid`. Optionally,
  //  it can also return the local IDs of the requested facet
  //
  //  This file was generated from update_facets_table
  //  MATLAB code ends
  const static std::vector<std::vector<uint8_T>> FACETS{
      //();
      {1, 1},                         // SFE_BAR_2();
      {},                             // 37();
      {},                             // 38();
      {},                             // 39();
      {1, 1},                         // SFE_BAR_3();
      {},                             // 41();
      {},                             // 42();
      {},                             // 43();
      {1, 1},                         // SFE_BAR_4();
      {1, 1},                         // SFE_BAR_FEK_4();
      {},                             // 46();
      {},                             // 47();
      {1, 1},                         // SFE_BAR_5();
      {1, 1},                         // SFE_BAR_FEK_5();
      {},                             // 50();
      {},                             // 51();
      {1, 1},                         // SFE_BAR_6();
      {1, 1},                         // SFE_BAR_FEK_6();
      {},                             // 54();
      {},                             // 55();
      {1, 1},                         // SFE_BAR_7();
      {1, 1},                         // SFE_BAR_FEK_7();
      {},                             // 58();
      {},                             // 59();
      {},                             // 60();
      {},                             // 61();
      {},                             // 62();
      {},                             // 63();
      {},                             // 64();
      {},                             // 65();
      {},                             // 66();
      {},                             // 67();
      {36, 36, 36},                   // SFE_TRI_3();
      {},                             // 69();
      {},                             // 70();
      {},                             // 71();
      {40, 40, 40},                   // SFE_TRI_6();
      {},                             // 73();
      {},                             // 74();
      {},                             // 75();
      {44, 44, 44},                   // SFE_TRI_10();
      {45, 45, 45},                   // SFE_TRI_FEK_10();
      {},                             // 78();
      {},                             // 79();
      {48, 48, 48},                   // SFE_TRI_15();
      {49, 49, 49},                   // SFE_TRI_GL_15();
      {48, 48, 48},                   // SFE_TRI_FEK_15();
      {},                             // 83();
      {52, 52, 52},                   // SFE_TRI_21();
      {53, 53, 53},                   // SFE_TRI_GL_21();
      {52, 52, 52},                   // SFE_TRI_FEK_21();
      {},                             // 87();
      {56, 56, 56},                   // SFE_TRI_28();
      {57, 57, 57},                   // SFE_TRI_GL_28();
      {56, 56, 56},                   // SFE_TRI_FEK_28();
      {},                             // 91();
      {},                             // 92();
      {},                             // 93();
      {},                             // 94();
      {},                             // 95();
      {},                             // 96();
      {},                             // 97();
      {},                             // 98();
      {},                             // 99();
      {36, 36, 36, 36},               // SFE_QUAD_4();
      {},                             // 101();
      {},                             // 102();
      {},                             // 103();
      {40, 40, 40, 40},               // SFE_QUAD_9();
      {},                             // 105();
      {},                             // 106();
      {},                             // 107();
      {44, 44, 44, 44},               // SFE_QUAD_16();
      {45, 45, 45, 45},               // SFE_QUAD_FEK_16();
      {},                             // 110();
      {},                             // 111();
      {48, 48, 48, 48},               // SFE_QUAD_25();
      {49, 49, 49, 49},               // SFE_QUAD_FEK_25();
      {},                             // 114();
      {},                             // 115();
      {52, 52, 52, 52},               // SFE_QUAD_36();
      {53, 53, 53, 53},               // SFE_QUAD_FEK_36();
      {},                             // 118();
      {},                             // 119();
      {56, 56, 56, 56},               // SFE_QUAD_49();
      {57, 57, 57, 57},               // SFE_QUAD_FEK_49();
      {},                             // 122();
      {},                             // 123();
      {},                             // 124();
      {},                             // 125();
      {},                             // 126();
      {},                             // 127();
      {},                             // 128();
      {},                             // 129();
      {},                             // 130();
      {},                             // 131();
      {68, 68, 68, 68},               // SFE_TET_4();
      {},                             // 133();
      {},                             // 134();
      {},                             // 135();
      {72, 72, 72, 72},               // SFE_TET_10();
      {},                             // 137();
      {},                             // 138();
      {},                             // 139();
      {76, 76, 76, 76},               // SFE_TET_20();
      {77, 77, 77, 77},               // SFE_TET_FEK_20();
      {},                             // 142();
      {},                             // 143();
      {80, 80, 80, 80},               // SFE_TET_35();
      {81, 81, 81, 81},               // SFE_TET_GL_35();
      {82, 82, 82, 82},               // SFE_TET_FEK_35();
      {},                             // 147();
      {84, 84, 84, 84},               // SFE_TET_56();
      {85, 85, 85, 85},               // SFE_TET_GL_56();
      {86, 86, 86, 86},               // SFE_TET_FEK_56();
      {},                             // 151();
      {88, 88, 88, 88},               // SFE_TET_84();
      {89, 89, 89, 89},               // SFE_TET_GL_84();
      {90, 90, 90, 90},               // SFE_TET_FEK_84();
      {},                             // 155();
      {},                             // 156();
      {},                             // 157();
      {},                             // 158();
      {},                             // 159();
      {},                             // 160();
      {},                             // 161();
      {},                             // 162();
      {},                             // 163();
      {100, 68, 68, 68, 68},          // SFE_PYRA_5();
      {},                             // 165();
      {},                             // 166();
      {},                             // 167();
      {104, 72, 72, 72, 72},          // SFE_PYRA_14();
      {},                             // 169();
      {},                             // 170();
      {},                             // 171();
      {108, 76, 76, 76, 76},          // SFE_PYRA_30();
      {109, 77, 77, 77, 77},          // SFE_PYRA_FEK_30();
      {},                             // 174();
      {},                             // 175();
      {112, 80, 80, 80, 80},          // SFE_PYRA_55();
      {113, 81, 81, 81, 81},          // SFE_PYRA_GL_55();
      {112, 82, 82, 82, 82},          // SFE_PYRA_FEK_55();
      {},                             // 179();
      {116, 84, 84, 84, 84},          // SFE_PYRA_91();
      {},                             // 181();
      {},                             // 182();
      {},                             // 183();
      {},                             // 184();
      {},                             // 185();
      {},                             // 186();
      {},                             // 187();
      {},                             // 188();
      {},                             // 189();
      {},                             // 190();
      {},                             // 191();
      {},                             // 192();
      {},                             // 193();
      {},                             // 194();
      {},                             // 195();
      {100, 100, 100, 68, 68},        // SFE_PRISM_6();
      {},                             // 197();
      {},                             // 198();
      {},                             // 199();
      {104, 104, 104, 72, 72},        // SFE_PRISM_18();
      {},                             // 201();
      {},                             // 202();
      {},                             // 203();
      {108, 108, 108, 76, 76},        // SFE_PRISM_40();
      {109, 109, 109, 77, 77},        // SFE_PRISM_FEK_40();
      {},                             // 206();
      {},                             // 207();
      {112, 112, 112, 80, 80},        // SFE_PRISM_75();
      {113, 113, 113, 81, 81},        // SFE_PRISM_GL_75();
      {112, 112, 112, 82, 82},        // SFE_PRISM_FEK_75();
      {},                             // 211();
      {116, 116, 116, 84, 84},        // SFE_PRISM_126();
      {117, 117, 117, 85, 85},        // SFE_PRISM_GL_126();
      {},                             // 214();
      {},                             // 215();
      {120, 120, 120, 88, 88},        // SFE_PRISM_196();
      {},                             // 217();
      {},                             // 218();
      {},                             // 219();
      {},                             // 220();
      {},                             // 221();
      {},                             // 222();
      {},                             // 223();
      {},                             // 224();
      {},                             // 225();
      {},                             // 226();
      {},                             // 227();
      {100, 100, 100, 100, 100, 100}, // SFE_HEXA_8();
      {},                             // 229();
      {},                             // 230();
      {},                             // 231();
      {104, 104, 104, 104, 104, 104}, // SFE_HEXA_27();
      {},                             // 233();
      {},                             // 234();
      {},                             // 235();
      {108, 108, 108, 108, 108, 108}, // SFE_HEXA_64();
      {109, 109, 109, 109, 109, 109}, // SFE_HEXA_FEK_64();
      {},                             // 238();
      {},                             // 239();
      {112, 112, 112, 112, 112, 112}, // SFE_HEXA_125();
      {113, 113, 113, 113, 113, 113}, // SFE_HEXA_FEK_125();
      {},                             // 242();
      {},                             // 243();
      {116, 116, 116, 116, 116, 116}, // SFE_HEXA_216();
      {117, 117, 117, 117, 117, 117}, // SFE_HEXA_FEK_216();
      {},                             // 246();
      {},                             // 247();
      {120, 120, 120, 120, 120, 120}, // SFE_HEXA_343();
      {121, 121, 121, 121, 121, 121}, // SFE_HEXA_FEK_343();
  };                                  //();
  //  get the number of facets
  return [&](uint8_T et) { return FACETS[et - 36].size(); }(etype);
}

static void obtain_facets(int32_T etype, uint8_T facetid, uint8_T *ret,
                          int16_T lids_data[], int32_T *lids_size)
{
  int32_T n;
  // obtain_facets - Query facet information
  //
  //     nfacets = obtain_facets(etype)
  //     facettype = obtain_facets(etype, facetid)
  //     [facettype, lids] = obtain_facets(etype, facetid)
  //
  //  PARAMETERS
  //  ----------
  //     etype:          Element type enums
  //     facetid:        Local facet IDs
  //
  //  RETURNS
  //  -------
  //  If only etype is provided, then this function returns
  //  a single number `nfacets`, which is the number
  //  of facets of an element.
  //
  //  If facet ID is provided (1:nfacets), then this function
  //  returns the facet element type of `facetid`. Optionally,
  //  it can also return the local IDs of the requested facet
  //
  //  This file was generated from update_facets_table
  //  MATLAB code ends
  const static std::vector<std::vector<uint8_T>> FACETS{
      //();
      {1, 1},                         // SFE_BAR_2();
      {},                             // 37();
      {},                             // 38();
      {},                             // 39();
      {1, 1},                         // SFE_BAR_3();
      {},                             // 41();
      {},                             // 42();
      {},                             // 43();
      {1, 1},                         // SFE_BAR_4();
      {1, 1},                         // SFE_BAR_FEK_4();
      {},                             // 46();
      {},                             // 47();
      {1, 1},                         // SFE_BAR_5();
      {1, 1},                         // SFE_BAR_FEK_5();
      {},                             // 50();
      {},                             // 51();
      {1, 1},                         // SFE_BAR_6();
      {1, 1},                         // SFE_BAR_FEK_6();
      {},                             // 54();
      {},                             // 55();
      {1, 1},                         // SFE_BAR_7();
      {1, 1},                         // SFE_BAR_FEK_7();
      {},                             // 58();
      {},                             // 59();
      {},                             // 60();
      {},                             // 61();
      {},                             // 62();
      {},                             // 63();
      {},                             // 64();
      {},                             // 65();
      {},                             // 66();
      {},                             // 67();
      {36, 36, 36},                   // SFE_TRI_3();
      {},                             // 69();
      {},                             // 70();
      {},                             // 71();
      {40, 40, 40},                   // SFE_TRI_6();
      {},                             // 73();
      {},                             // 74();
      {},                             // 75();
      {44, 44, 44},                   // SFE_TRI_10();
      {45, 45, 45},                   // SFE_TRI_FEK_10();
      {},                             // 78();
      {},                             // 79();
      {48, 48, 48},                   // SFE_TRI_15();
      {49, 49, 49},                   // SFE_TRI_GL_15();
      {48, 48, 48},                   // SFE_TRI_FEK_15();
      {},                             // 83();
      {52, 52, 52},                   // SFE_TRI_21();
      {53, 53, 53},                   // SFE_TRI_GL_21();
      {52, 52, 52},                   // SFE_TRI_FEK_21();
      {},                             // 87();
      {56, 56, 56},                   // SFE_TRI_28();
      {57, 57, 57},                   // SFE_TRI_GL_28();
      {56, 56, 56},                   // SFE_TRI_FEK_28();
      {},                             // 91();
      {},                             // 92();
      {},                             // 93();
      {},                             // 94();
      {},                             // 95();
      {},                             // 96();
      {},                             // 97();
      {},                             // 98();
      {},                             // 99();
      {36, 36, 36, 36},               // SFE_QUAD_4();
      {},                             // 101();
      {},                             // 102();
      {},                             // 103();
      {40, 40, 40, 40},               // SFE_QUAD_9();
      {},                             // 105();
      {},                             // 106();
      {},                             // 107();
      {44, 44, 44, 44},               // SFE_QUAD_16();
      {45, 45, 45, 45},               // SFE_QUAD_FEK_16();
      {},                             // 110();
      {},                             // 111();
      {48, 48, 48, 48},               // SFE_QUAD_25();
      {49, 49, 49, 49},               // SFE_QUAD_FEK_25();
      {},                             // 114();
      {},                             // 115();
      {52, 52, 52, 52},               // SFE_QUAD_36();
      {53, 53, 53, 53},               // SFE_QUAD_FEK_36();
      {},                             // 118();
      {},                             // 119();
      {56, 56, 56, 56},               // SFE_QUAD_49();
      {57, 57, 57, 57},               // SFE_QUAD_FEK_49();
      {},                             // 122();
      {},                             // 123();
      {},                             // 124();
      {},                             // 125();
      {},                             // 126();
      {},                             // 127();
      {},                             // 128();
      {},                             // 129();
      {},                             // 130();
      {},                             // 131();
      {68, 68, 68, 68},               // SFE_TET_4();
      {},                             // 133();
      {},                             // 134();
      {},                             // 135();
      {72, 72, 72, 72},               // SFE_TET_10();
      {},                             // 137();
      {},                             // 138();
      {},                             // 139();
      {76, 76, 76, 76},               // SFE_TET_20();
      {77, 77, 77, 77},               // SFE_TET_FEK_20();
      {},                             // 142();
      {},                             // 143();
      {80, 80, 80, 80},               // SFE_TET_35();
      {81, 81, 81, 81},               // SFE_TET_GL_35();
      {82, 82, 82, 82},               // SFE_TET_FEK_35();
      {},                             // 147();
      {84, 84, 84, 84},               // SFE_TET_56();
      {85, 85, 85, 85},               // SFE_TET_GL_56();
      {86, 86, 86, 86},               // SFE_TET_FEK_56();
      {},                             // 151();
      {88, 88, 88, 88},               // SFE_TET_84();
      {89, 89, 89, 89},               // SFE_TET_GL_84();
      {90, 90, 90, 90},               // SFE_TET_FEK_84();
      {},                             // 155();
      {},                             // 156();
      {},                             // 157();
      {},                             // 158();
      {},                             // 159();
      {},                             // 160();
      {},                             // 161();
      {},                             // 162();
      {},                             // 163();
      {100, 68, 68, 68, 68},          // SFE_PYRA_5();
      {},                             // 165();
      {},                             // 166();
      {},                             // 167();
      {104, 72, 72, 72, 72},          // SFE_PYRA_14();
      {},                             // 169();
      {},                             // 170();
      {},                             // 171();
      {108, 76, 76, 76, 76},          // SFE_PYRA_30();
      {109, 77, 77, 77, 77},          // SFE_PYRA_FEK_30();
      {},                             // 174();
      {},                             // 175();
      {112, 80, 80, 80, 80},          // SFE_PYRA_55();
      {113, 81, 81, 81, 81},          // SFE_PYRA_GL_55();
      {112, 82, 82, 82, 82},          // SFE_PYRA_FEK_55();
      {},                             // 179();
      {116, 84, 84, 84, 84},          // SFE_PYRA_91();
      {},                             // 181();
      {},                             // 182();
      {},                             // 183();
      {},                             // 184();
      {},                             // 185();
      {},                             // 186();
      {},                             // 187();
      {},                             // 188();
      {},                             // 189();
      {},                             // 190();
      {},                             // 191();
      {},                             // 192();
      {},                             // 193();
      {},                             // 194();
      {},                             // 195();
      {100, 100, 100, 68, 68},        // SFE_PRISM_6();
      {},                             // 197();
      {},                             // 198();
      {},                             // 199();
      {104, 104, 104, 72, 72},        // SFE_PRISM_18();
      {},                             // 201();
      {},                             // 202();
      {},                             // 203();
      {108, 108, 108, 76, 76},        // SFE_PRISM_40();
      {109, 109, 109, 77, 77},        // SFE_PRISM_FEK_40();
      {},                             // 206();
      {},                             // 207();
      {112, 112, 112, 80, 80},        // SFE_PRISM_75();
      {113, 113, 113, 81, 81},        // SFE_PRISM_GL_75();
      {112, 112, 112, 82, 82},        // SFE_PRISM_FEK_75();
      {},                             // 211();
      {116, 116, 116, 84, 84},        // SFE_PRISM_126();
      {117, 117, 117, 85, 85},        // SFE_PRISM_GL_126();
      {},                             // 214();
      {},                             // 215();
      {120, 120, 120, 88, 88},        // SFE_PRISM_196();
      {},                             // 217();
      {},                             // 218();
      {},                             // 219();
      {},                             // 220();
      {},                             // 221();
      {},                             // 222();
      {},                             // 223();
      {},                             // 224();
      {},                             // 225();
      {},                             // 226();
      {},                             // 227();
      {100, 100, 100, 100, 100, 100}, // SFE_HEXA_8();
      {},                             // 229();
      {},                             // 230();
      {},                             // 231();
      {104, 104, 104, 104, 104, 104}, // SFE_HEXA_27();
      {},                             // 233();
      {},                             // 234();
      {},                             // 235();
      {108, 108, 108, 108, 108, 108}, // SFE_HEXA_64();
      {109, 109, 109, 109, 109, 109}, // SFE_HEXA_FEK_64();
      {},                             // 238();
      {},                             // 239();
      {112, 112, 112, 112, 112, 112}, // SFE_HEXA_125();
      {113, 113, 113, 113, 113, 113}, // SFE_HEXA_FEK_125();
      {},                             // 242();
      {},                             // 243();
      {116, 116, 116, 116, 116, 116}, // SFE_HEXA_216();
      {117, 117, 117, 117, 117, 117}, // SFE_HEXA_FEK_216();
      {},                             // 246();
      {},                             // 247();
      {120, 120, 120, 120, 120, 120}, // SFE_HEXA_343();
      {121, 121, 121, 121, 121, 121}, // SFE_HEXA_FEK_343();
  };                                  //();
  const static std::vector<std::vector<std::vector<int16_T>>> LIDS{
      //();
      {{1}, {2}},                                 // SFE_BAR_2();
      {{}},                                       // 37();
      {{}},                                       // 38();
      {{}},                                       // 39();
      {{1}, {2}},                                 // SFE_BAR_3();
      {{}},                                       // 41();
      {{}},                                       // 42();
      {{}},                                       // 43();
      {{1}, {2}},                                 // SFE_BAR_4();
      {{1}, {2}},                                 // SFE_BAR_FEK_4();
      {{}},                                       // 46();
      {{}},                                       // 47();
      {{1}, {2}},                                 // SFE_BAR_5();
      {{1}, {2}},                                 // SFE_BAR_FEK_5();
      {{}},                                       // 50();
      {{}},                                       // 51();
      {{1}, {2}},                                 // SFE_BAR_6();
      {{1}, {2}},                                 // SFE_BAR_FEK_6();
      {{}},                                       // 54();
      {{}},                                       // 55();
      {{1}, {2}},                                 // SFE_BAR_7();
      {{1}, {2}},                                 // SFE_BAR_FEK_7();
      {{}},                                       // 58();
      {{}},                                       // 59();
      {{}},                                       // 60();
      {{}},                                       // 61();
      {{}},                                       // 62();
      {{}},                                       // 63();
      {{}},                                       // 64();
      {{}},                                       // 65();
      {{}},                                       // 66();
      {{}},                                       // 67();
      {{1, 2}, {2, 3}, {3, 1}},                   // SFE_TRI_3();
      {{}},                                       // 69();
      {{}},                                       // 70();
      {{}},                                       // 71();
      {{1, 2, 4}, {2, 3, 5}, {3, 1, 6}},          // SFE_TRI_6();
      {{}},                                       // 73();
      {{}},                                       // 74();
      {{}},                                       // 75();
      {{1, 2, 4, 5}, {2, 3, 6, 7}, {3, 1, 8, 9}}, // SFE_TRI_10();
      {{1, 2, 4, 5}, {2, 3, 6, 7}, {3, 1, 8, 9}}, // SFE_TRI_FEK_10();
      {{}},                                       // 78();
      {{}},                                       // 79();
      {{1, 2, 4, 5, 6}, {2, 3, 7, 8, 9}, {3, 1, 10, 11, 12}}, // SFE_TRI_15();
      {{1, 2, 4, 5, 6},
       {2, 3, 7, 8, 9},
       {3, 1, 10, 11, 12}}, // SFE_TRI_GL_15();
      {{1, 2, 4, 5, 6},
       {2, 3, 7, 8, 9},
       {3, 1, 10, 11, 12}}, // SFE_TRI_FEK_15();
      {{}},                 // 83();
      {{1, 2, 4, 5, 6, 7},
       {2, 3, 8, 9, 10, 11},
       {3, 1, 12, 13, 14, 15}}, // SFE_TRI_21();
      {{1, 2, 4, 5, 6, 7},
       {2, 3, 8, 9, 10, 11},
       {3, 1, 12, 13, 14, 15}}, // SFE_TRI_GL_21();
      {{1, 2, 4, 5, 6, 7},
       {2, 3, 8, 9, 10, 11},
       {3, 1, 12, 13, 14, 15}}, // SFE_TRI_FEK_21();
      {{}},                     // 87();
      {{1, 2, 4, 5, 6, 7, 8},
       {2, 3, 9, 10, 11, 12, 13},
       {3, 1, 14, 15, 16, 17, 18}}, // SFE_TRI_28();
      {{1, 2, 4, 5, 6, 7, 8},
       {2, 3, 9, 10, 11, 12, 13},
       {3, 1, 14, 15, 16, 17, 18}}, // SFE_TRI_GL_28();
      {{1, 2, 4, 5, 6, 7, 8},
       {2, 3, 9, 10, 11, 12, 13},
       {3, 1, 14, 15, 16, 17, 18}},                 // SFE_TRI_FEK_28();
      {{}},                                         // 91();
      {{}},                                         // 92();
      {{}},                                         // 93();
      {{}},                                         // 94();
      {{}},                                         // 95();
      {{}},                                         // 96();
      {{}},                                         // 97();
      {{}},                                         // 98();
      {{}},                                         // 99();
      {{1, 2}, {2, 3}, {3, 4}, {4, 1}},             // SFE_QUAD_4();
      {{}},                                         // 101();
      {{}},                                         // 102();
      {{}},                                         // 103();
      {{1, 2, 5}, {2, 3, 6}, {3, 4, 7}, {4, 1, 8}}, // SFE_QUAD_9();
      {{}},                                         // 105();
      {{}},                                         // 106();
      {{}},                                         // 107();
      {{1, 2, 5, 6},
       {2, 3, 7, 8},
       {3, 4, 9, 10},
       {4, 1, 11, 12}}, // SFE_QUAD_16();
      {{1, 2, 5, 6},
       {2, 3, 7, 8},
       {3, 4, 9, 10},
       {4, 1, 11, 12}}, // SFE_QUAD_FEK_16();
      {{}},             // 110();
      {{}},             // 111();
      {{1, 2, 5, 6, 7},
       {2, 3, 8, 9, 10},
       {3, 4, 11, 12, 13},
       {4, 1, 14, 15, 16}}, // SFE_QUAD_25();
      {{1, 2, 5, 6, 7},
       {2, 3, 8, 9, 10},
       {3, 4, 11, 12, 13},
       {4, 1, 14, 15, 16}}, // SFE_QUAD_FEK_25();
      {{}},                 // 114();
      {{}},                 // 115();
      {{1, 2, 5, 6, 7, 8},
       {2, 3, 9, 10, 11, 12},
       {3, 4, 13, 14, 15, 16},
       {4, 1, 17, 18, 19, 20}}, // SFE_QUAD_36();
      {{1, 2, 5, 6, 7, 8},
       {2, 3, 9, 10, 11, 12},
       {3, 4, 13, 14, 15, 16},
       {4, 1, 17, 18, 19, 20}}, // SFE_QUAD_FEK_36();
      {{}},                     // 118();
      {{}},                     // 119();
      {{1, 2, 5, 6, 7, 8, 9},
       {2, 3, 10, 11, 12, 13, 14},
       {3, 4, 15, 16, 17, 18, 19},
       {4, 1, 20, 21, 22, 23, 24}}, // SFE_QUAD_49();
      {{1, 2, 5, 6, 7, 8, 9},
       {2, 3, 10, 11, 12, 13, 14},
       {3, 4, 15, 16, 17, 18, 19},
       {4, 1, 20, 21, 22, 23, 24}},                 // SFE_QUAD_FEK_49();
      {{}},                                         // 122();
      {{}},                                         // 123();
      {{}},                                         // 124();
      {{}},                                         // 125();
      {{}},                                         // 126();
      {{}},                                         // 127();
      {{}},                                         // 128();
      {{}},                                         // 129();
      {{}},                                         // 130();
      {{}},                                         // 131();
      {{1, 3, 2}, {1, 2, 4}, {2, 3, 4}, {3, 1, 4}}, // SFE_TET_4();
      {{}},                                         // 133();
      {{}},                                         // 134();
      {{}},                                         // 135();
      {{1, 3, 2, 7, 6, 5},
       {1, 2, 4, 5, 9, 8},
       {2, 3, 4, 6, 10, 9},
       {3, 1, 4, 7, 8, 10}}, // SFE_TET_10();
      {{}},                  // 137();
      {{}},                  // 138();
      {{}},                  // 139();
      {{1, 3, 2, 10, 9, 8, 7, 6, 5, 17},
       {1, 2, 4, 5, 6, 13, 14, 12, 11, 18},
       {2, 3, 4, 7, 8, 15, 16, 14, 13, 19},
       {3, 1, 4, 9, 10, 11, 12, 16, 15, 20}}, // SFE_TET_20();
      {{1, 3, 2, 10, 9, 8, 7, 6, 5, 17},
       {1, 2, 4, 5, 6, 13, 14, 12, 11, 18},
       {2, 3, 4, 7, 8, 15, 16, 14, 13, 19},
       {3, 1, 4, 9, 10, 11, 12, 16, 15, 20}}, // SFE_TET_FEK_20();
      {{}},                                   // 142();
      {{}},                                   // 143();
      {{1, 3, 2, 13, 12, 11, 10, 9, 8, 7, 6, 5, 23, 25, 24},
       {1, 2, 4, 5, 6, 7, 17, 18, 19, 16, 15, 14, 26, 27, 28},
       {2, 3, 4, 8, 9, 10, 20, 21, 22, 19, 18, 17, 29, 30, 31},
       {3, 1, 4, 11, 12, 13, 14, 15, 16, 22, 21, 20, 32, 33,
        34}}, // SFE_TET_35();
      {{1, 3, 2, 13, 12, 11, 10, 9, 8, 7, 6, 5, 23, 25, 24},
       {1, 2, 4, 5, 6, 7, 17, 18, 19, 16, 15, 14, 26, 27, 28},
       {2, 3, 4, 8, 9, 10, 20, 21, 22, 19, 18, 17, 29, 30, 31},
       {3, 1, 4, 11, 12, 13, 14, 15, 16, 22, 21, 20, 32, 33,
        34}}, // SFE_TET_GL_35();
      {{1, 3, 2, 13, 12, 11, 10, 9, 8, 7, 6, 5, 23, 25, 24},
       {1, 2, 4, 5, 6, 7, 17, 18, 19, 16, 15, 14, 26, 27, 28},
       {2, 3, 4, 8, 9, 10, 20, 21, 22, 19, 18, 17, 29, 30, 31},
       {3, 1, 4, 11, 12, 13, 14, 15, 16, 22, 21, 20, 32, 33,
        34}}, // SFE_TET_FEK_35();
      {{}},   // 147();
      {{1, 3, 2, 16, 15, 14, 13, 12, 11, 10, 9,
        8, 7, 6, 5,  29, 34, 33, 32, 31, 30},
       {1,  2,  4,  5,  6,  7,  8,  21, 22, 23, 24,
        20, 19, 18, 17, 35, 36, 37, 38, 39, 40},
       {2,  3,  4,  9,  10, 11, 12, 25, 26, 27, 28,
        24, 23, 22, 21, 41, 42, 43, 44, 45, 46},
       {3,  1,  4,  13, 14, 15, 16, 17, 18, 19, 20,
        28, 27, 26, 25, 47, 48, 49, 50, 51, 52}}, // SFE_TET_56();
      {{1, 3, 2, 16, 15, 14, 13, 12, 11, 10, 9,
        8, 7, 6, 5,  29, 34, 33, 32, 31, 30},
       {1,  2,  4,  5,  6,  7,  8,  21, 22, 23, 24,
        20, 19, 18, 17, 35, 36, 37, 38, 39, 40},
       {2,  3,  4,  9,  10, 11, 12, 25, 26, 27, 28,
        24, 23, 22, 21, 41, 42, 43, 44, 45, 46},
       {3,  1,  4,  13, 14, 15, 16, 17, 18, 19, 20,
        28, 27, 26, 25, 47, 48, 49, 50, 51, 52}}, // SFE_TET_GL_56();
      {{1, 3, 2, 16, 15, 14, 13, 12, 11, 10, 9,
        8, 7, 6, 5,  29, 34, 33, 32, 31, 30},
       {1,  2,  4,  5,  6,  7,  8,  21, 22, 23, 24,
        20, 19, 18, 17, 35, 36, 37, 38, 39, 40},
       {2,  3,  4,  9,  10, 11, 12, 25, 26, 27, 28,
        24, 23, 22, 21, 41, 42, 43, 44, 45, 46},
       {3,  1,  4,  13, 14, 15, 16, 17, 18, 19, 20,
        28, 27, 26, 25, 47, 48, 49, 50, 51, 52}}, // SFE_TET_FEK_56();
      {{}},                                       // 151();
      {{1, 3, 2, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9,
        8, 7, 6, 5,  35, 43, 42, 41, 40, 39, 38, 37, 36, 44},
       {1,  2,  4,  5,  6,  7,  8,  9,  25, 26, 27, 28, 29, 24,
        23, 22, 21, 20, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54},
       {2,  3,  4,  10, 11, 12, 13, 14, 30, 31, 32, 33, 34, 29,
        28, 27, 26, 25, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64},
       {3,  1,  4,  15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 34, 33,
        32, 31, 30, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74}}, // SFE_TET_84();
      {{1, 3, 2, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9,
        8, 7, 6, 5,  35, 43, 42, 41, 40, 39, 38, 37, 36, 44},
       {1,  2,  4,  5,  6,  7,  8,  9,  25, 26, 27, 28, 29, 24,
        23, 22, 21, 20, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54},
       {2,  3,  4,  10, 11, 12, 13, 14, 30, 31, 32, 33, 34, 29,
        28, 27, 26, 25, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64},
       {3,  1,  4,  15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 34, 33,
        32, 31, 30, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74}}, // SFE_TET_GL_84();
      {{1, 3, 2, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9,
        8, 7, 6, 5,  35, 43, 42, 41, 40, 39, 38, 37, 36, 44},
       {1,  2,  4,  5,  6,  7,  8,  9,  25, 26, 27, 28, 29, 24,
        23, 22, 21, 20, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54},
       {2,  3,  4,  10, 11, 12, 13, 14, 30, 31, 32, 33, 34, 29,
        28, 27, 26, 25, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64},
       {3,  1,  4,  15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 34, 33,
        32, 31, 30, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74}}, // SFE_TET_FEK_84();
      {{}},                                                   // 155();
      {{}},                                                   // 156();
      {{}},                                                   // 157();
      {{}},                                                   // 158();
      {{}},                                                   // 159();
      {{}},                                                   // 160();
      {{}},                                                   // 161();
      {{}},                                                   // 162();
      {{}},                                                   // 163();
      {{1, 4, 3, 2},
       {1, 2, 5, 0},
       {2, 3, 5, 0},
       {3, 4, 5, 0},
       {4, 1, 5, 0}}, // SFE_PYRA_5();
      {{}},           // 165();
      {{}},           // 166();
      {{}},           // 167();
      {{1, 4, 3, 2, 9, 8, 7, 6, 14},
       {1, 2, 5, 6, 11, 10, 0, 0, 0},
       {2, 3, 5, 7, 12, 11, 0, 0, 0},
       {3, 4, 5, 8, 13, 12, 0, 0, 0},
       {4, 1, 5, 9, 10, 13, 0, 0, 0}}, // SFE_PYRA_14();
      {{}},                            // 169();
      {{}},                            // 170();
      {{}},                            // 171();
      {{1, 4, 3, 2, 13, 12, 11, 10, 9, 8, 7, 6, 22, 25, 24, 23},
       {1, 2, 5, 6, 7, 16, 17, 15, 14, 26, 0, 0, 0, 0, 0, 0},
       {2, 3, 5, 8, 9, 18, 19, 17, 16, 27, 0, 0, 0, 0, 0, 0},
       {3, 4, 5, 10, 11, 20, 21, 19, 18, 28, 0, 0, 0, 0, 0, 0},
       {4, 1, 5, 12, 13, 14, 15, 21, 20, 29, 0, 0, 0, 0, 0,
        0}}, // SFE_PYRA_30();
      {{1, 4, 3, 2, 13, 12, 11, 10, 9, 8, 7, 6, 22, 25, 24, 23},
       {1, 2, 5, 6, 7, 16, 17, 15, 14, 26, 0, 0, 0, 0, 0, 0},
       {2, 3, 5, 8, 9, 18, 19, 17, 16, 27, 0, 0, 0, 0, 0, 0},
       {3, 4, 5, 10, 11, 20, 21, 19, 18, 28, 0, 0, 0, 0, 0, 0},
       {4, 1, 5, 12, 13, 14, 15, 21, 20, 29, 0, 0, 0, 0, 0,
        0}}, // SFE_PYRA_FEK_30();
      {{}},  // 174();
      {{}},  // 175();
      {{1, 4, 3, 2,  17, 16, 15, 14, 13, 12, 11, 10, 9,
        8, 7, 6, 30, 37, 36, 35, 34, 33, 32, 31, 38},
       {1,  2,  5, 6, 7, 8, 21, 22, 23, 20, 19, 18, 39,
        40, 41, 0, 0, 0, 0, 0,  0,  0,  0,  0,  0},
       {2,  3,  5, 9, 10, 11, 24, 25, 26, 23, 22, 21, 42,
        43, 44, 0, 0, 0,  0,  0,  0,  0,  0,  0,  0},
       {3,  4,  5, 12, 13, 14, 27, 28, 29, 26, 25, 24, 45,
        46, 47, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0},
       {4,  1,  5, 15, 16, 17, 18, 19, 20, 29, 28, 27, 48,
        49, 50, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0}}, // SFE_PYRA_55();
      {{1, 4, 3, 2,  17, 16, 15, 14, 13, 12, 11, 10, 9,
        8, 7, 6, 30, 37, 36, 35, 34, 33, 32, 31, 38},
       {1,  2,  5, 6, 7, 8, 21, 22, 23, 20, 19, 18, 39,
        40, 41, 0, 0, 0, 0, 0,  0,  0,  0,  0,  0},
       {2,  3,  5, 9, 10, 11, 24, 25, 26, 23, 22, 21, 42,
        43, 44, 0, 0, 0,  0,  0,  0,  0,  0,  0,  0},
       {3,  4,  5, 12, 13, 14, 27, 28, 29, 26, 25, 24, 45,
        46, 47, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0},
       {4,  1,  5, 15, 16, 17, 18, 19, 20, 29, 28, 27, 48,
        49, 50, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0}}, // SFE_PYRA_GL_55();
      {{1, 4, 3, 2,  17, 16, 15, 14, 13, 12, 11, 10, 9,
        8, 7, 6, 30, 37, 36, 35, 34, 33, 32, 31, 38},
       {1,  2,  5, 6, 7, 8, 21, 22, 23, 20, 19, 18, 39,
        40, 41, 0, 0, 0, 0, 0,  0,  0,  0,  0,  0},
       {2,  3,  5, 9, 10, 11, 24, 25, 26, 23, 22, 21, 42,
        43, 44, 0, 0, 0,  0,  0,  0,  0,  0,  0,  0},
       {3,  4,  5, 12, 13, 14, 27, 28, 29, 26, 25, 24, 45,
        46, 47, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0},
       {4,  1,  5, 15, 16, 17, 18, 19, 20, 29, 28, 27, 48,
        49, 50, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0}}, // SFE_PYRA_FEK_55();
      {{}},                                             // 179();
      {{1, 4, 3,  2,  21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9,  8,
        7, 6, 38, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 50, 53, 52, 51},
       {1,  2,  5,  6, 7, 8, 9, 26, 27, 28, 29, 25, 24, 23, 22, 54, 55, 56,
        57, 58, 59, 0, 0, 0, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
       {2,  3,  5,  10, 11, 12, 13, 30, 31, 32, 33, 29, 28, 27, 26, 60, 61, 62,
        63, 64, 65, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
       {3,  4,  5,  14, 15, 16, 17, 34, 35, 36, 37, 33, 32, 31, 30, 66, 67, 68,
        69, 70, 71, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
       {4,  1,  5,  18, 19, 20, 21, 22, 23, 24, 25, 37,
        36, 35, 34, 72, 73, 74, 75, 76, 77, 0,  0,  0,
        0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0}}, // SFE_PYRA_91();
      {{}},                                              // 181();
      {{}},                                              // 182();
      {{}},                                              // 183();
      {{}},                                              // 184();
      {{}},                                              // 185();
      {{}},                                              // 186();
      {{}},                                              // 187();
      {{}},                                              // 188();
      {{}},                                              // 189();
      {{}},                                              // 190();
      {{}},                                              // 191();
      {{}},                                              // 192();
      {{}},                                              // 193();
      {{}},                                              // 194();
      {{}},                                              // 195();
      {{1, 2, 5, 4},
       {2, 3, 6, 5},
       {3, 1, 4, 6},
       {1, 3, 2, 0},
       {4, 5, 6, 0}}, // SFE_PRISM_6();
      {{}},           // 197();
      {{}},           // 198();
      {{}},           // 199();
      {{1, 2, 5, 4, 7, 11, 13, 10, 16},
       {2, 3, 6, 5, 8, 12, 14, 11, 17},
       {3, 1, 4, 6, 9, 10, 15, 12, 18},
       {1, 3, 2, 9, 8, 7, 0, 0, 0},
       {4, 5, 6, 13, 14, 15, 0, 0, 0}}, // SFE_PRISM_18();
      {{}},                             // 201();
      {{}},                             // 202();
      {{}},                             // 203();
      {{1, 2, 5, 4, 7, 8, 15, 16, 20, 19, 14, 13, 26, 27, 28, 29},
       {2, 3, 6, 5, 9, 10, 17, 18, 22, 21, 16, 15, 30, 31, 32, 33},
       {3, 1, 4, 6, 11, 12, 13, 14, 24, 23, 18, 17, 34, 35, 36, 37},
       {1, 3, 2, 12, 11, 10, 9, 8, 7, 25, 0, 0, 0, 0, 0, 0},
       {4, 5, 6, 19, 20, 21, 22, 23, 24, 38, 0, 0, 0, 0, 0,
        0}}, // SFE_PRISM_40();
      {{1, 2, 5, 4, 7, 8, 15, 16, 20, 19, 14, 13, 26, 27, 28, 29},
       {2, 3, 6, 5, 9, 10, 17, 18, 22, 21, 16, 15, 30, 31, 32, 33},
       {3, 1, 4, 6, 11, 12, 13, 14, 24, 23, 18, 17, 34, 35, 36, 37},
       {1, 3, 2, 12, 11, 10, 9, 8, 7, 25, 0, 0, 0, 0, 0, 0},
       {4, 5, 6, 19, 20, 21, 22, 23, 24, 38, 0, 0, 0, 0, 0,
        0}}, // SFE_PRISM_FEK_40();
      {{}},  // 206();
      {{}},  // 207();
      {{1,  2,  5,  4,  7,  8,  9,  19, 20, 21, 27, 26, 25,
        18, 17, 16, 37, 38, 39, 40, 41, 42, 43, 44, 45},
       {2,  3,  6,  5,  10, 11, 12, 22, 23, 24, 30, 29, 28,
        21, 20, 19, 46, 47, 48, 49, 50, 51, 52, 53, 54},
       {3,  1,  4,  6,  13, 14, 15, 16, 17, 18, 33, 32, 31,
        24, 23, 22, 55, 56, 57, 58, 59, 60, 61, 62, 63},
       {1,  3,  2, 15, 14, 13, 12, 11, 10, 9, 8, 7, 34,
        36, 35, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0},
       {4,  5,  6, 25, 26, 27, 28, 29, 30, 31, 32, 33, 64,
        65, 66, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0}}, // SFE_PRISM_75();
      {{1,  2,  5,  4,  7,  8,  9,  19, 20, 21, 27, 26, 25,
        18, 17, 16, 37, 38, 39, 40, 41, 42, 43, 44, 45},
       {2,  3,  6,  5,  10, 11, 12, 22, 23, 24, 30, 29, 28,
        21, 20, 19, 46, 47, 48, 49, 50, 51, 52, 53, 54},
       {3,  1,  4,  6,  13, 14, 15, 16, 17, 18, 33, 32, 31,
        24, 23, 22, 55, 56, 57, 58, 59, 60, 61, 62, 63},
       {1,  3,  2, 15, 14, 13, 12, 11, 10, 9, 8, 7, 34,
        36, 35, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0},
       {4,  5,  6, 25, 26, 27, 28, 29, 30, 31, 32, 33, 64,
        65, 66, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0}}, // SFE_PRISM_GL_75();
      {{1,  2,  5,  4,  7,  8,  9,  19, 20, 21, 27, 26, 25,
        18, 17, 16, 37, 38, 39, 40, 41, 42, 43, 44, 45},
       {2,  3,  6,  5,  10, 11, 12, 22, 23, 24, 30, 29, 28,
        21, 20, 19, 46, 47, 48, 49, 50, 51, 52, 53, 54},
       {3,  1,  4,  6,  13, 14, 15, 16, 17, 18, 33, 32, 31,
        24, 23, 22, 55, 56, 57, 58, 59, 60, 61, 62, 63},
       {1,  3,  2, 15, 14, 13, 12, 11, 10, 9, 8, 7, 34,
        36, 35, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0},
       {4,  5,  6, 25, 26, 27, 28, 29, 30, 31, 32, 33, 64,
        65, 66, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0}}, // SFE_PRISM_FEK_75();
      {{}},                                             // 211();
      {{1,  2,  5,  4,  7,  8,  9,  10, 23, 24, 25, 26, 34, 33, 32, 31, 24, 23,
        22, 21, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58},
       {2,  3,  6,  5,  11, 12, 13, 14, 27, 28, 29, 30, 38, 37, 36, 35, 26, 25,
        24, 23, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74},
       {3,  1,  4,  6,  15, 16, 17, 18, 19, 20, 21, 22, 42, 41, 40, 39, 30, 29,
        28, 27, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90},
       {1,  3,  2,  18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 91, 96, 95,
        94, 93, 92, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 0, 0, 0,  0,  0},
       {4,  5,  6,  31, 32, 33, 34,  35,  36,  37, 38, 39,
        40, 41, 42, 97, 98, 99, 100, 101, 102, 0,  0,  0,
        0,  0,  0,  0,  0,  0,  0,   0,   0,   0,  0,  0}}, // SFE_PRISM_126();
      {{1,  2,  5,  4,  7,  8,  9,  10, 23, 24, 25, 26, 34, 33, 32, 31, 24, 23,
        22, 21, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58},
       {2,  3,  6,  5,  11, 12, 13, 14, 27, 28, 29, 30, 38, 37, 36, 35, 26, 25,
        24, 23, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74},
       {3,  1,  4,  6,  15, 16, 17, 18, 19, 20, 21, 22, 42, 41, 40, 39, 30, 29,
        28, 27, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90},
       {1,  3,  2,  18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 91, 96, 95,
        94, 93, 92, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 0, 0, 0,  0,  0},
       {4,  5,  6,  31, 32, 33,  34,  35,  36, 37, 38, 39, 40,
        41, 42, 97, 98, 99, 100, 101, 102, 0,  0,  0,  0,  0,
        0,  0,  0,  0,  0,  0,   0,   0,   0,  0}}, // SFE_PRISM_GL_126();
      {{}},                                         // 214();
      {{}},                                         // 215();
      {{1,  2,  5,  4,  7,  8,  9,  10, 11, 27, 28, 29, 30, 31, 41, 40, 39,
        38, 37, 26, 25, 24, 23, 22, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61,
        62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76},
       {2,  3,  6,  5,  12, 13, 14, 15, 16, 32, 33, 34, 35, 36,  46, 45, 44,
        43, 42, 31, 30, 29, 28, 27, 77, 78, 79, 80, 81, 82, 83,  84, 85, 86,
        87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101},
       {3,   1,   4,   6,   17,  18,  19,  20,  21,  22,  23,  24,  25,
        26,  51,  50,  49,  48,  47,  26,  25,  24,  23,  22,  102, 103,
        104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116,
        117, 118, 119, 120, 121, 122, 123, 124, 125, 126},
       {1,   3,   2, 21, 20, 19,  18,  17,  16,  15,  14,  13,  12,
        11,  10,  9, 8,  7,  127, 135, 134, 133, 132, 131, 130, 129,
        128, 136, 0, 0,  0,  0,   0,   0,   0,   0,   0,   0,   0,
        0,   0,   0, 0,  0,  0,   0,   0,   0,   0},
       {4,   5,   6,  37, 38, 39,  40,  41,  42,  43,  44,  45,  46,
        47,  48,  49, 50, 51, 137, 138, 139, 140, 141, 142, 143, 144,
        145, 146, 0,  0,  0,  0,   0,   0,   0,   0,   0,   0,   0,
        0,   0,   0,  0,  0,  0,   0,   0,   0,   0}}, // SFE_PRISM_196();
      {{}},                                            // 217();
      {{}},                                            // 218();
      {{}},                                            // 219();
      {{}},                                            // 220();
      {{}},                                            // 221();
      {{}},                                            // 222();
      {{}},                                            // 223();
      {{}},                                            // 224();
      {{}},                                            // 225();
      {{}},                                            // 226();
      {{}},                                            // 227();
      {{1, 4, 3, 2},
       {1, 2, 6, 5},
       {2, 3, 7, 6},
       {3, 4, 8, 7},
       {1, 5, 8, 4},
       {5, 6, 7, 8}}, // SFE_HEXA_8();
      {{}},           // 229();
      {{}},           // 230();
      {{}},           // 231();
      {{1, 4, 3, 2, 12, 11, 10, 9, 21},
       {1, 2, 6, 5, 9, 14, 17, 13, 22},
       {2, 3, 7, 6, 10, 15, 18, 14, 23},
       {3, 4, 8, 7, 11, 16, 19, 15, 24},
       {1, 5, 8, 4, 13, 20, 16, 12, 25},
       {5, 6, 7, 8, 17, 18, 19, 20, 26}}, // SFE_HEXA_27();
      {{}},                               // 233();
      {{}},                               // 234();
      {{}},                               // 235();
      {{1, 4, 3, 2, 16, 15, 14, 13, 12, 11, 10, 9, 33, 36, 35, 34},
       {1, 2, 6, 5, 9, 10, 19, 20, 26, 25, 18, 17, 37, 38, 39, 40},
       {2, 3, 7, 6, 11, 12, 21, 22, 28, 27, 20, 19, 41, 42, 43, 44},
       {3, 4, 8, 7, 13, 14, 23, 24, 30, 29, 22, 21, 45, 46, 47, 48},
       {1, 5, 8, 4, 17, 18, 32, 31, 24, 23, 15, 16, 50, 51, 52, 49},
       {5, 6, 7, 8, 25, 26, 27, 28, 29, 30, 31, 32, 53, 54, 55,
        56}}, // SFE_HEXA_64();
      {{1, 4, 3, 2, 16, 15, 14, 13, 12, 11, 10, 9, 33, 36, 35, 34},
       {1, 2, 6, 5, 9, 10, 19, 20, 26, 25, 18, 17, 37, 38, 39, 40},
       {2, 3, 7, 6, 11, 12, 21, 22, 28, 27, 20, 19, 41, 42, 43, 44},
       {3, 4, 8, 7, 13, 14, 23, 24, 30, 29, 22, 21, 45, 46, 47, 48},
       {1, 5, 8, 4, 17, 18, 32, 31, 24, 23, 15, 16, 50, 51, 52, 49},
       {5, 6, 7, 8, 25, 26, 27, 28, 29, 30, 31, 32, 53, 54, 55,
        56}}, // SFE_HEXA_FEK_64();
      {{}},   // 238();
      {{}},   // 239();
      {{1,  4,  3, 2,  20, 19, 18, 17, 16, 15, 14, 13, 12,
        11, 10, 9, 45, 52, 51, 50, 49, 48, 47, 46, 53},
       {1,  2,  6,  5,  9,  10, 11, 24, 25, 26, 35, 34, 33,
        23, 22, 21, 54, 55, 56, 57, 58, 59, 60, 61, 62},
       {2,  3,  7,  6,  12, 13, 14, 27, 28, 29, 38, 37, 36,
        26, 25, 24, 63, 64, 65, 66, 67, 68, 69, 70, 71},
       {3,  4,  8,  7,  15, 16, 17, 30, 31, 32, 40, 40, 39,
        29, 28, 27, 72, 73, 74, 75, 76, 77, 78, 79, 80},
       {1,  5,  8,  4,  21, 22, 23, 44, 43, 42, 32, 31, 30,
        18, 19, 20, 83, 84, 85, 86, 87, 88, 81, 82, 89},
       {5,  6,  7,  8,  33, 34, 35, 36, 37, 38, 39, 40, 41,
        42, 43, 44, 90, 91, 92, 93, 94, 95, 96, 97, 98}}, // SFE_HEXA_125();
      {{1,  4,  3, 2,  20, 19, 18, 17, 16, 15, 14, 13, 12,
        11, 10, 9, 45, 52, 51, 50, 49, 48, 47, 46, 53},
       {1,  2,  6,  5,  9,  10, 11, 24, 25, 26, 35, 34, 33,
        23, 22, 21, 54, 55, 56, 57, 58, 59, 60, 61, 62},
       {2,  3,  7,  6,  12, 13, 14, 27, 28, 29, 38, 37, 36,
        26, 25, 24, 63, 64, 65, 66, 67, 68, 69, 70, 71},
       {3,  4,  8,  7,  15, 16, 17, 30, 31, 32, 40, 40, 39,
        29, 28, 27, 72, 73, 74, 75, 76, 77, 78, 79, 80},
       {1,  5,  8,  4,  21, 22, 23, 44, 43, 42, 32, 31, 30,
        18, 19, 20, 83, 84, 85, 86, 87, 88, 81, 82, 89},
       {5,  6,  7,  8,  33, 34, 35, 36, 37, 38, 39, 40, 41,
        42, 43, 44, 90, 91, 92, 93, 94, 95, 96, 97, 98}}, // SFE_HEXA_FEK_125();
      {{}},                                               // 242();
      {{}},                                               // 243();
      {{1,  4, 3,  2,  24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11,
        10, 9, 57, 68, 67, 66, 65, 64, 63, 62, 61, 60, 59, 58, 69, 72, 71, 70},
       {1,  2,  6,  5,  9,  10, 11, 12, 29, 30, 31, 32, 44, 43, 42, 41, 28, 27,
        26, 25, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88},
       {2,  3,  7,  6,  13, 14, 15, 16,  33,  34,  35,  36,
        48, 47, 46, 45, 32, 31, 30, 29,  89,  90,  91,  92,
        93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104},
       {3,   4,   8,   7,   17,  18,  19,  20,  37,  38,  39,  40,
        52,  51,  50,  49,  36,  35,  34,  33,  105, 106, 107, 108,
        109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120},
       {1,   5,   8,   4,   25,  26,  27,  28,  56,  55,  54,  53,
        40,  39,  38,  37,  21,  22,  23,  24,  124, 125, 126, 127,
        128, 129, 130, 131, 132, 121, 122, 123, 134, 135, 136, 133},
       {5,   6,   7,   8,   41,  42,  43,  44,  45,  46,  47,  48,  49,
        50,  51,  52,  53,  54,  55,  56,  137, 138, 139, 140, 141, 142,
        143, 144, 145, 146, 147, 148, 149, 150, 151, 152}}, // SFE_HEXA_216();
      {{1,  4, 3,  2,  24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11,
        10, 9, 57, 68, 67, 66, 65, 64, 63, 62, 61, 60, 59, 58, 69, 72, 71, 70},
       {1,  2,  6,  5,  9,  10, 11, 12, 29, 30, 31, 32, 44, 43, 42, 41, 28, 27,
        26, 25, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88},
       {2,  3,  7,  6,  13, 14, 15, 16,  33,  34,  35,  36,
        48, 47, 46, 45, 32, 31, 30, 29,  89,  90,  91,  92,
        93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104},
       {3,   4,   8,   7,   17,  18,  19,  20,  37,  38,  39,  40,
        52,  51,  50,  49,  36,  35,  34,  33,  105, 106, 107, 108,
        109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120},
       {1,   5,   8,   4,   25,  26,  27,  28,  56,  55,  54,  53,
        40,  39,  38,  37,  21,  22,  23,  24,  124, 125, 126, 127,
        128, 129, 130, 131, 132, 121, 122, 123, 134, 135, 136, 133},
       {5,   6,   7,   8,   41,  42,  43,  44,  45,  46,  47,  48,  49,
        50,  51,  52,  53,  54,  55,  56,  137, 138, 139, 140, 141, 142,
        143, 144, 145, 146, 147, 148, 149, 150, 151, 152}}, // SFE_HEXA_FEK_216();
      {{}},                                                 // 246();
      {{}},                                                 // 247();
      {{1,  4,  3,  2,  28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16,
        15, 14, 13, 12, 11, 10, 9,  69, 84, 83, 82, 81, 80, 79, 78, 77, 76,
        75, 74, 73, 72, 71, 70, 85, 92, 91, 90, 89, 88, 87, 86, 93},
       {1,   2,   6,   5,   9,   10,  11,  12,  13,  34,  35,  36,  37,
        38,  53,  52,  51,  50,  49,  33,  32,  31,  30,  29,  94,  95,
        96,  97,  98,  99,  100, 101, 102, 103, 104, 105, 106, 107, 108,
        109, 110, 111, 112, 113, 114, 115, 116, 117, 118},
       {2,   3,   7,   6,   14,  15,  16,  17,  18,  39,  40,  41,  42,
        43,  58,  57,  56,  55,  54,  38,  37,  36,  35,  34,  119, 120,
        121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133,
        134, 135, 136, 137, 138, 139, 140, 141, 142, 143},
       {3,   4,   8,   7,   19,  20,  21,  22,  23,  44,  45,  46,  47,
        48,  63,  62,  61,  60,  59,  43,  42,  41,  40,  39,  144, 145,
        146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158,
        159, 160, 161, 162, 163, 164, 165, 166, 167, 168},
       {4,   1,   5,   8,   24,  25,  26,  27,  28,  29,  30,  31,  32,
        33,  68,  67,  66,  65,  64,  48,  47,  46,  45,  44,  169, 170,
        171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183,
        184, 185, 186, 187, 188, 189, 190, 191, 192, 193},
       {5,   6,   7,   8,   49,  50,  51,  52,  53,  54,  55,  56,  57,
        58,  59,  60,  61,  62,  63,  64,  65,  66,  67,  68,  194, 195,
        196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208,
        209, 210, 211, 212, 213, 214, 215, 216, 217, 218}}, // SFE_HEXA_343();
      {{1,  4,  3,  2,  28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16,
        15, 14, 13, 12, 11, 10, 9,  69, 84, 83, 82, 81, 80, 79, 78, 77, 76,
        75, 74, 73, 72, 71, 70, 85, 92, 91, 90, 89, 88, 87, 86, 93},
       {1,   2,   6,   5,   9,   10,  11,  12,  13,  34,  35,  36,  37,
        38,  53,  52,  51,  50,  49,  33,  32,  31,  30,  29,  94,  95,
        96,  97,  98,  99,  100, 101, 102, 103, 104, 105, 106, 107, 108,
        109, 110, 111, 112, 113, 114, 115, 116, 117, 118},
       {2,   3,   7,   6,   14,  15,  16,  17,  18,  39,  40,  41,  42,
        43,  58,  57,  56,  55,  54,  38,  37,  36,  35,  34,  119, 120,
        121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133,
        134, 135, 136, 137, 138, 139, 140, 141, 142, 143},
       {3,   4,   8,   7,   19,  20,  21,  22,  23,  44,  45,  46,  47,
        48,  63,  62,  61,  60,  59,  43,  42,  41,  40,  39,  144, 145,
        146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158,
        159, 160, 161, 162, 163, 164, 165, 166, 167, 168},
       {4,   1,   5,   8,   24,  25,  26,  27,  28,  29,  30,  31,  32,
        33,  68,  67,  66,  65,  64,  48,  47,  46,  45,  44,  169, 170,
        171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183,
        184, 185, 186, 187, 188, 189, 190, 191, 192, 193},
       {5,   6,   7,   8,   49,  50,  51,  52,  53,  54,  55,  56,  57,
        58,  59,  60,  61,  62,  63,  64,  65,  66,  67,  68,  194, 195,
        196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208,
        209, 210, 211, 212, 213, 214, 215, 216, 217, 218}}, // SFE_HEXA_FEK_343();
  };                                                        //();
  *ret = [&](int et, uint8_T fid) {
    return FACETS[et - 36][fid];
  }(etype, static_cast<uint8_T>(facetid - 1U));
  n = [&](int et, uint8_T fid) {
    int n = LIDS[et - 36][fid].size();
    while (n && LIDS[et - 36][fid][n - 1] == 0)
      --n;
    return n;
  }(etype, static_cast<uint8_T>(facetid - 1U));
  *lids_size = n;
  [&](int et, uint8_T fid, int n, std::int16_t *v) {
    std::copy_n(LIDS[et - 36][fid].cbegin(), n, v);
  }(etype, static_cast<uint8_T>(facetid - 1U), n, &lids_data[0]);
}

static void obtain_facets(int32_T etype, int8_T facetid, uint8_T *ret,
                          int16_T lids_data[], int32_T *lids_size)
{
  int32_T n;
  // obtain_facets - Query facet information
  //
  //     nfacets = obtain_facets(etype)
  //     facettype = obtain_facets(etype, facetid)
  //     [facettype, lids] = obtain_facets(etype, facetid)
  //
  //  PARAMETERS
  //  ----------
  //     etype:          Element type enums
  //     facetid:        Local facet IDs
  //
  //  RETURNS
  //  -------
  //  If only etype is provided, then this function returns
  //  a single number `nfacets`, which is the number
  //  of facets of an element.
  //
  //  If facet ID is provided (1:nfacets), then this function
  //  returns the facet element type of `facetid`. Optionally,
  //  it can also return the local IDs of the requested facet
  //
  //  This file was generated from update_facets_table
  //  MATLAB code ends
  const static std::vector<std::vector<uint8_T>> FACETS{
      //();
      {1, 1},                         // SFE_BAR_2();
      {},                             // 37();
      {},                             // 38();
      {},                             // 39();
      {1, 1},                         // SFE_BAR_3();
      {},                             // 41();
      {},                             // 42();
      {},                             // 43();
      {1, 1},                         // SFE_BAR_4();
      {1, 1},                         // SFE_BAR_FEK_4();
      {},                             // 46();
      {},                             // 47();
      {1, 1},                         // SFE_BAR_5();
      {1, 1},                         // SFE_BAR_FEK_5();
      {},                             // 50();
      {},                             // 51();
      {1, 1},                         // SFE_BAR_6();
      {1, 1},                         // SFE_BAR_FEK_6();
      {},                             // 54();
      {},                             // 55();
      {1, 1},                         // SFE_BAR_7();
      {1, 1},                         // SFE_BAR_FEK_7();
      {},                             // 58();
      {},                             // 59();
      {},                             // 60();
      {},                             // 61();
      {},                             // 62();
      {},                             // 63();
      {},                             // 64();
      {},                             // 65();
      {},                             // 66();
      {},                             // 67();
      {36, 36, 36},                   // SFE_TRI_3();
      {},                             // 69();
      {},                             // 70();
      {},                             // 71();
      {40, 40, 40},                   // SFE_TRI_6();
      {},                             // 73();
      {},                             // 74();
      {},                             // 75();
      {44, 44, 44},                   // SFE_TRI_10();
      {45, 45, 45},                   // SFE_TRI_FEK_10();
      {},                             // 78();
      {},                             // 79();
      {48, 48, 48},                   // SFE_TRI_15();
      {49, 49, 49},                   // SFE_TRI_GL_15();
      {48, 48, 48},                   // SFE_TRI_FEK_15();
      {},                             // 83();
      {52, 52, 52},                   // SFE_TRI_21();
      {53, 53, 53},                   // SFE_TRI_GL_21();
      {52, 52, 52},                   // SFE_TRI_FEK_21();
      {},                             // 87();
      {56, 56, 56},                   // SFE_TRI_28();
      {57, 57, 57},                   // SFE_TRI_GL_28();
      {56, 56, 56},                   // SFE_TRI_FEK_28();
      {},                             // 91();
      {},                             // 92();
      {},                             // 93();
      {},                             // 94();
      {},                             // 95();
      {},                             // 96();
      {},                             // 97();
      {},                             // 98();
      {},                             // 99();
      {36, 36, 36, 36},               // SFE_QUAD_4();
      {},                             // 101();
      {},                             // 102();
      {},                             // 103();
      {40, 40, 40, 40},               // SFE_QUAD_9();
      {},                             // 105();
      {},                             // 106();
      {},                             // 107();
      {44, 44, 44, 44},               // SFE_QUAD_16();
      {45, 45, 45, 45},               // SFE_QUAD_FEK_16();
      {},                             // 110();
      {},                             // 111();
      {48, 48, 48, 48},               // SFE_QUAD_25();
      {49, 49, 49, 49},               // SFE_QUAD_FEK_25();
      {},                             // 114();
      {},                             // 115();
      {52, 52, 52, 52},               // SFE_QUAD_36();
      {53, 53, 53, 53},               // SFE_QUAD_FEK_36();
      {},                             // 118();
      {},                             // 119();
      {56, 56, 56, 56},               // SFE_QUAD_49();
      {57, 57, 57, 57},               // SFE_QUAD_FEK_49();
      {},                             // 122();
      {},                             // 123();
      {},                             // 124();
      {},                             // 125();
      {},                             // 126();
      {},                             // 127();
      {},                             // 128();
      {},                             // 129();
      {},                             // 130();
      {},                             // 131();
      {68, 68, 68, 68},               // SFE_TET_4();
      {},                             // 133();
      {},                             // 134();
      {},                             // 135();
      {72, 72, 72, 72},               // SFE_TET_10();
      {},                             // 137();
      {},                             // 138();
      {},                             // 139();
      {76, 76, 76, 76},               // SFE_TET_20();
      {77, 77, 77, 77},               // SFE_TET_FEK_20();
      {},                             // 142();
      {},                             // 143();
      {80, 80, 80, 80},               // SFE_TET_35();
      {81, 81, 81, 81},               // SFE_TET_GL_35();
      {82, 82, 82, 82},               // SFE_TET_FEK_35();
      {},                             // 147();
      {84, 84, 84, 84},               // SFE_TET_56();
      {85, 85, 85, 85},               // SFE_TET_GL_56();
      {86, 86, 86, 86},               // SFE_TET_FEK_56();
      {},                             // 151();
      {88, 88, 88, 88},               // SFE_TET_84();
      {89, 89, 89, 89},               // SFE_TET_GL_84();
      {90, 90, 90, 90},               // SFE_TET_FEK_84();
      {},                             // 155();
      {},                             // 156();
      {},                             // 157();
      {},                             // 158();
      {},                             // 159();
      {},                             // 160();
      {},                             // 161();
      {},                             // 162();
      {},                             // 163();
      {100, 68, 68, 68, 68},          // SFE_PYRA_5();
      {},                             // 165();
      {},                             // 166();
      {},                             // 167();
      {104, 72, 72, 72, 72},          // SFE_PYRA_14();
      {},                             // 169();
      {},                             // 170();
      {},                             // 171();
      {108, 76, 76, 76, 76},          // SFE_PYRA_30();
      {109, 77, 77, 77, 77},          // SFE_PYRA_FEK_30();
      {},                             // 174();
      {},                             // 175();
      {112, 80, 80, 80, 80},          // SFE_PYRA_55();
      {113, 81, 81, 81, 81},          // SFE_PYRA_GL_55();
      {112, 82, 82, 82, 82},          // SFE_PYRA_FEK_55();
      {},                             // 179();
      {116, 84, 84, 84, 84},          // SFE_PYRA_91();
      {},                             // 181();
      {},                             // 182();
      {},                             // 183();
      {},                             // 184();
      {},                             // 185();
      {},                             // 186();
      {},                             // 187();
      {},                             // 188();
      {},                             // 189();
      {},                             // 190();
      {},                             // 191();
      {},                             // 192();
      {},                             // 193();
      {},                             // 194();
      {},                             // 195();
      {100, 100, 100, 68, 68},        // SFE_PRISM_6();
      {},                             // 197();
      {},                             // 198();
      {},                             // 199();
      {104, 104, 104, 72, 72},        // SFE_PRISM_18();
      {},                             // 201();
      {},                             // 202();
      {},                             // 203();
      {108, 108, 108, 76, 76},        // SFE_PRISM_40();
      {109, 109, 109, 77, 77},        // SFE_PRISM_FEK_40();
      {},                             // 206();
      {},                             // 207();
      {112, 112, 112, 80, 80},        // SFE_PRISM_75();
      {113, 113, 113, 81, 81},        // SFE_PRISM_GL_75();
      {112, 112, 112, 82, 82},        // SFE_PRISM_FEK_75();
      {},                             // 211();
      {116, 116, 116, 84, 84},        // SFE_PRISM_126();
      {117, 117, 117, 85, 85},        // SFE_PRISM_GL_126();
      {},                             // 214();
      {},                             // 215();
      {120, 120, 120, 88, 88},        // SFE_PRISM_196();
      {},                             // 217();
      {},                             // 218();
      {},                             // 219();
      {},                             // 220();
      {},                             // 221();
      {},                             // 222();
      {},                             // 223();
      {},                             // 224();
      {},                             // 225();
      {},                             // 226();
      {},                             // 227();
      {100, 100, 100, 100, 100, 100}, // SFE_HEXA_8();
      {},                             // 229();
      {},                             // 230();
      {},                             // 231();
      {104, 104, 104, 104, 104, 104}, // SFE_HEXA_27();
      {},                             // 233();
      {},                             // 234();
      {},                             // 235();
      {108, 108, 108, 108, 108, 108}, // SFE_HEXA_64();
      {109, 109, 109, 109, 109, 109}, // SFE_HEXA_FEK_64();
      {},                             // 238();
      {},                             // 239();
      {112, 112, 112, 112, 112, 112}, // SFE_HEXA_125();
      {113, 113, 113, 113, 113, 113}, // SFE_HEXA_FEK_125();
      {},                             // 242();
      {},                             // 243();
      {116, 116, 116, 116, 116, 116}, // SFE_HEXA_216();
      {117, 117, 117, 117, 117, 117}, // SFE_HEXA_FEK_216();
      {},                             // 246();
      {},                             // 247();
      {120, 120, 120, 120, 120, 120}, // SFE_HEXA_343();
      {121, 121, 121, 121, 121, 121}, // SFE_HEXA_FEK_343();
  };                                  //();
  const static std::vector<std::vector<std::vector<int16_T>>> LIDS{
      //();
      {{1}, {2}},                                 // SFE_BAR_2();
      {{}},                                       // 37();
      {{}},                                       // 38();
      {{}},                                       // 39();
      {{1}, {2}},                                 // SFE_BAR_3();
      {{}},                                       // 41();
      {{}},                                       // 42();
      {{}},                                       // 43();
      {{1}, {2}},                                 // SFE_BAR_4();
      {{1}, {2}},                                 // SFE_BAR_FEK_4();
      {{}},                                       // 46();
      {{}},                                       // 47();
      {{1}, {2}},                                 // SFE_BAR_5();
      {{1}, {2}},                                 // SFE_BAR_FEK_5();
      {{}},                                       // 50();
      {{}},                                       // 51();
      {{1}, {2}},                                 // SFE_BAR_6();
      {{1}, {2}},                                 // SFE_BAR_FEK_6();
      {{}},                                       // 54();
      {{}},                                       // 55();
      {{1}, {2}},                                 // SFE_BAR_7();
      {{1}, {2}},                                 // SFE_BAR_FEK_7();
      {{}},                                       // 58();
      {{}},                                       // 59();
      {{}},                                       // 60();
      {{}},                                       // 61();
      {{}},                                       // 62();
      {{}},                                       // 63();
      {{}},                                       // 64();
      {{}},                                       // 65();
      {{}},                                       // 66();
      {{}},                                       // 67();
      {{1, 2}, {2, 3}, {3, 1}},                   // SFE_TRI_3();
      {{}},                                       // 69();
      {{}},                                       // 70();
      {{}},                                       // 71();
      {{1, 2, 4}, {2, 3, 5}, {3, 1, 6}},          // SFE_TRI_6();
      {{}},                                       // 73();
      {{}},                                       // 74();
      {{}},                                       // 75();
      {{1, 2, 4, 5}, {2, 3, 6, 7}, {3, 1, 8, 9}}, // SFE_TRI_10();
      {{1, 2, 4, 5}, {2, 3, 6, 7}, {3, 1, 8, 9}}, // SFE_TRI_FEK_10();
      {{}},                                       // 78();
      {{}},                                       // 79();
      {{1, 2, 4, 5, 6}, {2, 3, 7, 8, 9}, {3, 1, 10, 11, 12}}, // SFE_TRI_15();
      {{1, 2, 4, 5, 6},
       {2, 3, 7, 8, 9},
       {3, 1, 10, 11, 12}}, // SFE_TRI_GL_15();
      {{1, 2, 4, 5, 6},
       {2, 3, 7, 8, 9},
       {3, 1, 10, 11, 12}}, // SFE_TRI_FEK_15();
      {{}},                 // 83();
      {{1, 2, 4, 5, 6, 7},
       {2, 3, 8, 9, 10, 11},
       {3, 1, 12, 13, 14, 15}}, // SFE_TRI_21();
      {{1, 2, 4, 5, 6, 7},
       {2, 3, 8, 9, 10, 11},
       {3, 1, 12, 13, 14, 15}}, // SFE_TRI_GL_21();
      {{1, 2, 4, 5, 6, 7},
       {2, 3, 8, 9, 10, 11},
       {3, 1, 12, 13, 14, 15}}, // SFE_TRI_FEK_21();
      {{}},                     // 87();
      {{1, 2, 4, 5, 6, 7, 8},
       {2, 3, 9, 10, 11, 12, 13},
       {3, 1, 14, 15, 16, 17, 18}}, // SFE_TRI_28();
      {{1, 2, 4, 5, 6, 7, 8},
       {2, 3, 9, 10, 11, 12, 13},
       {3, 1, 14, 15, 16, 17, 18}}, // SFE_TRI_GL_28();
      {{1, 2, 4, 5, 6, 7, 8},
       {2, 3, 9, 10, 11, 12, 13},
       {3, 1, 14, 15, 16, 17, 18}},                 // SFE_TRI_FEK_28();
      {{}},                                         // 91();
      {{}},                                         // 92();
      {{}},                                         // 93();
      {{}},                                         // 94();
      {{}},                                         // 95();
      {{}},                                         // 96();
      {{}},                                         // 97();
      {{}},                                         // 98();
      {{}},                                         // 99();
      {{1, 2}, {2, 3}, {3, 4}, {4, 1}},             // SFE_QUAD_4();
      {{}},                                         // 101();
      {{}},                                         // 102();
      {{}},                                         // 103();
      {{1, 2, 5}, {2, 3, 6}, {3, 4, 7}, {4, 1, 8}}, // SFE_QUAD_9();
      {{}},                                         // 105();
      {{}},                                         // 106();
      {{}},                                         // 107();
      {{1, 2, 5, 6},
       {2, 3, 7, 8},
       {3, 4, 9, 10},
       {4, 1, 11, 12}}, // SFE_QUAD_16();
      {{1, 2, 5, 6},
       {2, 3, 7, 8},
       {3, 4, 9, 10},
       {4, 1, 11, 12}}, // SFE_QUAD_FEK_16();
      {{}},             // 110();
      {{}},             // 111();
      {{1, 2, 5, 6, 7},
       {2, 3, 8, 9, 10},
       {3, 4, 11, 12, 13},
       {4, 1, 14, 15, 16}}, // SFE_QUAD_25();
      {{1, 2, 5, 6, 7},
       {2, 3, 8, 9, 10},
       {3, 4, 11, 12, 13},
       {4, 1, 14, 15, 16}}, // SFE_QUAD_FEK_25();
      {{}},                 // 114();
      {{}},                 // 115();
      {{1, 2, 5, 6, 7, 8},
       {2, 3, 9, 10, 11, 12},
       {3, 4, 13, 14, 15, 16},
       {4, 1, 17, 18, 19, 20}}, // SFE_QUAD_36();
      {{1, 2, 5, 6, 7, 8},
       {2, 3, 9, 10, 11, 12},
       {3, 4, 13, 14, 15, 16},
       {4, 1, 17, 18, 19, 20}}, // SFE_QUAD_FEK_36();
      {{}},                     // 118();
      {{}},                     // 119();
      {{1, 2, 5, 6, 7, 8, 9},
       {2, 3, 10, 11, 12, 13, 14},
       {3, 4, 15, 16, 17, 18, 19},
       {4, 1, 20, 21, 22, 23, 24}}, // SFE_QUAD_49();
      {{1, 2, 5, 6, 7, 8, 9},
       {2, 3, 10, 11, 12, 13, 14},
       {3, 4, 15, 16, 17, 18, 19},
       {4, 1, 20, 21, 22, 23, 24}},                 // SFE_QUAD_FEK_49();
      {{}},                                         // 122();
      {{}},                                         // 123();
      {{}},                                         // 124();
      {{}},                                         // 125();
      {{}},                                         // 126();
      {{}},                                         // 127();
      {{}},                                         // 128();
      {{}},                                         // 129();
      {{}},                                         // 130();
      {{}},                                         // 131();
      {{1, 3, 2}, {1, 2, 4}, {2, 3, 4}, {3, 1, 4}}, // SFE_TET_4();
      {{}},                                         // 133();
      {{}},                                         // 134();
      {{}},                                         // 135();
      {{1, 3, 2, 7, 6, 5},
       {1, 2, 4, 5, 9, 8},
       {2, 3, 4, 6, 10, 9},
       {3, 1, 4, 7, 8, 10}}, // SFE_TET_10();
      {{}},                  // 137();
      {{}},                  // 138();
      {{}},                  // 139();
      {{1, 3, 2, 10, 9, 8, 7, 6, 5, 17},
       {1, 2, 4, 5, 6, 13, 14, 12, 11, 18},
       {2, 3, 4, 7, 8, 15, 16, 14, 13, 19},
       {3, 1, 4, 9, 10, 11, 12, 16, 15, 20}}, // SFE_TET_20();
      {{1, 3, 2, 10, 9, 8, 7, 6, 5, 17},
       {1, 2, 4, 5, 6, 13, 14, 12, 11, 18},
       {2, 3, 4, 7, 8, 15, 16, 14, 13, 19},
       {3, 1, 4, 9, 10, 11, 12, 16, 15, 20}}, // SFE_TET_FEK_20();
      {{}},                                   // 142();
      {{}},                                   // 143();
      {{1, 3, 2, 13, 12, 11, 10, 9, 8, 7, 6, 5, 23, 25, 24},
       {1, 2, 4, 5, 6, 7, 17, 18, 19, 16, 15, 14, 26, 27, 28},
       {2, 3, 4, 8, 9, 10, 20, 21, 22, 19, 18, 17, 29, 30, 31},
       {3, 1, 4, 11, 12, 13, 14, 15, 16, 22, 21, 20, 32, 33,
        34}}, // SFE_TET_35();
      {{1, 3, 2, 13, 12, 11, 10, 9, 8, 7, 6, 5, 23, 25, 24},
       {1, 2, 4, 5, 6, 7, 17, 18, 19, 16, 15, 14, 26, 27, 28},
       {2, 3, 4, 8, 9, 10, 20, 21, 22, 19, 18, 17, 29, 30, 31},
       {3, 1, 4, 11, 12, 13, 14, 15, 16, 22, 21, 20, 32, 33,
        34}}, // SFE_TET_GL_35();
      {{1, 3, 2, 13, 12, 11, 10, 9, 8, 7, 6, 5, 23, 25, 24},
       {1, 2, 4, 5, 6, 7, 17, 18, 19, 16, 15, 14, 26, 27, 28},
       {2, 3, 4, 8, 9, 10, 20, 21, 22, 19, 18, 17, 29, 30, 31},
       {3, 1, 4, 11, 12, 13, 14, 15, 16, 22, 21, 20, 32, 33,
        34}}, // SFE_TET_FEK_35();
      {{}},   // 147();
      {{1, 3, 2, 16, 15, 14, 13, 12, 11, 10, 9,
        8, 7, 6, 5,  29, 34, 33, 32, 31, 30},
       {1,  2,  4,  5,  6,  7,  8,  21, 22, 23, 24,
        20, 19, 18, 17, 35, 36, 37, 38, 39, 40},
       {2,  3,  4,  9,  10, 11, 12, 25, 26, 27, 28,
        24, 23, 22, 21, 41, 42, 43, 44, 45, 46},
       {3,  1,  4,  13, 14, 15, 16, 17, 18, 19, 20,
        28, 27, 26, 25, 47, 48, 49, 50, 51, 52}}, // SFE_TET_56();
      {{1, 3, 2, 16, 15, 14, 13, 12, 11, 10, 9,
        8, 7, 6, 5,  29, 34, 33, 32, 31, 30},
       {1,  2,  4,  5,  6,  7,  8,  21, 22, 23, 24,
        20, 19, 18, 17, 35, 36, 37, 38, 39, 40},
       {2,  3,  4,  9,  10, 11, 12, 25, 26, 27, 28,
        24, 23, 22, 21, 41, 42, 43, 44, 45, 46},
       {3,  1,  4,  13, 14, 15, 16, 17, 18, 19, 20,
        28, 27, 26, 25, 47, 48, 49, 50, 51, 52}}, // SFE_TET_GL_56();
      {{1, 3, 2, 16, 15, 14, 13, 12, 11, 10, 9,
        8, 7, 6, 5,  29, 34, 33, 32, 31, 30},
       {1,  2,  4,  5,  6,  7,  8,  21, 22, 23, 24,
        20, 19, 18, 17, 35, 36, 37, 38, 39, 40},
       {2,  3,  4,  9,  10, 11, 12, 25, 26, 27, 28,
        24, 23, 22, 21, 41, 42, 43, 44, 45, 46},
       {3,  1,  4,  13, 14, 15, 16, 17, 18, 19, 20,
        28, 27, 26, 25, 47, 48, 49, 50, 51, 52}}, // SFE_TET_FEK_56();
      {{}},                                       // 151();
      {{1, 3, 2, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9,
        8, 7, 6, 5,  35, 43, 42, 41, 40, 39, 38, 37, 36, 44},
       {1,  2,  4,  5,  6,  7,  8,  9,  25, 26, 27, 28, 29, 24,
        23, 22, 21, 20, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54},
       {2,  3,  4,  10, 11, 12, 13, 14, 30, 31, 32, 33, 34, 29,
        28, 27, 26, 25, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64},
       {3,  1,  4,  15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 34, 33,
        32, 31, 30, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74}}, // SFE_TET_84();
      {{1, 3, 2, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9,
        8, 7, 6, 5,  35, 43, 42, 41, 40, 39, 38, 37, 36, 44},
       {1,  2,  4,  5,  6,  7,  8,  9,  25, 26, 27, 28, 29, 24,
        23, 22, 21, 20, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54},
       {2,  3,  4,  10, 11, 12, 13, 14, 30, 31, 32, 33, 34, 29,
        28, 27, 26, 25, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64},
       {3,  1,  4,  15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 34, 33,
        32, 31, 30, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74}}, // SFE_TET_GL_84();
      {{1, 3, 2, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9,
        8, 7, 6, 5,  35, 43, 42, 41, 40, 39, 38, 37, 36, 44},
       {1,  2,  4,  5,  6,  7,  8,  9,  25, 26, 27, 28, 29, 24,
        23, 22, 21, 20, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54},
       {2,  3,  4,  10, 11, 12, 13, 14, 30, 31, 32, 33, 34, 29,
        28, 27, 26, 25, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64},
       {3,  1,  4,  15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 34, 33,
        32, 31, 30, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74}}, // SFE_TET_FEK_84();
      {{}},                                                   // 155();
      {{}},                                                   // 156();
      {{}},                                                   // 157();
      {{}},                                                   // 158();
      {{}},                                                   // 159();
      {{}},                                                   // 160();
      {{}},                                                   // 161();
      {{}},                                                   // 162();
      {{}},                                                   // 163();
      {{1, 4, 3, 2},
       {1, 2, 5, 0},
       {2, 3, 5, 0},
       {3, 4, 5, 0},
       {4, 1, 5, 0}}, // SFE_PYRA_5();
      {{}},           // 165();
      {{}},           // 166();
      {{}},           // 167();
      {{1, 4, 3, 2, 9, 8, 7, 6, 14},
       {1, 2, 5, 6, 11, 10, 0, 0, 0},
       {2, 3, 5, 7, 12, 11, 0, 0, 0},
       {3, 4, 5, 8, 13, 12, 0, 0, 0},
       {4, 1, 5, 9, 10, 13, 0, 0, 0}}, // SFE_PYRA_14();
      {{}},                            // 169();
      {{}},                            // 170();
      {{}},                            // 171();
      {{1, 4, 3, 2, 13, 12, 11, 10, 9, 8, 7, 6, 22, 25, 24, 23},
       {1, 2, 5, 6, 7, 16, 17, 15, 14, 26, 0, 0, 0, 0, 0, 0},
       {2, 3, 5, 8, 9, 18, 19, 17, 16, 27, 0, 0, 0, 0, 0, 0},
       {3, 4, 5, 10, 11, 20, 21, 19, 18, 28, 0, 0, 0, 0, 0, 0},
       {4, 1, 5, 12, 13, 14, 15, 21, 20, 29, 0, 0, 0, 0, 0,
        0}}, // SFE_PYRA_30();
      {{1, 4, 3, 2, 13, 12, 11, 10, 9, 8, 7, 6, 22, 25, 24, 23},
       {1, 2, 5, 6, 7, 16, 17, 15, 14, 26, 0, 0, 0, 0, 0, 0},
       {2, 3, 5, 8, 9, 18, 19, 17, 16, 27, 0, 0, 0, 0, 0, 0},
       {3, 4, 5, 10, 11, 20, 21, 19, 18, 28, 0, 0, 0, 0, 0, 0},
       {4, 1, 5, 12, 13, 14, 15, 21, 20, 29, 0, 0, 0, 0, 0,
        0}}, // SFE_PYRA_FEK_30();
      {{}},  // 174();
      {{}},  // 175();
      {{1, 4, 3, 2,  17, 16, 15, 14, 13, 12, 11, 10, 9,
        8, 7, 6, 30, 37, 36, 35, 34, 33, 32, 31, 38},
       {1,  2,  5, 6, 7, 8, 21, 22, 23, 20, 19, 18, 39,
        40, 41, 0, 0, 0, 0, 0,  0,  0,  0,  0,  0},
       {2,  3,  5, 9, 10, 11, 24, 25, 26, 23, 22, 21, 42,
        43, 44, 0, 0, 0,  0,  0,  0,  0,  0,  0,  0},
       {3,  4,  5, 12, 13, 14, 27, 28, 29, 26, 25, 24, 45,
        46, 47, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0},
       {4,  1,  5, 15, 16, 17, 18, 19, 20, 29, 28, 27, 48,
        49, 50, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0}}, // SFE_PYRA_55();
      {{1, 4, 3, 2,  17, 16, 15, 14, 13, 12, 11, 10, 9,
        8, 7, 6, 30, 37, 36, 35, 34, 33, 32, 31, 38},
       {1,  2,  5, 6, 7, 8, 21, 22, 23, 20, 19, 18, 39,
        40, 41, 0, 0, 0, 0, 0,  0,  0,  0,  0,  0},
       {2,  3,  5, 9, 10, 11, 24, 25, 26, 23, 22, 21, 42,
        43, 44, 0, 0, 0,  0,  0,  0,  0,  0,  0,  0},
       {3,  4,  5, 12, 13, 14, 27, 28, 29, 26, 25, 24, 45,
        46, 47, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0},
       {4,  1,  5, 15, 16, 17, 18, 19, 20, 29, 28, 27, 48,
        49, 50, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0}}, // SFE_PYRA_GL_55();
      {{1, 4, 3, 2,  17, 16, 15, 14, 13, 12, 11, 10, 9,
        8, 7, 6, 30, 37, 36, 35, 34, 33, 32, 31, 38},
       {1,  2,  5, 6, 7, 8, 21, 22, 23, 20, 19, 18, 39,
        40, 41, 0, 0, 0, 0, 0,  0,  0,  0,  0,  0},
       {2,  3,  5, 9, 10, 11, 24, 25, 26, 23, 22, 21, 42,
        43, 44, 0, 0, 0,  0,  0,  0,  0,  0,  0,  0},
       {3,  4,  5, 12, 13, 14, 27, 28, 29, 26, 25, 24, 45,
        46, 47, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0},
       {4,  1,  5, 15, 16, 17, 18, 19, 20, 29, 28, 27, 48,
        49, 50, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0}}, // SFE_PYRA_FEK_55();
      {{}},                                             // 179();
      {{1, 4, 3,  2,  21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9,  8,
        7, 6, 38, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 50, 53, 52, 51},
       {1,  2,  5,  6, 7, 8, 9, 26, 27, 28, 29, 25, 24, 23, 22, 54, 55, 56,
        57, 58, 59, 0, 0, 0, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
       {2,  3,  5,  10, 11, 12, 13, 30, 31, 32, 33, 29, 28, 27, 26, 60, 61, 62,
        63, 64, 65, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
       {3,  4,  5,  14, 15, 16, 17, 34, 35, 36, 37, 33, 32, 31, 30, 66, 67, 68,
        69, 70, 71, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
       {4,  1,  5,  18, 19, 20, 21, 22, 23, 24, 25, 37,
        36, 35, 34, 72, 73, 74, 75, 76, 77, 0,  0,  0,
        0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0}}, // SFE_PYRA_91();
      {{}},                                              // 181();
      {{}},                                              // 182();
      {{}},                                              // 183();
      {{}},                                              // 184();
      {{}},                                              // 185();
      {{}},                                              // 186();
      {{}},                                              // 187();
      {{}},                                              // 188();
      {{}},                                              // 189();
      {{}},                                              // 190();
      {{}},                                              // 191();
      {{}},                                              // 192();
      {{}},                                              // 193();
      {{}},                                              // 194();
      {{}},                                              // 195();
      {{1, 2, 5, 4},
       {2, 3, 6, 5},
       {3, 1, 4, 6},
       {1, 3, 2, 0},
       {4, 5, 6, 0}}, // SFE_PRISM_6();
      {{}},           // 197();
      {{}},           // 198();
      {{}},           // 199();
      {{1, 2, 5, 4, 7, 11, 13, 10, 16},
       {2, 3, 6, 5, 8, 12, 14, 11, 17},
       {3, 1, 4, 6, 9, 10, 15, 12, 18},
       {1, 3, 2, 9, 8, 7, 0, 0, 0},
       {4, 5, 6, 13, 14, 15, 0, 0, 0}}, // SFE_PRISM_18();
      {{}},                             // 201();
      {{}},                             // 202();
      {{}},                             // 203();
      {{1, 2, 5, 4, 7, 8, 15, 16, 20, 19, 14, 13, 26, 27, 28, 29},
       {2, 3, 6, 5, 9, 10, 17, 18, 22, 21, 16, 15, 30, 31, 32, 33},
       {3, 1, 4, 6, 11, 12, 13, 14, 24, 23, 18, 17, 34, 35, 36, 37},
       {1, 3, 2, 12, 11, 10, 9, 8, 7, 25, 0, 0, 0, 0, 0, 0},
       {4, 5, 6, 19, 20, 21, 22, 23, 24, 38, 0, 0, 0, 0, 0,
        0}}, // SFE_PRISM_40();
      {{1, 2, 5, 4, 7, 8, 15, 16, 20, 19, 14, 13, 26, 27, 28, 29},
       {2, 3, 6, 5, 9, 10, 17, 18, 22, 21, 16, 15, 30, 31, 32, 33},
       {3, 1, 4, 6, 11, 12, 13, 14, 24, 23, 18, 17, 34, 35, 36, 37},
       {1, 3, 2, 12, 11, 10, 9, 8, 7, 25, 0, 0, 0, 0, 0, 0},
       {4, 5, 6, 19, 20, 21, 22, 23, 24, 38, 0, 0, 0, 0, 0,
        0}}, // SFE_PRISM_FEK_40();
      {{}},  // 206();
      {{}},  // 207();
      {{1,  2,  5,  4,  7,  8,  9,  19, 20, 21, 27, 26, 25,
        18, 17, 16, 37, 38, 39, 40, 41, 42, 43, 44, 45},
       {2,  3,  6,  5,  10, 11, 12, 22, 23, 24, 30, 29, 28,
        21, 20, 19, 46, 47, 48, 49, 50, 51, 52, 53, 54},
       {3,  1,  4,  6,  13, 14, 15, 16, 17, 18, 33, 32, 31,
        24, 23, 22, 55, 56, 57, 58, 59, 60, 61, 62, 63},
       {1,  3,  2, 15, 14, 13, 12, 11, 10, 9, 8, 7, 34,
        36, 35, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0},
       {4,  5,  6, 25, 26, 27, 28, 29, 30, 31, 32, 33, 64,
        65, 66, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0}}, // SFE_PRISM_75();
      {{1,  2,  5,  4,  7,  8,  9,  19, 20, 21, 27, 26, 25,
        18, 17, 16, 37, 38, 39, 40, 41, 42, 43, 44, 45},
       {2,  3,  6,  5,  10, 11, 12, 22, 23, 24, 30, 29, 28,
        21, 20, 19, 46, 47, 48, 49, 50, 51, 52, 53, 54},
       {3,  1,  4,  6,  13, 14, 15, 16, 17, 18, 33, 32, 31,
        24, 23, 22, 55, 56, 57, 58, 59, 60, 61, 62, 63},
       {1,  3,  2, 15, 14, 13, 12, 11, 10, 9, 8, 7, 34,
        36, 35, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0},
       {4,  5,  6, 25, 26, 27, 28, 29, 30, 31, 32, 33, 64,
        65, 66, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0}}, // SFE_PRISM_GL_75();
      {{1,  2,  5,  4,  7,  8,  9,  19, 20, 21, 27, 26, 25,
        18, 17, 16, 37, 38, 39, 40, 41, 42, 43, 44, 45},
       {2,  3,  6,  5,  10, 11, 12, 22, 23, 24, 30, 29, 28,
        21, 20, 19, 46, 47, 48, 49, 50, 51, 52, 53, 54},
       {3,  1,  4,  6,  13, 14, 15, 16, 17, 18, 33, 32, 31,
        24, 23, 22, 55, 56, 57, 58, 59, 60, 61, 62, 63},
       {1,  3,  2, 15, 14, 13, 12, 11, 10, 9, 8, 7, 34,
        36, 35, 0, 0,  0,  0,  0,  0,  0,  0, 0, 0},
       {4,  5,  6, 25, 26, 27, 28, 29, 30, 31, 32, 33, 64,
        65, 66, 0, 0,  0,  0,  0,  0,  0,  0,  0,  0}}, // SFE_PRISM_FEK_75();
      {{}},                                             // 211();
      {{1,  2,  5,  4,  7,  8,  9,  10, 23, 24, 25, 26, 34, 33, 32, 31, 24, 23,
        22, 21, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58},
       {2,  3,  6,  5,  11, 12, 13, 14, 27, 28, 29, 30, 38, 37, 36, 35, 26, 25,
        24, 23, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74},
       {3,  1,  4,  6,  15, 16, 17, 18, 19, 20, 21, 22, 42, 41, 40, 39, 30, 29,
        28, 27, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90},
       {1,  3,  2,  18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 91, 96, 95,
        94, 93, 92, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 0, 0, 0,  0,  0},
       {4,  5,  6,  31, 32, 33, 34,  35,  36,  37, 38, 39,
        40, 41, 42, 97, 98, 99, 100, 101, 102, 0,  0,  0,
        0,  0,  0,  0,  0,  0,  0,   0,   0,   0,  0,  0}}, // SFE_PRISM_126();
      {{1,  2,  5,  4,  7,  8,  9,  10, 23, 24, 25, 26, 34, 33, 32, 31, 24, 23,
        22, 21, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58},
       {2,  3,  6,  5,  11, 12, 13, 14, 27, 28, 29, 30, 38, 37, 36, 35, 26, 25,
        24, 23, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74},
       {3,  1,  4,  6,  15, 16, 17, 18, 19, 20, 21, 22, 42, 41, 40, 39, 30, 29,
        28, 27, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90},
       {1,  3,  2,  18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 91, 96, 95,
        94, 93, 92, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 0, 0, 0,  0,  0},
       {4,  5,  6,  31, 32, 33,  34,  35,  36, 37, 38, 39, 40,
        41, 42, 97, 98, 99, 100, 101, 102, 0,  0,  0,  0,  0,
        0,  0,  0,  0,  0,  0,   0,   0,   0,  0}}, // SFE_PRISM_GL_126();
      {{}},                                         // 214();
      {{}},                                         // 215();
      {{1,  2,  5,  4,  7,  8,  9,  10, 11, 27, 28, 29, 30, 31, 41, 40, 39,
        38, 37, 26, 25, 24, 23, 22, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61,
        62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76},
       {2,  3,  6,  5,  12, 13, 14, 15, 16, 32, 33, 34, 35, 36,  46, 45, 44,
        43, 42, 31, 30, 29, 28, 27, 77, 78, 79, 80, 81, 82, 83,  84, 85, 86,
        87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101},
       {3,   1,   4,   6,   17,  18,  19,  20,  21,  22,  23,  24,  25,
        26,  51,  50,  49,  48,  47,  26,  25,  24,  23,  22,  102, 103,
        104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116,
        117, 118, 119, 120, 121, 122, 123, 124, 125, 126},
       {1,   3,   2, 21, 20, 19,  18,  17,  16,  15,  14,  13,  12,
        11,  10,  9, 8,  7,  127, 135, 134, 133, 132, 131, 130, 129,
        128, 136, 0, 0,  0,  0,   0,   0,   0,   0,   0,   0,   0,
        0,   0,   0, 0,  0,  0,   0,   0,   0,   0},
       {4,   5,   6,  37, 38, 39,  40,  41,  42,  43,  44,  45,  46,
        47,  48,  49, 50, 51, 137, 138, 139, 140, 141, 142, 143, 144,
        145, 146, 0,  0,  0,  0,   0,   0,   0,   0,   0,   0,   0,
        0,   0,   0,  0,  0,  0,   0,   0,   0,   0}}, // SFE_PRISM_196();
      {{}},                                            // 217();
      {{}},                                            // 218();
      {{}},                                            // 219();
      {{}},                                            // 220();
      {{}},                                            // 221();
      {{}},                                            // 222();
      {{}},                                            // 223();
      {{}},                                            // 224();
      {{}},                                            // 225();
      {{}},                                            // 226();
      {{}},                                            // 227();
      {{1, 4, 3, 2},
       {1, 2, 6, 5},
       {2, 3, 7, 6},
       {3, 4, 8, 7},
       {1, 5, 8, 4},
       {5, 6, 7, 8}}, // SFE_HEXA_8();
      {{}},           // 229();
      {{}},           // 230();
      {{}},           // 231();
      {{1, 4, 3, 2, 12, 11, 10, 9, 21},
       {1, 2, 6, 5, 9, 14, 17, 13, 22},
       {2, 3, 7, 6, 10, 15, 18, 14, 23},
       {3, 4, 8, 7, 11, 16, 19, 15, 24},
       {1, 5, 8, 4, 13, 20, 16, 12, 25},
       {5, 6, 7, 8, 17, 18, 19, 20, 26}}, // SFE_HEXA_27();
      {{}},                               // 233();
      {{}},                               // 234();
      {{}},                               // 235();
      {{1, 4, 3, 2, 16, 15, 14, 13, 12, 11, 10, 9, 33, 36, 35, 34},
       {1, 2, 6, 5, 9, 10, 19, 20, 26, 25, 18, 17, 37, 38, 39, 40},
       {2, 3, 7, 6, 11, 12, 21, 22, 28, 27, 20, 19, 41, 42, 43, 44},
       {3, 4, 8, 7, 13, 14, 23, 24, 30, 29, 22, 21, 45, 46, 47, 48},
       {1, 5, 8, 4, 17, 18, 32, 31, 24, 23, 15, 16, 50, 51, 52, 49},
       {5, 6, 7, 8, 25, 26, 27, 28, 29, 30, 31, 32, 53, 54, 55,
        56}}, // SFE_HEXA_64();
      {{1, 4, 3, 2, 16, 15, 14, 13, 12, 11, 10, 9, 33, 36, 35, 34},
       {1, 2, 6, 5, 9, 10, 19, 20, 26, 25, 18, 17, 37, 38, 39, 40},
       {2, 3, 7, 6, 11, 12, 21, 22, 28, 27, 20, 19, 41, 42, 43, 44},
       {3, 4, 8, 7, 13, 14, 23, 24, 30, 29, 22, 21, 45, 46, 47, 48},
       {1, 5, 8, 4, 17, 18, 32, 31, 24, 23, 15, 16, 50, 51, 52, 49},
       {5, 6, 7, 8, 25, 26, 27, 28, 29, 30, 31, 32, 53, 54, 55,
        56}}, // SFE_HEXA_FEK_64();
      {{}},   // 238();
      {{}},   // 239();
      {{1,  4,  3, 2,  20, 19, 18, 17, 16, 15, 14, 13, 12,
        11, 10, 9, 45, 52, 51, 50, 49, 48, 47, 46, 53},
       {1,  2,  6,  5,  9,  10, 11, 24, 25, 26, 35, 34, 33,
        23, 22, 21, 54, 55, 56, 57, 58, 59, 60, 61, 62},
       {2,  3,  7,  6,  12, 13, 14, 27, 28, 29, 38, 37, 36,
        26, 25, 24, 63, 64, 65, 66, 67, 68, 69, 70, 71},
       {3,  4,  8,  7,  15, 16, 17, 30, 31, 32, 40, 40, 39,
        29, 28, 27, 72, 73, 74, 75, 76, 77, 78, 79, 80},
       {1,  5,  8,  4,  21, 22, 23, 44, 43, 42, 32, 31, 30,
        18, 19, 20, 83, 84, 85, 86, 87, 88, 81, 82, 89},
       {5,  6,  7,  8,  33, 34, 35, 36, 37, 38, 39, 40, 41,
        42, 43, 44, 90, 91, 92, 93, 94, 95, 96, 97, 98}}, // SFE_HEXA_125();
      {{1,  4,  3, 2,  20, 19, 18, 17, 16, 15, 14, 13, 12,
        11, 10, 9, 45, 52, 51, 50, 49, 48, 47, 46, 53},
       {1,  2,  6,  5,  9,  10, 11, 24, 25, 26, 35, 34, 33,
        23, 22, 21, 54, 55, 56, 57, 58, 59, 60, 61, 62},
       {2,  3,  7,  6,  12, 13, 14, 27, 28, 29, 38, 37, 36,
        26, 25, 24, 63, 64, 65, 66, 67, 68, 69, 70, 71},
       {3,  4,  8,  7,  15, 16, 17, 30, 31, 32, 40, 40, 39,
        29, 28, 27, 72, 73, 74, 75, 76, 77, 78, 79, 80},
       {1,  5,  8,  4,  21, 22, 23, 44, 43, 42, 32, 31, 30,
        18, 19, 20, 83, 84, 85, 86, 87, 88, 81, 82, 89},
       {5,  6,  7,  8,  33, 34, 35, 36, 37, 38, 39, 40, 41,
        42, 43, 44, 90, 91, 92, 93, 94, 95, 96, 97, 98}}, // SFE_HEXA_FEK_125();
      {{}},                                               // 242();
      {{}},                                               // 243();
      {{1,  4, 3,  2,  24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11,
        10, 9, 57, 68, 67, 66, 65, 64, 63, 62, 61, 60, 59, 58, 69, 72, 71, 70},
       {1,  2,  6,  5,  9,  10, 11, 12, 29, 30, 31, 32, 44, 43, 42, 41, 28, 27,
        26, 25, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88},
       {2,  3,  7,  6,  13, 14, 15, 16,  33,  34,  35,  36,
        48, 47, 46, 45, 32, 31, 30, 29,  89,  90,  91,  92,
        93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104},
       {3,   4,   8,   7,   17,  18,  19,  20,  37,  38,  39,  40,
        52,  51,  50,  49,  36,  35,  34,  33,  105, 106, 107, 108,
        109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120},
       {1,   5,   8,   4,   25,  26,  27,  28,  56,  55,  54,  53,
        40,  39,  38,  37,  21,  22,  23,  24,  124, 125, 126, 127,
        128, 129, 130, 131, 132, 121, 122, 123, 134, 135, 136, 133},
       {5,   6,   7,   8,   41,  42,  43,  44,  45,  46,  47,  48,  49,
        50,  51,  52,  53,  54,  55,  56,  137, 138, 139, 140, 141, 142,
        143, 144, 145, 146, 147, 148, 149, 150, 151, 152}}, // SFE_HEXA_216();
      {{1,  4, 3,  2,  24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11,
        10, 9, 57, 68, 67, 66, 65, 64, 63, 62, 61, 60, 59, 58, 69, 72, 71, 70},
       {1,  2,  6,  5,  9,  10, 11, 12, 29, 30, 31, 32, 44, 43, 42, 41, 28, 27,
        26, 25, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88},
       {2,  3,  7,  6,  13, 14, 15, 16,  33,  34,  35,  36,
        48, 47, 46, 45, 32, 31, 30, 29,  89,  90,  91,  92,
        93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104},
       {3,   4,   8,   7,   17,  18,  19,  20,  37,  38,  39,  40,
        52,  51,  50,  49,  36,  35,  34,  33,  105, 106, 107, 108,
        109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120},
       {1,   5,   8,   4,   25,  26,  27,  28,  56,  55,  54,  53,
        40,  39,  38,  37,  21,  22,  23,  24,  124, 125, 126, 127,
        128, 129, 130, 131, 132, 121, 122, 123, 134, 135, 136, 133},
       {5,   6,   7,   8,   41,  42,  43,  44,  45,  46,  47,  48,  49,
        50,  51,  52,  53,  54,  55,  56,  137, 138, 139, 140, 141, 142,
        143, 144, 145, 146, 147, 148, 149, 150, 151, 152}}, // SFE_HEXA_FEK_216();
      {{}},                                                 // 246();
      {{}},                                                 // 247();
      {{1,  4,  3,  2,  28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16,
        15, 14, 13, 12, 11, 10, 9,  69, 84, 83, 82, 81, 80, 79, 78, 77, 76,
        75, 74, 73, 72, 71, 70, 85, 92, 91, 90, 89, 88, 87, 86, 93},
       {1,   2,   6,   5,   9,   10,  11,  12,  13,  34,  35,  36,  37,
        38,  53,  52,  51,  50,  49,  33,  32,  31,  30,  29,  94,  95,
        96,  97,  98,  99,  100, 101, 102, 103, 104, 105, 106, 107, 108,
        109, 110, 111, 112, 113, 114, 115, 116, 117, 118},
       {2,   3,   7,   6,   14,  15,  16,  17,  18,  39,  40,  41,  42,
        43,  58,  57,  56,  55,  54,  38,  37,  36,  35,  34,  119, 120,
        121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133,
        134, 135, 136, 137, 138, 139, 140, 141, 142, 143},
       {3,   4,   8,   7,   19,  20,  21,  22,  23,  44,  45,  46,  47,
        48,  63,  62,  61,  60,  59,  43,  42,  41,  40,  39,  144, 145,
        146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158,
        159, 160, 161, 162, 163, 164, 165, 166, 167, 168},
       {4,   1,   5,   8,   24,  25,  26,  27,  28,  29,  30,  31,  32,
        33,  68,  67,  66,  65,  64,  48,  47,  46,  45,  44,  169, 170,
        171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183,
        184, 185, 186, 187, 188, 189, 190, 191, 192, 193},
       {5,   6,   7,   8,   49,  50,  51,  52,  53,  54,  55,  56,  57,
        58,  59,  60,  61,  62,  63,  64,  65,  66,  67,  68,  194, 195,
        196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208,
        209, 210, 211, 212, 213, 214, 215, 216, 217, 218}}, // SFE_HEXA_343();
      {{1,  4,  3,  2,  28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16,
        15, 14, 13, 12, 11, 10, 9,  69, 84, 83, 82, 81, 80, 79, 78, 77, 76,
        75, 74, 73, 72, 71, 70, 85, 92, 91, 90, 89, 88, 87, 86, 93},
       {1,   2,   6,   5,   9,   10,  11,  12,  13,  34,  35,  36,  37,
        38,  53,  52,  51,  50,  49,  33,  32,  31,  30,  29,  94,  95,
        96,  97,  98,  99,  100, 101, 102, 103, 104, 105, 106, 107, 108,
        109, 110, 111, 112, 113, 114, 115, 116, 117, 118},
       {2,   3,   7,   6,   14,  15,  16,  17,  18,  39,  40,  41,  42,
        43,  58,  57,  56,  55,  54,  38,  37,  36,  35,  34,  119, 120,
        121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133,
        134, 135, 136, 137, 138, 139, 140, 141, 142, 143},
       {3,   4,   8,   7,   19,  20,  21,  22,  23,  44,  45,  46,  47,
        48,  63,  62,  61,  60,  59,  43,  42,  41,  40,  39,  144, 145,
        146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158,
        159, 160, 161, 162, 163, 164, 165, 166, 167, 168},
       {4,   1,   5,   8,   24,  25,  26,  27,  28,  29,  30,  31,  32,
        33,  68,  67,  66,  65,  64,  48,  47,  46,  45,  44,  169, 170,
        171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183,
        184, 185, 186, 187, 188, 189, 190, 191, 192, 193},
       {5,   6,   7,   8,   49,  50,  51,  52,  53,  54,  55,  56,  57,
        58,  59,  60,  61,  62,  63,  64,  65,  66,  67,  68,  194, 195,
        196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208,
        209, 210, 211, 212, 213, 214, 215, 216, 217, 218}}, // SFE_HEXA_FEK_343();
  };                                                        //();
  *ret = [&](int et, uint8_T fid) {
    return FACETS[et - 36][fid];
  }(etype, static_cast<int8_T>(facetid - 1));
  n = [&](int et, uint8_T fid) {
    int n = LIDS[et - 36][fid].size();
    while (n && LIDS[et - 36][fid][n - 1] == 0)
      --n;
    return n;
  }(etype, static_cast<int8_T>(facetid - 1));
  *lids_size = n;
  [&](int et, uint8_T fid, int n, std::int16_t *v) {
    std::copy_n(LIDS[et - 36][fid].cbegin(), n, v);
  }(etype, static_cast<int8_T>(facetid - 1), n, &lids_data[0]);
}

static void obtain_natcoords(uint8_T etype,
                             ::coder::array<real_T, 2U> &natcoords)
{
  int32_T shape;
  // obtain_natcoords - Obtain the coordinates for nodes in master elements
  //
  //    natcoords = obtain_natcoords(etype)
  //
  //  Parameter
  //  ---------
  //    etype:      integer representing the element type
  //
  //  Returns
  //  -------
  //    natcoords:  The coordinates in an n-by-d array
  // obtain_elemdim - Obtain the dimension of an element
  //
  //    dim = obtain_elemdim(etype)
  //
  //  See also obtain_elemshape
  // obtain_elemshape - Decode an element geometric shape from etype
  //
  //    shapeid = obtain_elemshape(etype)
  //
  //  RETURN
  //  ------
  //    shapeid:    Integer type of different geometry shapes:
  //                    1 - BAR
  //                    2 - TRI
  //                    3 - QUAD
  //                    4 - TET
  //                    5 - PYRAMID
  //                    6 - PRISM
  //                    7 - HEX
  //
  //  See also obtain_elemdim
  //  shapeid = (etype>>5)&0b111
  shape = static_cast<int32_T>(static_cast<uint32_T>(etype) >> 5);
  switch (((shape > 0) + (shape > 1)) + (shape > 3)) {
  case 1: {
    real_T natcoords_data[7];
    int32_T natcoords_size;
    // obtain_natcoords1d - obtain coordinates for elems in 1d in param space
    switch (etype) {
    case 36U: {
      real_T h_sfvals[2];
      // bar_2 - Compute shape functions and their derivatives of bar_2
      //
      //     ncoords = bar_2
      //     [sfvals,sdvals] = bar_2(xi)
      //
      // Parameters
      // ----------
      //     xi: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 2-by-1
      //     sdvals: vector of size 2-by-1
      ::sfe_sfuncs::bar_2_ncoords(&h_sfvals[0]);
      natcoords_size = 2;
      natcoords_data[0] = h_sfvals[0];
      natcoords_data[1] = h_sfvals[1];
    } break;
    case 40U: {
      real_T i_sfvals[3];
      // bar_3 - Compute shape functions and their derivatives of bar_3
      //
      //     ncoords = bar_3
      //     [sfvals,sdvals] = bar_3(xi)
      //
      // Parameters
      // ----------
      //     xi: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 3-by-1
      //     sdvals: vector of size 3-by-1
      ::sfe_sfuncs::bar_3_ncoords(&i_sfvals[0]);
      natcoords_size = 3;
      natcoords_data[0] = i_sfvals[0];
      natcoords_data[1] = i_sfvals[1];
      natcoords_data[2] = i_sfvals[2];
    } break;
    case 44U: {
      real_T j_sfvals[4];
      // bar_4 - Compute shape functions and their derivatives of bar_4
      //
      //     ncoords = bar_4
      //     [sfvals,sdvals] = bar_4(xi)
      //
      // Parameters
      // ----------
      //     xi: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 4-by-1
      //     sdvals: vector of size 4-by-1
      ::sfe_sfuncs::bar_4_ncoords(&j_sfvals[0]);
      natcoords_size = 4;
      natcoords_data[0] = j_sfvals[0];
      natcoords_data[1] = j_sfvals[1];
      natcoords_data[2] = j_sfvals[2];
      natcoords_data[3] = j_sfvals[3];
    } break;
    case 48U: {
      real_T k_sfvals[5];
      // bar_5 - Compute shape functions and their derivatives of bar_5
      //
      //     ncoords = bar_5
      //     [sfvals,sdvals] = bar_5(xi)
      //
      // Parameters
      // ----------
      //     xi: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 5-by-1
      //     sdvals: vector of size 5-by-1
      ::sfe_sfuncs::bar_5_ncoords(&k_sfvals[0]);
      natcoords_size = 5;
      for (int32_T i{0}; i < 5; i++) {
        natcoords_data[i] = k_sfvals[i];
      }
    } break;
    case 52U: {
      real_T l_sfvals[6];
      // bar_6 - Compute shape functions and their derivatives of bar_6
      //
      //     ncoords = bar_6
      //     [sfvals,sdvals] = bar_6(xi)
      //
      // Parameters
      // ----------
      //     xi: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 6-by-1
      //     sdvals: vector of size 6-by-1
      ::sfe_sfuncs::bar_6_ncoords(&l_sfvals[0]);
      natcoords_size = 6;
      for (int32_T i{0}; i < 6; i++) {
        natcoords_data[i] = l_sfvals[i];
      }
    } break;
    case 56U: {
      real_T g_sfvals[7];
      // bar_7 - Compute shape functions and their derivatives of bar_7
      //
      //     ncoords = bar_7
      //     [sfvals,sdvals] = bar_7(xi)
      //
      // Parameters
      // ----------
      //     xi: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 7-by-1
      //     sdvals: vector of size 7-by-1
      ::sfe_sfuncs::bar_7_ncoords(&g_sfvals[0]);
      natcoords_size = 7;
      for (int32_T i{0}; i < 7; i++) {
        natcoords_data[i] = g_sfvals[i];
      }
    } break;
    case 45U: {
      real_T j_sfvals[4];
      // bar_gl_4 - Compute shape functions and their derivatives of bar_gl_4
      //
      //     ncoords = bar_gl_4
      //     [sfvals,sdvals] = bar_gl_4(xi)
      //
      // Parameters
      // ----------
      //     xi: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 4-by-1
      //     sdvals: vector of size 4-by-1
      ::sfe_sfuncs::bar_gl_4_ncoords(&j_sfvals[0]);
      natcoords_size = 4;
      natcoords_data[0] = j_sfvals[0];
      natcoords_data[1] = j_sfvals[1];
      natcoords_data[2] = j_sfvals[2];
      natcoords_data[3] = j_sfvals[3];
    } break;
    case 49U: {
      real_T k_sfvals[5];
      // bar_gl_5 - Compute shape functions and their derivatives of bar_gl_5
      //
      //     ncoords = bar_gl_5
      //     [sfvals,sdvals] = bar_gl_5(xi)
      //
      // Parameters
      // ----------
      //     xi: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 5-by-1
      //     sdvals: vector of size 5-by-1
      ::sfe_sfuncs::bar_gl_5_ncoords(&k_sfvals[0]);
      natcoords_size = 5;
      for (int32_T i{0}; i < 5; i++) {
        natcoords_data[i] = k_sfvals[i];
      }
    } break;
    case 53U: {
      real_T l_sfvals[6];
      // bar_gl_6 - Compute shape functions and their derivatives of bar_gl_6
      //
      //     ncoords = bar_gl_6
      //     [sfvals,sdvals] = bar_gl_6(xi)
      //
      // Parameters
      // ----------
      //     xi: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 6-by-1
      //     sdvals: vector of size 6-by-1
      ::sfe_sfuncs::bar_gl_6_ncoords(&l_sfvals[0]);
      natcoords_size = 6;
      for (int32_T i{0}; i < 6; i++) {
        natcoords_data[i] = l_sfvals[i];
      }
    } break;
    default: {
      real_T g_sfvals[7];
      // bar_gl_7 - Compute shape functions and their derivatives of bar_gl_7
      //
      //     ncoords = bar_gl_7
      //     [sfvals,sdvals] = bar_gl_7(xi)
      //
      // Parameters
      // ----------
      //     xi: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 7-by-1
      //     sdvals: vector of size 7-by-1
      ::sfe_sfuncs::bar_gl_7_ncoords(&g_sfvals[0]);
      natcoords_size = 7;
      for (int32_T i{0}; i < 7; i++) {
        natcoords_data[i] = g_sfvals[i];
      }
    } break;
    }
    natcoords.set_size(natcoords_size, 1);
    for (int32_T i{0}; i < natcoords_size; i++) {
      natcoords[i] = natcoords_data[i];
    }
  } break;
  case 2: {
    // obtain_natcoords2d - obtain coordinates for elems in 2d in param space
    switch (etype) {
    case 68U: {
      real_T l_sfvals[6];
      natcoords.set_size(3, 2);
      // tri_3 - Compute shape functions and their derivatives of tri_3
      //
      //     ncoords = tri_3
      //     [sfvals,sdvals] = tri_3(xi,eta)
      //
      // Parameters
      // ----------
      //     xi,eta: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 3-by-1
      //     sdvals: vector of size 3-by-2
      ::sfe_sfuncs::tri_3_ncoords(&l_sfvals[0]);
      for (int32_T i{0}; i < 3; i++) {
        int32_T natcoords_size;
        natcoords_size = i << 1;
        natcoords[2 * i] = l_sfvals[natcoords_size];
        natcoords[2 * i + 1] = l_sfvals[natcoords_size + 1];
      }
    } break;
    case 72U: {
      real_T m_sfvals[12];
      natcoords.set_size(6, 2);
      // tri_6 - Compute shape functions and their derivatives of tri_6
      //
      //     ncoords = tri_6
      //     [sfvals,sdvals] = tri_6(xi,eta)
      //
      // Parameters
      // ----------
      //     xi,eta: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 6-by-1
      //     sdvals: vector of size 6-by-2
      ::sfe_sfuncs::tri_6_ncoords(&m_sfvals[0]);
      for (int32_T i{0}; i < 6; i++) {
        int32_T natcoords_size;
        natcoords_size = i << 1;
        natcoords[2 * i] = m_sfvals[natcoords_size];
        natcoords[2 * i + 1] = m_sfvals[natcoords_size + 1];
      }
    } break;
    case 76U: {
      real_T n_sfvals[20];
      natcoords.set_size(10, 2);
      // tri_10 - Compute shape functions and their derivatives of tri_10
      //
      //     ncoords = tri_10
      //     [sfvals,sdvals] = tri_10(xi,eta)
      //
      // Parameters
      // ----------
      //     xi,eta: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 10-by-1
      //     sdvals: vector of size 10-by-2
      ::sfe_sfuncs::tri_10_ncoords(&n_sfvals[0]);
      for (int32_T i{0}; i < 10; i++) {
        int32_T natcoords_size;
        natcoords_size = i << 1;
        natcoords[2 * i] = n_sfvals[natcoords_size];
        natcoords[2 * i + 1] = n_sfvals[natcoords_size + 1];
      }
    } break;
    case 77U: {
      real_T n_sfvals[20];
      natcoords.set_size(10, 2);
      // tri_gl_10 - Compute shape functions and their derivatives of tri_gl_10
      //
      //     ncoords = tri_gl_10
      //     [sfvals,sdvals] = tri_gl_10(xi,eta)
      //
      // Parameters
      // ----------
      //     xi,eta: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 10-by-1
      //     sdvals: vector of size 10-by-2
      ::sfe_sfuncs::tri_gl_10_ncoords(&n_sfvals[0]);
      for (int32_T i{0}; i < 10; i++) {
        int32_T natcoords_size;
        natcoords_size = i << 1;
        natcoords[2 * i] = n_sfvals[natcoords_size];
        natcoords[2 * i + 1] = n_sfvals[natcoords_size + 1];
      }
    } break;
    case 80U: {
      real_T o_sfvals[30];
      natcoords.set_size(15, 2);
      // tri_15 - Compute shape functions and their derivatives of tri_15
      //
      //     ncoords = tri_15
      //     [sfvals,sdvals] = tri_15(xi,eta)
      //
      // Parameters
      // ----------
      //     xi,eta: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 15-by-1
      //     sdvals: vector of size 15-by-2
      ::sfe_sfuncs::tri_15_ncoords(&o_sfvals[0]);
      for (int32_T i{0}; i < 15; i++) {
        int32_T natcoords_size;
        natcoords_size = i << 1;
        natcoords[2 * i] = o_sfvals[natcoords_size];
        natcoords[2 * i + 1] = o_sfvals[natcoords_size + 1];
      }
    } break;
    case 81U: {
      real_T o_sfvals[30];
      natcoords.set_size(15, 2);
      // tri_gl_15 - Compute shape functions and their derivatives of tri_gl_15
      //
      //     ncoords = tri_gl_15
      //     [sfvals,sdvals] = tri_gl_15(xi,eta)
      //
      // Parameters
      // ----------
      //     xi,eta: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 15-by-1
      //     sdvals: vector of size 15-by-2
      ::sfe_sfuncs::tri_gl_15_ncoords(&o_sfvals[0]);
      for (int32_T i{0}; i < 15; i++) {
        int32_T natcoords_size;
        natcoords_size = i << 1;
        natcoords[2 * i] = o_sfvals[natcoords_size];
        natcoords[2 * i + 1] = o_sfvals[natcoords_size + 1];
      }
    } break;
    case 84U: {
      real_T p_sfvals[42];
      natcoords.set_size(21, 2);
      // tri_21 - Compute shape functions and their derivatives of tri_21
      //
      //     ncoords = tri_21
      //     [sfvals,sdvals] = tri_21(xi,eta)
      //
      // Parameters
      // ----------
      //     xi,eta: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 21-by-1
      //     sdvals: vector of size 21-by-2
      ::sfe_sfuncs::tri_21_ncoords(&p_sfvals[0]);
      for (int32_T i{0}; i < 21; i++) {
        int32_T natcoords_size;
        natcoords_size = i << 1;
        natcoords[2 * i] = p_sfvals[natcoords_size];
        natcoords[2 * i + 1] = p_sfvals[natcoords_size + 1];
      }
    } break;
    case 85U: {
      real_T p_sfvals[42];
      natcoords.set_size(21, 2);
      // tri_gl_21 - Compute shape functions and their derivatives of tri_gl_21
      //
      //     ncoords = tri_gl_21
      //     [sfvals,sdvals] = tri_gl_21(xi,eta)
      //
      // Parameters
      // ----------
      //     xi,eta: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 21-by-1
      //     sdvals: vector of size 21-by-2
      ::sfe_sfuncs::tri_gl_21_ncoords(&p_sfvals[0]);
      for (int32_T i{0}; i < 21; i++) {
        int32_T natcoords_size;
        natcoords_size = i << 1;
        natcoords[2 * i] = p_sfvals[natcoords_size];
        natcoords[2 * i + 1] = p_sfvals[natcoords_size + 1];
      }
    } break;
    case 88U: {
      real_T q_sfvals[56];
      natcoords.set_size(28, 2);
      // tri_28 - Compute shape functions and their derivatives of tri_28
      //
      //     ncoords = tri_28
      //     [sfvals,sdvals] = tri_28(xi,eta)
      //
      // Parameters
      // ----------
      //     xi,eta: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 28-by-1
      //     sdvals: vector of size 28-by-2
      ::sfe_sfuncs::tri_28_ncoords(&q_sfvals[0]);
      for (int32_T i{0}; i < 28; i++) {
        int32_T natcoords_size;
        natcoords_size = i << 1;
        natcoords[2 * i] = q_sfvals[natcoords_size];
        natcoords[2 * i + 1] = q_sfvals[natcoords_size + 1];
      }
    } break;
    case 100U: {
      real_T b_sfvals[8];
      natcoords.set_size(4, 2);
      // quad_4 - Bilinear quadrilateral element
      //     [sfvals,sdvals] = quad_4(xi,eta)
      //
      //   Input:
      //      xi, eta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 4-by-1
      //      sdvals: vector of size 4-by-2
      //
      //     nodes_nat_coors = quad_4
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also quad_9, quad_16, quad_gl_16, quad_25, quad_gl_25
      ::sfe_sfuncs::quad_4_ncoords(&b_sfvals[0]);
      for (int32_T i{0}; i < 4; i++) {
        int32_T natcoords_size;
        natcoords_size = i << 1;
        natcoords[2 * i] = b_sfvals[natcoords_size];
        natcoords[2 * i + 1] = b_sfvals[natcoords_size + 1];
      }
    } break;
    case 104U: {
      real_T c_sfvals[18];
      natcoords.set_size(9, 2);
      // quad_9 - Bilinear quadrilateral element
      //     [sfvals,sdvals] = quad_9(xi,eta)
      //
      //   Input:
      //      xi, eta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 9-by-1
      //      sdvals: vector of size 9-by-2
      //
      //     nodes_nat_coors = quad_9
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also quad_4, quad_16, quad_gl_16, quad_25, quad_gl_25
      ::sfe_sfuncs::quad_9_ncoords(&c_sfvals[0]);
      for (int32_T i{0}; i < 9; i++) {
        int32_T natcoords_size;
        natcoords_size = i << 1;
        natcoords[2 * i] = c_sfvals[natcoords_size];
        natcoords[2 * i + 1] = c_sfvals[natcoords_size + 1];
      }
    } break;
    case 108U: {
      real_T d_sfvals[32];
      natcoords.set_size(16, 2);
      // quad_16 - Bicubic quadrilateral element with equidistant points
      //     [sfvals,sdvals] = quad_16(xi,eta)
      //
      //   Input:
      //      xi, eta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 16-by-1
      //      sdvals: vector of size 16-by-2
      //
      //     nodes_nat_coors = quad_16
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also quad_4, quad_9, quad_gl_16, quad_25, quad_gl_25
      ::sfe_sfuncs::quad_16_ncoords(&d_sfvals[0]);
      for (int32_T i{0}; i < 16; i++) {
        int32_T natcoords_size;
        natcoords_size = i << 1;
        natcoords[2 * i] = d_sfvals[natcoords_size];
        natcoords[2 * i + 1] = d_sfvals[natcoords_size + 1];
      }
    } break;
    case 109U: {
      real_T d_sfvals[32];
      natcoords.set_size(16, 2);
      // quad_gl_16 - Bicubic quadrilateral element with Gauss-Lobatto points
      //     [sfvals,sdvals] = quad_gl_16(xi,eta)
      //
      //   Input:
      //      xi, eta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 16-by-1
      //      sdvals: vector of size 16-by-2
      //
      //     NAT_COORS = quad_gl_16
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also quad_4, quad_9, quad_16, quad_25, quad_gl_25
      ::sfe_sfuncs::quad_gl_16_ncoords(&d_sfvals[0]);
      for (int32_T i{0}; i < 16; i++) {
        int32_T natcoords_size;
        natcoords_size = i << 1;
        natcoords[2 * i] = d_sfvals[natcoords_size];
        natcoords[2 * i + 1] = d_sfvals[natcoords_size + 1];
      }
    } break;
    case 112U: {
      real_T e_sfvals[50];
      natcoords.set_size(25, 2);
      // quad_25 - Biquartic quadrilateral element with equidistant points
      //     [sfvals,sdvals] = quad_25(xi,eta)
      //
      //   Input:
      //      xi, eta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 25-by-1
      //      sdvals: vector of size 25-by-2
      //
      //     nodes_nat_coors = quad_25
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also quad_4, quad_9, quad_16, quad_gl_16, quad_gl_25
      ::sfe_sfuncs::quad_25_ncoords(&e_sfvals[0]);
      for (int32_T i{0}; i < 25; i++) {
        int32_T natcoords_size;
        natcoords_size = i << 1;
        natcoords[2 * i] = e_sfvals[natcoords_size];
        natcoords[2 * i + 1] = e_sfvals[natcoords_size + 1];
      }
    } break;
    case 113U: {
      real_T e_sfvals[50];
      natcoords.set_size(25, 2);
      // quad_gl_25 - Biquartic quadrilateral element with Gauss-Lobatto points
      //     [sfvals,sdvals] = quad_gl_25(xi,eta)
      //
      //   Input:
      //      xi, eta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 25-by-1
      //      sdvals: vector of size 25-by-2
      //
      //     nodes_nat_coors = quad_gl_25
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also quad_4, quad_9, quad_16, quad_gl_16, quad_25
      ::sfe_sfuncs::quad_gl_25_ncoords(&e_sfvals[0]);
      for (int32_T i{0}; i < 25; i++) {
        int32_T natcoords_size;
        natcoords_size = i << 1;
        natcoords[2 * i] = e_sfvals[natcoords_size];
        natcoords[2 * i + 1] = e_sfvals[natcoords_size + 1];
      }
    } break;
    case 116U: {
      real_T f_sfvals[72];
      natcoords.set_size(36, 2);
      // quad_36   Biquintic quadrilateral element with equidistant points
      //     [sfvals,sdvals] = quad_36(xi,eta)
      //
      //   Input:
      //      xi, eta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 25-by-1
      //      sdvals: vector of size 25-by-2
      //
      //     nodes_nat_coors = quad_36
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also quad_4, quad_9, quad_16, quad_gl_16, quad_gl_25
      ::sfe_sfuncs::quad_36_ncoords(&f_sfvals[0]);
      for (int32_T i{0}; i < 36; i++) {
        int32_T natcoords_size;
        natcoords_size = i << 1;
        natcoords[2 * i] = f_sfvals[natcoords_size];
        natcoords[2 * i + 1] = f_sfvals[natcoords_size + 1];
      }
    } break;
    case 117U: {
      real_T f_sfvals[72];
      natcoords.set_size(36, 2);
      // quad_gl_36 - Biquintic quadrilateral element with equidistant points
      //     [sfvals,sdvals] = quad_gl_36(xi,eta)
      //
      //   Input:
      //      xi, eta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 36-by-1
      //      sdvals: vector of size 36-by-2
      //
      //     nodes_nat_coors = quad_gl_36
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also quad_4, quad_9, quad_16, quad_gl_16, quad_gl_25
      ::sfe_sfuncs::quad_gl_36_ncoords(&f_sfvals[0]);
      for (int32_T i{0}; i < 36; i++) {
        int32_T natcoords_size;
        natcoords_size = i << 1;
        natcoords[2 * i] = f_sfvals[natcoords_size];
        natcoords[2 * i + 1] = f_sfvals[natcoords_size + 1];
      }
    } break;
    case 120U: {
      real_T sfvals[98];
      natcoords.set_size(49, 2);
      // quad_49 - Bisextic quadrilateral element with equidistant points
      //     [sfvals,sdvals] = quad_49(xi,eta)
      //
      //   Input:
      //      xi, eta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 25-by-1
      //      sdvals: vector of size 25-by-2
      //
      //     nodes_nat_coors = quad_49
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also quad_4, quad_9, quad_16, quad_gl_16, quad_gl_25
      ::sfe_sfuncs::quad_49_ncoords(&sfvals[0]);
      for (int32_T i{0}; i < 49; i++) {
        int32_T natcoords_size;
        natcoords_size = i << 1;
        natcoords[2 * i] = sfvals[natcoords_size];
        natcoords[2 * i + 1] = sfvals[natcoords_size + 1];
      }
    } break;
    default: {
      real_T sfvals[98];
      natcoords.set_size(49, 2);
      // quad_gl_49 - Bisextic quadrilateral element with equidistant points
      //     [sfvals,sdvals] = quad_gl_49(xi,eta)
      //
      //   Input:
      //      xi, eta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 49-by-1
      //      sdvals: vector of size 49-by-2
      //
      //     nodes_nat_coors = quad_gl_49
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also quad_4, quad_9, quad_16, quad_gl_16, quad_gl_25
      ::sfe_sfuncs::quad_gl_49_ncoords(&sfvals[0]);
      for (int32_T i{0}; i < 49; i++) {
        int32_T natcoords_size;
        natcoords_size = i << 1;
        natcoords[2 * i] = sfvals[natcoords_size];
        natcoords[2 * i + 1] = sfvals[natcoords_size + 1];
      }
    } break;
    }
  } break;
  default: {
    // obtain_elemdim - Obtain the dimension of an element
    //
    //    dim = obtain_elemdim(etype)
    //
    //  See also obtain_elemshape
    // obtain_elemshape - Decode an element geometric shape from etype
    //
    //    shapeid = obtain_elemshape(etype)
    //
    //  RETURN
    //  ------
    //    shapeid:    Integer type of different geometry shapes:
    //                    1 - BAR
    //                    2 - TRI
    //                    3 - QUAD
    //                    4 - TET
    //                    5 - PYRAMID
    //                    6 - PRISM
    //                    7 - HEX
    //
    //  See also obtain_elemdim
    //  shapeid = (etype>>5)&0b111
    // obtain_natcoords3d - obtain coordinates for elems in 3d in param space
    switch (etype) {
    case 132U: {
      real_T m_sfvals[12];
      natcoords.set_size(4, 3);
      // tet_4 - Compute shape functions and their derivatives of tet_4
      //
      //     ncoords = tet_4
      //     [sfvals,sdvals] = tet_4(xi,eta,zeta)
      //
      // Parameters
      // ----------
      //     xi,eta,zeta: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 4-by-1
      //     sdvals: vector of size 4-by-3
      ::sfe_sfuncs::tet_4_ncoords(&m_sfvals[0]);
      for (int32_T i{0}; i < 4; i++) {
        natcoords[3 * i] = m_sfvals[3 * i];
        natcoords[3 * i + 1] = m_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = m_sfvals[3 * i + 2];
      }
    } break;
    case 136U: {
      real_T o_sfvals[30];
      natcoords.set_size(10, 3);
      // tet_10 - Compute shape functions and their derivatives of tet_10
      //
      //     ncoords = tet_10
      //     [sfvals,sdvals] = tet_10(xi,eta,zeta)
      //
      // Parameters
      // ----------
      //     xi,eta,zeta: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 10-by-1
      //     sdvals: vector of size 10-by-3
      ::sfe_sfuncs::tet_10_ncoords(&o_sfvals[0]);
      for (int32_T i{0}; i < 10; i++) {
        natcoords[3 * i] = o_sfvals[3 * i];
        natcoords[3 * i + 1] = o_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = o_sfvals[3 * i + 2];
      }
    } break;
    case 140U: {
      real_T db_sfvals[60];
      natcoords.set_size(20, 3);
      // tet_20 - Compute shape functions and their derivatives of tet_20
      //
      //     ncoords = tet_20
      //     [sfvals,sdvals] = tet_20(xi,eta,zeta)
      //
      // Parameters
      // ----------
      //     xi,eta,zeta: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 20-by-1
      //     sdvals: vector of size 20-by-3
      ::sfe_sfuncs::tet_20_ncoords(&db_sfvals[0]);
      for (int32_T i{0}; i < 20; i++) {
        natcoords[3 * i] = db_sfvals[3 * i];
        natcoords[3 * i + 1] = db_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = db_sfvals[3 * i + 2];
      }
    } break;
    case 141U: {
      real_T db_sfvals[60];
      natcoords.set_size(20, 3);
      // tet_gl_20 - Compute shape functions and their derivatives of tet_gl_20
      //
      //     ncoords = tet_gl_20
      //     [sfvals,sdvals] = tet_gl_20(xi,eta,zeta)
      //
      // Parameters
      // ----------
      //     xi,eta,zeta: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 20-by-1
      //     sdvals: vector of size 20-by-3
      ::sfe_sfuncs::tet_gl_20_ncoords(&db_sfvals[0]);
      for (int32_T i{0}; i < 20; i++) {
        natcoords[3 * i] = db_sfvals[3 * i];
        natcoords[3 * i + 1] = db_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = db_sfvals[3 * i + 2];
      }
    } break;
    case 144U: {
      real_T eb_sfvals[105];
      natcoords.set_size(35, 3);
      // tet_35 - Compute shape functions and their derivatives of tet_35
      //
      //     ncoords = tet_35
      //     [sfvals,sdvals] = tet_35(xi,eta,zeta)
      //
      // Parameters
      // ----------
      //     xi,eta,zeta: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 35-by-1
      //     sdvals: vector of size 35-by-3
      ::sfe_sfuncs::tet_35_ncoords(&eb_sfvals[0]);
      for (int32_T i{0}; i < 35; i++) {
        natcoords[3 * i] = eb_sfvals[3 * i];
        natcoords[3 * i + 1] = eb_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = eb_sfvals[3 * i + 2];
      }
    } break;
    case 145U: {
      real_T eb_sfvals[105];
      natcoords.set_size(35, 3);
      // tet_gl_35 - Compute shape functions and their derivatives of tet_gl_35
      //
      //     ncoords = tet_gl_35
      //     [sfvals,sdvals] = tet_gl_35(xi,eta,zeta)
      //
      // Parameters
      // ----------
      //     xi,eta,zeta: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 35-by-1
      //     sdvals: vector of size 35-by-3
      ::sfe_sfuncs::tet_gl_35_ncoords(&eb_sfvals[0]);
      for (int32_T i{0}; i < 35; i++) {
        natcoords[3 * i] = eb_sfvals[3 * i];
        natcoords[3 * i + 1] = eb_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = eb_sfvals[3 * i + 2];
      }
    } break;
    case 148U: {
      real_T fb_sfvals[168];
      natcoords.set_size(56, 3);
      // tet_56 - Compute shape functions and their derivatives of tet_56
      //
      //     ncoords = tet_56
      //     [sfvals,sdvals] = tet_56(xi,eta,zeta)
      //
      // Parameters
      // ----------
      //     xi,eta,zeta: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 56-by-1
      //     sdvals: vector of size 56-by-3
      ::sfe_sfuncs::tet_56_ncoords(&fb_sfvals[0]);
      for (int32_T i{0}; i < 56; i++) {
        natcoords[3 * i] = fb_sfvals[3 * i];
        natcoords[3 * i + 1] = fb_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = fb_sfvals[3 * i + 2];
      }
    } break;
    case 152U: {
      real_T gb_sfvals[252];
      natcoords.set_size(84, 3);
      // tet_84 - Compute shape functions and their derivatives of tet_84
      //
      //     ncoords = tet_84
      //     [sfvals,sdvals] = tet_84(xi,eta,zeta,varargin)
      //
      // Parameters
      // ----------
      //     xi,eta,zeta,varargin: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 84-by-1
      //     sdvals: vector of size 84-by-3
      ::sfe_sfuncs::tet_84_ncoords(&gb_sfvals[0]);
      for (int32_T i{0}; i < 84; i++) {
        natcoords[3 * i] = gb_sfvals[3 * i];
        natcoords[3 * i + 1] = gb_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = gb_sfvals[3 * i + 2];
      }
    } break;
    case 164U: {
      real_T hb_sfvals[15];
      natcoords.set_size(5, 3);
      // pyra_5 - Compute shape functions and their derivatives of pyra_5
      //
      //     ncoords = pyra_5
      //     [sfvals,sdvals] = pyra_5(xi,eta,zeta)
      //
      // Parameters
      // ----------
      //     xi,eta: natural coordinates ranging between -1 and 1
      //     zeta: natural coordinate ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 5-by-1
      //     sdvals: vector of size 5-by-3
      // Note
      // ----
      //  The shape functions are based on Bedrosian rational basis functions.
      ::sfe_sfuncs::pyra_5_ncoords(&hb_sfvals[0]);
      for (int32_T i{0}; i < 5; i++) {
        natcoords[3 * i] = hb_sfvals[3 * i];
        natcoords[3 * i + 1] = hb_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = hb_sfvals[3 * i + 2];
      }
    } break;
    case 168U: {
      real_T p_sfvals[42];
      natcoords.set_size(14, 3);
      // pyra_14 - Compute shape functions and their derivatives of pyra_14
      //
      //     ncoords = pyra_14
      //     [sfvals,sdvals] = pyra_14(xi,eta,zeta)
      //
      // Parameters
      // ----------
      //     xi,eta: natural coordinates ranging between -1 and 1
      //     zeta: natural coordinate ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 14-by-1
      //     sdvals: vector of size 14-by-3
      // Note
      // ----
      //  The shape functions are based on Bedrosian rational basis functions.
      ::sfe_sfuncs::pyra_14_ncoords(&p_sfvals[0]);
      for (int32_T i{0}; i < 14; i++) {
        natcoords[3 * i] = p_sfvals[3 * i];
        natcoords[3 * i + 1] = p_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = p_sfvals[3 * i + 2];
      }
    } break;
    case 172U: {
      real_T ib_sfvals[90];
      natcoords.set_size(30, 3);
      // pyra_30 - Compute shape functions and their derivatives of pyra_30
      //
      //     ncoords = pyra_30
      //     [sfvals,sdvals] = pyra_30(xi,eta,zeta)
      //
      // Parameters
      // ----------
      //     xi,eta: natural coordinates ranging between -1 and 1
      //     zeta: natural coordinate ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 30-by-1
      //     sdvals: vector of size 30-by-3
      // Note
      // ----
      //  The shape functions are based on Bedrosian rational basis functions.
      ::sfe_sfuncs::pyra_30_ncoords(&ib_sfvals[0]);
      for (int32_T i{0}; i < 30; i++) {
        natcoords[3 * i] = ib_sfvals[3 * i];
        natcoords[3 * i + 1] = ib_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = ib_sfvals[3 * i + 2];
      }
    } break;
    case 173U: {
      real_T ib_sfvals[90];
      natcoords.set_size(30, 3);
      // pyra_gl_30 - Compute shape functions and their derivatives of
      // pyra_gl_30
      //
      //     ncoords = pyra_gl_30
      //     [sfvals,sdvals] = pyra_gl_30(xi,eta,zeta)
      //
      // Parameters
      // ----------
      //     xi,eta: natural coordinates ranging between -1 and 1
      //     zeta: natural coordinate ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 30-by-1
      //     sdvals: vector of size 30-by-3
      // Note
      // ----
      //  The shape functions are based on Bedrosian rational basis functions.
      ::sfe_sfuncs::pyra_gl_30_ncoords(&ib_sfvals[0]);
      for (int32_T i{0}; i < 30; i++) {
        natcoords[3 * i] = ib_sfvals[3 * i];
        natcoords[3 * i + 1] = ib_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = ib_sfvals[3 * i + 2];
      }
    } break;
    case 176U: {
      real_T jb_sfvals[165];
      natcoords.set_size(55, 3);
      // pyra_55 - Compute shape functions and their derivatives of pyra_55
      //
      //     ncoords = pyra_55
      //     [sfvals,sdvals] = pyra_55(xi,eta,zeta)
      //
      // Parameters
      // ----------
      //     xi,eta: natural coordinates ranging between -1 and 1
      //     zeta: natural coordinate ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 55-by-1
      //     sdvals: vector of size 55-by-3
      // Note
      // ----
      //  The shape functions are based on Bedrosian rational basis functions.
      ::sfe_sfuncs::pyra_55_ncoords(&jb_sfvals[0]);
      for (int32_T i{0}; i < 55; i++) {
        natcoords[3 * i] = jb_sfvals[3 * i];
        natcoords[3 * i + 1] = jb_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = jb_sfvals[3 * i + 2];
      }
    } break;
    case 177U: {
      real_T jb_sfvals[165];
      natcoords.set_size(55, 3);
      // pyra_gl_55 - Compute shape functions and their derivatives of
      // pyra_gl_55
      //
      //     ncoords = pyra_gl_55
      //     [sfvals,sdvals] = pyra_gl_55(xi,eta,zeta)
      //
      // Parameters
      // ----------
      //     xi,eta: natural coordinates ranging between -1 and 1
      //     zeta: natural coordinate ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 55-by-1
      //     sdvals: vector of size 55-by-3
      // Note
      // ----
      //  The shape functions are based on Bedrosian rational basis functions.
      ::sfe_sfuncs::pyra_gl_55_ncoords(&jb_sfvals[0]);
      for (int32_T i{0}; i < 55; i++) {
        natcoords[3 * i] = jb_sfvals[3 * i];
        natcoords[3 * i + 1] = jb_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = jb_sfvals[3 * i + 2];
      }
    } break;
    case 180U: {
      real_T kb_sfvals[273];
      natcoords.set_size(91, 3);
      // pyra_91 - Compute shape functions and their derivatives of pyra_91
      //
      //     ncoords = pyra_91
      //     [sfvals,sdvals] = pyra_91(xi,eta,zeta)
      //
      // Parameters
      // ----------
      //     xi,eta: natural coordinates ranging between -1 and 1
      //     zeta: natural coordinate ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 91-by-1
      //     sdvals: vector of size 91-by-3
      // Note
      // ----
      //  The shape functions are based on Bedrosian rational basis functions.
      ::sfe_sfuncs::pyra_91_ncoords(&kb_sfvals[0]);
      for (int32_T i{0}; i < 91; i++) {
        natcoords[3 * i] = kb_sfvals[3 * i];
        natcoords[3 * i + 1] = kb_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = kb_sfvals[3 * i + 2];
      }
    } break;
    case 196U: {
      real_T c_sfvals[18];
      natcoords.set_size(6, 3);
      // prism_6 - Linear prismatic element
      //     [sfvals,sdvals] = prism_6(xi,eta,zeta)
      //
      //   Input:
      //      xi, eta, zeta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 6-by-1
      //      sdvals: vector of size 6-by-3
      //
      //     nodes_nat_coors = prism_6
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also prism_18, prism_40, prism_gl_40, prism_75, prism_gl_75
      ::sfe_sfuncs::prism_6_ncoords(&c_sfvals[0]);
      for (int32_T i{0}; i < 6; i++) {
        natcoords[3 * i] = c_sfvals[3 * i];
        natcoords[3 * i + 1] = c_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = c_sfvals[3 * i + 2];
      }
    } break;
    case 200U: {
      real_T r_sfvals[54];
      natcoords.set_size(18, 3);
      // prism_18 - Quadratic prismatic element
      //     [sfvals,sdvals] = prism_18(xi,eta,zeta)
      //
      //   Input:
      //      xi, eta, zeta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 18-by-1
      //      sdvals: vector of size 18-by-3
      //
      //     nodes_nat_coors = prism_18
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also prism_6, prism_40, prism_gl_40, prism_75, prism_gl_75
      ::sfe_sfuncs::prism_18_ncoords(&r_sfvals[0]);
      for (int32_T i{0}; i < 18; i++) {
        natcoords[3 * i] = r_sfvals[3 * i];
        natcoords[3 * i + 1] = r_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = r_sfvals[3 * i + 2];
      }
    } break;
    case 204U: {
      real_T s_sfvals[120];
      natcoords.set_size(40, 3);
      // prism_40 - Cubic prismatic element
      //     [sfvals,sdvals] = prism_40(xi,eta,zeta)
      //
      //   Input:
      //      xi, eta, zeta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 40-by-1
      //      sdvals: vector of size 40-by-3
      //
      //     nodes_nat_coors = prism_40
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also prism_6, prism_18, prism_gl_40, prism_75, prism_gl_75
      ::sfe_sfuncs::prism_40_ncoords(&s_sfvals[0]);
      for (int32_T i{0}; i < 40; i++) {
        natcoords[3 * i] = s_sfvals[3 * i];
        natcoords[3 * i + 1] = s_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = s_sfvals[3 * i + 2];
      }
    } break;
    case 205U: {
      real_T s_sfvals[120];
      natcoords.set_size(40, 3);
      // prism_gl_40 - Quadratic prismatic element with Gauss-Lobatto nodes
      //     [sfvals,sdvals] = prism_gl_40(xi,eta,zeta)
      //
      //   Input:
      //      xi, eta, zeta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 40-by-1
      //      sdvals: vector of size 40-by-3
      //
      //     nodes_nat_coors = prism_40
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also prism_6, prism_18, prism_gl_40, prism_75, prism_gl_75
      ::sfe_sfuncs::prism_gl_40_ncoords(&s_sfvals[0]);
      for (int32_T i{0}; i < 40; i++) {
        natcoords[3 * i] = s_sfvals[3 * i];
        natcoords[3 * i + 1] = s_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = s_sfvals[3 * i + 2];
      }
    } break;
    case 208U: {
      real_T t_sfvals[225];
      natcoords.set_size(75, 3);
      // prism_75 - Quartic prismatic element with equidistant nodes
      //     [sfvals,sdvals] = prism_75(xi,eta,zeta)
      //
      //   Input:
      //      xi, eta, zeta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 75-by-1
      //      sdvals: vector of size 75-by-3
      //
      //     nodes_nat_coors = prism_75
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also prism_6, prism_18, prism_40, prism_gl_40, prism_gl_75
      ::sfe_sfuncs::prism_75_ncoords(&t_sfvals[0]);
      for (int32_T i{0}; i < 75; i++) {
        natcoords[3 * i] = t_sfvals[3 * i];
        natcoords[3 * i + 1] = t_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = t_sfvals[3 * i + 2];
      }
    } break;
    case 209U: {
      real_T t_sfvals[225];
      natcoords.set_size(75, 3);
      // prism_gl_75 - Quartic prismatic element with Gauss-Lobatto nodes
      //     [sfvals,sdvals] = prism_gl_75(xi,eta,zeta)
      //
      //   Input:
      //      xi, eta, zeta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 75-by-1
      //      sdvals: vector of size 75-by-3
      //
      //     nodes_nat_coors = prism_fek_75
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also prism_6, prism_18, prism_40, prism_gl_40, prism_75
      ::sfe_sfuncs::prism_gl_75_ncoords(&t_sfvals[0]);
      for (int32_T i{0}; i < 75; i++) {
        natcoords[3 * i] = t_sfvals[3 * i];
        natcoords[3 * i + 1] = t_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = t_sfvals[3 * i + 2];
      }
    } break;
    case 210U: {
      real_T t_sfvals[225];
      natcoords.set_size(75, 3);
      // prism_fek_75 - Quartic prismatic element with Fekete points
      //     [sfvals,sdvals] = prism_fek_75(xi,eta,zeta)
      //
      //   Input:
      //      xi, eta, zeta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 75-by-1
      //      sdvals: vector of size 75-by-3
      //
      //     nodes_nat_coors = prism_fek_75
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also prism_6, prism_18, prism_40, prism_gl_40, prism_75
      ::sfe_sfuncs::prism_fek_75_ncoords(&t_sfvals[0]);
      for (int32_T i{0}; i < 75; i++) {
        natcoords[3 * i] = t_sfvals[3 * i];
        natcoords[3 * i + 1] = t_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = t_sfvals[3 * i + 2];
      }
    } break;
    case 212U: {
      real_T ab_sfvals[378];
      natcoords.set_size(126, 3);
      // prism_126 - Quintic prismatic element with equidistant nodes
      //     [sfvals,sdvals] = prism_126(xi,eta,zeta)
      //
      //   Input:
      //      xi, eta, zeta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 126-by-1
      //      sdvals: vector of size 126-by-3
      //
      //     nodes_nat_coors = prism_126
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also prism_6, prism_18, prism_40, prism_gl_40, prism_gl_75,
      //   prism_75
      //  If no input argument, return nodal positions
      ::sfe_sfuncs::prism_126_ncoords(&ab_sfvals[0]);
      for (int32_T i{0}; i < 126; i++) {
        natcoords[3 * i] = ab_sfvals[3 * i];
        natcoords[3 * i + 1] = ab_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = ab_sfvals[3 * i + 2];
      }
    } break;
    case 216U: {
      real_T bb_sfvals[588];
      natcoords.set_size(196, 3);
      // prism_196 - Sextic prismatic element with equidistant nodes
      //     [sfvals,sdvals] = prism_196(xi,eta,zeta)
      //
      //   Input:
      //      xi, eta, zeta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 196-by-1
      //      sdvals: vector of size 196-by-3
      //
      //     nodes_nat_coors = prism_196
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also prism_6, prism_18, prism_40, prism_gl_40, prism_gl_75,
      //   prism_75
      //  If no input argument, return nodal positions
      ::sfe_sfuncs::prism_196_ncoords(&bb_sfvals[0]);
      for (int32_T i{0}; i < 196; i++) {
        natcoords[3 * i] = bb_sfvals[3 * i];
        natcoords[3 * i + 1] = bb_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = bb_sfvals[3 * i + 2];
      }
    } break;
    case 228U: {
      real_T u_sfvals[24];
      natcoords.set_size(8, 3);
      // hexa_8 - Trilinear hexahedral element
      //     [sfvals,sdvals] = hexa_8(xi,eta,zeta)
      //
      //   Input:
      //      xi, eta, zeta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 8-by-1
      //      sdvals: vector of size 8-by-3
      //
      //     nodes_nat_coors = hexa_8
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also hexa_27, hexa_64, hexa_gl_64, hexa_125, hexa_gl_125
      ::sfe_sfuncs::hexa_8_ncoords(&u_sfvals[0]);
      for (int32_T i{0}; i < 8; i++) {
        natcoords[3 * i] = u_sfvals[3 * i];
        natcoords[3 * i + 1] = u_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = u_sfvals[3 * i + 2];
      }
    } break;
    case 232U: {
      real_T v_sfvals[81];
      natcoords.set_size(27, 3);
      // hexa_27 - Triquadratic hexahedral element with equidistant nodes
      //     [sfvals,sdvals] = hexa_27(xi,eta,zeta)
      //
      //   Input:
      //      xi, eta, zeta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 27-by-1
      //      sdvals: vector of size 27-by-3
      //
      //     nodes_nat_coors = hexa_27
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also hexa_8, hexa_64, hexa_gl_64, hexa_125, hexa_gl_125
      ::sfe_sfuncs::hexa_27_ncoords(&v_sfvals[0]);
      for (int32_T i{0}; i < 27; i++) {
        natcoords[3 * i] = v_sfvals[3 * i];
        natcoords[3 * i + 1] = v_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = v_sfvals[3 * i + 2];
      }
    } break;
    case 236U: {
      real_T w_sfvals[192];
      natcoords.set_size(64, 3);
      // hexa_64 - Tricubic hexahedral element with equidistant nodes
      //     [sfvals,sdvals] = hexa_64(xi,eta,zeta)
      //
      //   Input:
      //      xi, eta, zeta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 64-by-1
      //      sdvals: vector of size 64-by-3
      //
      //     nodes_nat_coors = hexa_64
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also hexa_8, hexa_27, hexa_gl_64, hexa_125, hexa_gl_125
      ::sfe_sfuncs::hexa_64_ncoords(&w_sfvals[0]);
      for (int32_T i{0}; i < 64; i++) {
        natcoords[3 * i] = w_sfvals[3 * i];
        natcoords[3 * i + 1] = w_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = w_sfvals[3 * i + 2];
      }
    } break;
    case 237U: {
      real_T w_sfvals[192];
      natcoords.set_size(64, 3);
      // hexa_gl_64 - Tricubic hexahedral element with Gauss-Lobatto nodes
      //     [sfvals,sdvals] = hexa_gl_64(xi,eta,zeta)
      //
      //   Input:
      //      xi, eta, zeta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 64-by-1
      //      sdvals: vector of size 64-by-3
      //
      //     nodes_nat_coors = hexa_gl_64
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also hexa_8, hexa_27, hexa_64, hexa_125, hexa_gl_125
      ::sfe_sfuncs::hexa_gl_64_ncoords(&w_sfvals[0]);
      for (int32_T i{0}; i < 64; i++) {
        natcoords[3 * i] = w_sfvals[3 * i];
        natcoords[3 * i + 1] = w_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = w_sfvals[3 * i + 2];
      }
    } break;
    case 240U: {
      real_T x_sfvals[375];
      natcoords.set_size(125, 3);
      // hexa_125 - Triquartic hexahedral element with equidistant points
      //     [sfvals,sdvals] = hexa_125(xi,eta,zeta)
      //
      //   Input:
      //      xi, eta, zeta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 125-by-1
      //      sdvals: vector of size 125-by-3
      //
      //     nodes_nat_coors = hexa_125
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also hexa_8, hexa_27, hexa_64, hexa_gl_64, hexa_gl_125, hexa_216,
      //   hexa_gl_216
      ::sfe_sfuncs::hexa_125_ncoords(&x_sfvals[0]);
      for (int32_T i{0}; i < 125; i++) {
        natcoords[3 * i] = x_sfvals[3 * i];
        natcoords[3 * i + 1] = x_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = x_sfvals[3 * i + 2];
      }
    } break;
    case 241U: {
      real_T x_sfvals[375];
      natcoords.set_size(125, 3);
      // hexa_gl_125 - Triquartic hexahedral element with Gauss-Lobatto points
      //     [sfvals,sdvals] = hexa_gl_125(xi,eta,zeta)
      //
      //   Input:
      //      xi, eta, zeta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 125-by-1
      //      sdvals: vector of size 125-by-3
      //
      //     nodes_nat_coors = hexa_gl_125
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also hexa_8, hexa_27, hexa_64, hexa_gl_64, hexa_125
      ::sfe_sfuncs::hexa_gl_125_ncoords(&x_sfvals[0]);
      for (int32_T i{0}; i < 125; i++) {
        natcoords[3 * i] = x_sfvals[3 * i];
        natcoords[3 * i + 1] = x_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = x_sfvals[3 * i + 2];
      }
    } break;
    case 244U: {
      real_T cb_sfvals[648];
      natcoords.set_size(216, 3);
      // hexa_216 - Triquintic hexahedral element with equidistant points
      //     [sfvals,sdvals] = hexa_216(xi,eta,zeta)
      //
      //   Input:
      //      xi, eta, zeta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 216-by-1
      //      sdvals: vector of size 216-by-3
      //
      //     nodes_nat_coors = hexa_216
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also hexa_8, hexa_27, hexa_64, hexa_gl_64, hexa_125, hexa_gl_125,
      //   hexa_gl_216
      ::sfe_sfuncs::hexa_216_ncoords(&cb_sfvals[0]);
      for (int32_T i{0}; i < 216; i++) {
        natcoords[3 * i] = cb_sfvals[3 * i];
        natcoords[3 * i + 1] = cb_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = cb_sfvals[3 * i + 2];
      }
    } break;
    case 245U: {
      real_T cb_sfvals[648];
      natcoords.set_size(216, 3);
      // hexa_gl_216 - Triquintic hexahedral element with equidistant points
      //     [sfvals,sdvals] = hexa_gl_216(xi,eta,zeta)
      //
      //   Input:
      //      xi, eta, zeta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 216-by-1
      //      sdvals: vector of size 216-by-3
      //
      //     nodes_nat_coors = hexa_gl_216
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also hexa_8, hexa_27, hexa_64, hexa_gl_64, hexa_125, hexa_gl_125,
      //   hexa_216
      ::sfe_sfuncs::hexa_gl_216_ncoords(&cb_sfvals[0]);
      for (int32_T i{0}; i < 216; i++) {
        natcoords[3 * i] = cb_sfvals[3 * i];
        natcoords[3 * i + 1] = cb_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = cb_sfvals[3 * i + 2];
      }
    } break;
    case 248U: {
      real_T y_sfvals[1029];
      natcoords.set_size(343, 3);
      // hexa_343 - Trisextic hexahedral element with equidistant points
      //     [sfvals,sdvals] = hexa_343(xi,eta,zeta)
      //
      //   Input:
      //      xi, eta, zeta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 343-by-1
      //      sdvals: vector of size 343-by-3
      //
      //     nodes_nat_coors = hexa_34
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also hexa_8, hexa_27, hexa_64, hexa_gl_64, hexa_125, hexa_gl_125,
      //   hexa_gl_343
      ::sfe_sfuncs::hexa_343_ncoords(&y_sfvals[0]);
      for (int32_T i{0}; i < 343; i++) {
        natcoords[3 * i] = y_sfvals[3 * i];
        natcoords[3 * i + 1] = y_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = y_sfvals[3 * i + 2];
      }
    } break;
    default: {
      real_T y_sfvals[1029];
      natcoords.set_size(343, 3);
      // hexa_gl_343 - Trisextic hexahedral element with equidistant points
      //     [sfvals,sdvals] = hexa_gl_343(xi,eta,zeta)
      //
      //   Input:
      //      xi, eta, zeta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 343-by-1
      //      sdvals: vector of size 343-by-3
      //
      //     nodes_nat_coors = hexa_gl_343
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also hexa_8, hexa_27, hexa_64, hexa_gl_64, hexa_125, hexa_gl_125,
      //   hexa_343
      ::sfe_sfuncs::hexa_gl_343_ncoords(&y_sfvals[0]);
      for (int32_T i{0}; i < 343; i++) {
        natcoords[3 * i] = y_sfvals[3 * i];
        natcoords[3 * i + 1] = y_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = y_sfvals[3 * i + 2];
      }
    } break;
    }
  } break;
  }
}

static void obtain_natcoords(int32_T etype,
                             ::coder::array<real_T, 2U> &natcoords)
{
  int32_T shape;
  // obtain_natcoords - Obtain the coordinates for nodes in master elements
  //
  //    natcoords = obtain_natcoords(etype)
  //
  //  Parameter
  //  ---------
  //    etype:      integer representing the element type
  //
  //  Returns
  //  -------
  //    natcoords:  The coordinates in an n-by-d array
  // obtain_elemdim - Obtain the dimension of an element
  //
  //    dim = obtain_elemdim(etype)
  //
  //  See also obtain_elemshape
  // obtain_elemshape - Decode an element geometric shape from etype
  //
  //    shapeid = obtain_elemshape(etype)
  //
  //  RETURN
  //  ------
  //    shapeid:    Integer type of different geometry shapes:
  //                    1 - BAR
  //                    2 - TRI
  //                    3 - QUAD
  //                    4 - TET
  //                    5 - PYRAMID
  //                    6 - PRISM
  //                    7 - HEX
  //
  //  See also obtain_elemdim
  //  shapeid = (etype>>5)&0b111
  shape = etype >> 5 & 7;
  switch (((shape > 0) + (shape > 1)) + (shape > 3)) {
  case 1: {
    real_T natcoords_data[7];
    int32_T natcoords_size;
    // obtain_natcoords1d - obtain coordinates for elems in 1d in param space
    switch (etype) {
    case 36: {
      real_T h_sfvals[2];
      // bar_2 - Compute shape functions and their derivatives of bar_2
      //
      //     ncoords = bar_2
      //     [sfvals,sdvals] = bar_2(xi)
      //
      // Parameters
      // ----------
      //     xi: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 2-by-1
      //     sdvals: vector of size 2-by-1
      ::sfe_sfuncs::bar_2_ncoords(&h_sfvals[0]);
      natcoords_size = 2;
      natcoords_data[0] = h_sfvals[0];
      natcoords_data[1] = h_sfvals[1];
    } break;
    case 40: {
      real_T i_sfvals[3];
      // bar_3 - Compute shape functions and their derivatives of bar_3
      //
      //     ncoords = bar_3
      //     [sfvals,sdvals] = bar_3(xi)
      //
      // Parameters
      // ----------
      //     xi: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 3-by-1
      //     sdvals: vector of size 3-by-1
      ::sfe_sfuncs::bar_3_ncoords(&i_sfvals[0]);
      natcoords_size = 3;
      natcoords_data[0] = i_sfvals[0];
      natcoords_data[1] = i_sfvals[1];
      natcoords_data[2] = i_sfvals[2];
    } break;
    case 44: {
      real_T j_sfvals[4];
      // bar_4 - Compute shape functions and their derivatives of bar_4
      //
      //     ncoords = bar_4
      //     [sfvals,sdvals] = bar_4(xi)
      //
      // Parameters
      // ----------
      //     xi: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 4-by-1
      //     sdvals: vector of size 4-by-1
      ::sfe_sfuncs::bar_4_ncoords(&j_sfvals[0]);
      natcoords_size = 4;
      natcoords_data[0] = j_sfvals[0];
      natcoords_data[1] = j_sfvals[1];
      natcoords_data[2] = j_sfvals[2];
      natcoords_data[3] = j_sfvals[3];
    } break;
    case 48: {
      real_T k_sfvals[5];
      // bar_5 - Compute shape functions and their derivatives of bar_5
      //
      //     ncoords = bar_5
      //     [sfvals,sdvals] = bar_5(xi)
      //
      // Parameters
      // ----------
      //     xi: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 5-by-1
      //     sdvals: vector of size 5-by-1
      ::sfe_sfuncs::bar_5_ncoords(&k_sfvals[0]);
      natcoords_size = 5;
      for (int32_T i{0}; i < 5; i++) {
        natcoords_data[i] = k_sfvals[i];
      }
    } break;
    case 52: {
      real_T l_sfvals[6];
      // bar_6 - Compute shape functions and their derivatives of bar_6
      //
      //     ncoords = bar_6
      //     [sfvals,sdvals] = bar_6(xi)
      //
      // Parameters
      // ----------
      //     xi: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 6-by-1
      //     sdvals: vector of size 6-by-1
      ::sfe_sfuncs::bar_6_ncoords(&l_sfvals[0]);
      natcoords_size = 6;
      for (int32_T i{0}; i < 6; i++) {
        natcoords_data[i] = l_sfvals[i];
      }
    } break;
    case 56: {
      real_T g_sfvals[7];
      // bar_7 - Compute shape functions and their derivatives of bar_7
      //
      //     ncoords = bar_7
      //     [sfvals,sdvals] = bar_7(xi)
      //
      // Parameters
      // ----------
      //     xi: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 7-by-1
      //     sdvals: vector of size 7-by-1
      ::sfe_sfuncs::bar_7_ncoords(&g_sfvals[0]);
      natcoords_size = 7;
      for (int32_T i{0}; i < 7; i++) {
        natcoords_data[i] = g_sfvals[i];
      }
    } break;
    case 45: {
      real_T j_sfvals[4];
      // bar_gl_4 - Compute shape functions and their derivatives of bar_gl_4
      //
      //     ncoords = bar_gl_4
      //     [sfvals,sdvals] = bar_gl_4(xi)
      //
      // Parameters
      // ----------
      //     xi: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 4-by-1
      //     sdvals: vector of size 4-by-1
      ::sfe_sfuncs::bar_gl_4_ncoords(&j_sfvals[0]);
      natcoords_size = 4;
      natcoords_data[0] = j_sfvals[0];
      natcoords_data[1] = j_sfvals[1];
      natcoords_data[2] = j_sfvals[2];
      natcoords_data[3] = j_sfvals[3];
    } break;
    case 49: {
      real_T k_sfvals[5];
      // bar_gl_5 - Compute shape functions and their derivatives of bar_gl_5
      //
      //     ncoords = bar_gl_5
      //     [sfvals,sdvals] = bar_gl_5(xi)
      //
      // Parameters
      // ----------
      //     xi: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 5-by-1
      //     sdvals: vector of size 5-by-1
      ::sfe_sfuncs::bar_gl_5_ncoords(&k_sfvals[0]);
      natcoords_size = 5;
      for (int32_T i{0}; i < 5; i++) {
        natcoords_data[i] = k_sfvals[i];
      }
    } break;
    case 53: {
      real_T l_sfvals[6];
      // bar_gl_6 - Compute shape functions and their derivatives of bar_gl_6
      //
      //     ncoords = bar_gl_6
      //     [sfvals,sdvals] = bar_gl_6(xi)
      //
      // Parameters
      // ----------
      //     xi: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 6-by-1
      //     sdvals: vector of size 6-by-1
      ::sfe_sfuncs::bar_gl_6_ncoords(&l_sfvals[0]);
      natcoords_size = 6;
      for (int32_T i{0}; i < 6; i++) {
        natcoords_data[i] = l_sfvals[i];
      }
    } break;
    default: {
      real_T g_sfvals[7];
      // bar_gl_7 - Compute shape functions and their derivatives of bar_gl_7
      //
      //     ncoords = bar_gl_7
      //     [sfvals,sdvals] = bar_gl_7(xi)
      //
      // Parameters
      // ----------
      //     xi: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 7-by-1
      //     sdvals: vector of size 7-by-1
      ::sfe_sfuncs::bar_gl_7_ncoords(&g_sfvals[0]);
      natcoords_size = 7;
      for (int32_T i{0}; i < 7; i++) {
        natcoords_data[i] = g_sfvals[i];
      }
    } break;
    }
    natcoords.set_size(natcoords_size, 1);
    for (int32_T i{0}; i < natcoords_size; i++) {
      natcoords[i] = natcoords_data[i];
    }
  } break;
  case 2: {
    // obtain_natcoords2d - obtain coordinates for elems in 2d in param space
    switch (etype) {
    case 68: {
      real_T l_sfvals[6];
      natcoords.set_size(3, 2);
      // tri_3 - Compute shape functions and their derivatives of tri_3
      //
      //     ncoords = tri_3
      //     [sfvals,sdvals] = tri_3(xi,eta)
      //
      // Parameters
      // ----------
      //     xi,eta: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 3-by-1
      //     sdvals: vector of size 3-by-2
      ::sfe_sfuncs::tri_3_ncoords(&l_sfvals[0]);
      for (int32_T i{0}; i < 3; i++) {
        int32_T natcoords_size;
        natcoords_size = i << 1;
        natcoords[2 * i] = l_sfvals[natcoords_size];
        natcoords[2 * i + 1] = l_sfvals[natcoords_size + 1];
      }
    } break;
    case 72: {
      real_T m_sfvals[12];
      natcoords.set_size(6, 2);
      // tri_6 - Compute shape functions and their derivatives of tri_6
      //
      //     ncoords = tri_6
      //     [sfvals,sdvals] = tri_6(xi,eta)
      //
      // Parameters
      // ----------
      //     xi,eta: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 6-by-1
      //     sdvals: vector of size 6-by-2
      ::sfe_sfuncs::tri_6_ncoords(&m_sfvals[0]);
      for (int32_T i{0}; i < 6; i++) {
        int32_T natcoords_size;
        natcoords_size = i << 1;
        natcoords[2 * i] = m_sfvals[natcoords_size];
        natcoords[2 * i + 1] = m_sfvals[natcoords_size + 1];
      }
    } break;
    case 76: {
      real_T n_sfvals[20];
      natcoords.set_size(10, 2);
      // tri_10 - Compute shape functions and their derivatives of tri_10
      //
      //     ncoords = tri_10
      //     [sfvals,sdvals] = tri_10(xi,eta)
      //
      // Parameters
      // ----------
      //     xi,eta: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 10-by-1
      //     sdvals: vector of size 10-by-2
      ::sfe_sfuncs::tri_10_ncoords(&n_sfvals[0]);
      for (int32_T i{0}; i < 10; i++) {
        int32_T natcoords_size;
        natcoords_size = i << 1;
        natcoords[2 * i] = n_sfvals[natcoords_size];
        natcoords[2 * i + 1] = n_sfvals[natcoords_size + 1];
      }
    } break;
    case 77: {
      real_T n_sfvals[20];
      natcoords.set_size(10, 2);
      // tri_gl_10 - Compute shape functions and their derivatives of tri_gl_10
      //
      //     ncoords = tri_gl_10
      //     [sfvals,sdvals] = tri_gl_10(xi,eta)
      //
      // Parameters
      // ----------
      //     xi,eta: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 10-by-1
      //     sdvals: vector of size 10-by-2
      ::sfe_sfuncs::tri_gl_10_ncoords(&n_sfvals[0]);
      for (int32_T i{0}; i < 10; i++) {
        int32_T natcoords_size;
        natcoords_size = i << 1;
        natcoords[2 * i] = n_sfvals[natcoords_size];
        natcoords[2 * i + 1] = n_sfvals[natcoords_size + 1];
      }
    } break;
    case 80: {
      real_T o_sfvals[30];
      natcoords.set_size(15, 2);
      // tri_15 - Compute shape functions and their derivatives of tri_15
      //
      //     ncoords = tri_15
      //     [sfvals,sdvals] = tri_15(xi,eta)
      //
      // Parameters
      // ----------
      //     xi,eta: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 15-by-1
      //     sdvals: vector of size 15-by-2
      ::sfe_sfuncs::tri_15_ncoords(&o_sfvals[0]);
      for (int32_T i{0}; i < 15; i++) {
        int32_T natcoords_size;
        natcoords_size = i << 1;
        natcoords[2 * i] = o_sfvals[natcoords_size];
        natcoords[2 * i + 1] = o_sfvals[natcoords_size + 1];
      }
    } break;
    case 81: {
      real_T o_sfvals[30];
      natcoords.set_size(15, 2);
      // tri_gl_15 - Compute shape functions and their derivatives of tri_gl_15
      //
      //     ncoords = tri_gl_15
      //     [sfvals,sdvals] = tri_gl_15(xi,eta)
      //
      // Parameters
      // ----------
      //     xi,eta: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 15-by-1
      //     sdvals: vector of size 15-by-2
      ::sfe_sfuncs::tri_gl_15_ncoords(&o_sfvals[0]);
      for (int32_T i{0}; i < 15; i++) {
        int32_T natcoords_size;
        natcoords_size = i << 1;
        natcoords[2 * i] = o_sfvals[natcoords_size];
        natcoords[2 * i + 1] = o_sfvals[natcoords_size + 1];
      }
    } break;
    case 84: {
      real_T p_sfvals[42];
      natcoords.set_size(21, 2);
      // tri_21 - Compute shape functions and their derivatives of tri_21
      //
      //     ncoords = tri_21
      //     [sfvals,sdvals] = tri_21(xi,eta)
      //
      // Parameters
      // ----------
      //     xi,eta: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 21-by-1
      //     sdvals: vector of size 21-by-2
      ::sfe_sfuncs::tri_21_ncoords(&p_sfvals[0]);
      for (int32_T i{0}; i < 21; i++) {
        int32_T natcoords_size;
        natcoords_size = i << 1;
        natcoords[2 * i] = p_sfvals[natcoords_size];
        natcoords[2 * i + 1] = p_sfvals[natcoords_size + 1];
      }
    } break;
    case 85: {
      real_T p_sfvals[42];
      natcoords.set_size(21, 2);
      // tri_gl_21 - Compute shape functions and their derivatives of tri_gl_21
      //
      //     ncoords = tri_gl_21
      //     [sfvals,sdvals] = tri_gl_21(xi,eta)
      //
      // Parameters
      // ----------
      //     xi,eta: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 21-by-1
      //     sdvals: vector of size 21-by-2
      ::sfe_sfuncs::tri_gl_21_ncoords(&p_sfvals[0]);
      for (int32_T i{0}; i < 21; i++) {
        int32_T natcoords_size;
        natcoords_size = i << 1;
        natcoords[2 * i] = p_sfvals[natcoords_size];
        natcoords[2 * i + 1] = p_sfvals[natcoords_size + 1];
      }
    } break;
    case 88: {
      real_T q_sfvals[56];
      natcoords.set_size(28, 2);
      // tri_28 - Compute shape functions and their derivatives of tri_28
      //
      //     ncoords = tri_28
      //     [sfvals,sdvals] = tri_28(xi,eta)
      //
      // Parameters
      // ----------
      //     xi,eta: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 28-by-1
      //     sdvals: vector of size 28-by-2
      ::sfe_sfuncs::tri_28_ncoords(&q_sfvals[0]);
      for (int32_T i{0}; i < 28; i++) {
        int32_T natcoords_size;
        natcoords_size = i << 1;
        natcoords[2 * i] = q_sfvals[natcoords_size];
        natcoords[2 * i + 1] = q_sfvals[natcoords_size + 1];
      }
    } break;
    case 100: {
      real_T b_sfvals[8];
      natcoords.set_size(4, 2);
      // quad_4 - Bilinear quadrilateral element
      //     [sfvals,sdvals] = quad_4(xi,eta)
      //
      //   Input:
      //      xi, eta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 4-by-1
      //      sdvals: vector of size 4-by-2
      //
      //     nodes_nat_coors = quad_4
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also quad_9, quad_16, quad_gl_16, quad_25, quad_gl_25
      ::sfe_sfuncs::quad_4_ncoords(&b_sfvals[0]);
      for (int32_T i{0}; i < 4; i++) {
        int32_T natcoords_size;
        natcoords_size = i << 1;
        natcoords[2 * i] = b_sfvals[natcoords_size];
        natcoords[2 * i + 1] = b_sfvals[natcoords_size + 1];
      }
    } break;
    case 104: {
      real_T c_sfvals[18];
      natcoords.set_size(9, 2);
      // quad_9 - Bilinear quadrilateral element
      //     [sfvals,sdvals] = quad_9(xi,eta)
      //
      //   Input:
      //      xi, eta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 9-by-1
      //      sdvals: vector of size 9-by-2
      //
      //     nodes_nat_coors = quad_9
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also quad_4, quad_16, quad_gl_16, quad_25, quad_gl_25
      ::sfe_sfuncs::quad_9_ncoords(&c_sfvals[0]);
      for (int32_T i{0}; i < 9; i++) {
        int32_T natcoords_size;
        natcoords_size = i << 1;
        natcoords[2 * i] = c_sfvals[natcoords_size];
        natcoords[2 * i + 1] = c_sfvals[natcoords_size + 1];
      }
    } break;
    case 108: {
      real_T d_sfvals[32];
      natcoords.set_size(16, 2);
      // quad_16 - Bicubic quadrilateral element with equidistant points
      //     [sfvals,sdvals] = quad_16(xi,eta)
      //
      //   Input:
      //      xi, eta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 16-by-1
      //      sdvals: vector of size 16-by-2
      //
      //     nodes_nat_coors = quad_16
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also quad_4, quad_9, quad_gl_16, quad_25, quad_gl_25
      ::sfe_sfuncs::quad_16_ncoords(&d_sfvals[0]);
      for (int32_T i{0}; i < 16; i++) {
        int32_T natcoords_size;
        natcoords_size = i << 1;
        natcoords[2 * i] = d_sfvals[natcoords_size];
        natcoords[2 * i + 1] = d_sfvals[natcoords_size + 1];
      }
    } break;
    case 109: {
      real_T d_sfvals[32];
      natcoords.set_size(16, 2);
      // quad_gl_16 - Bicubic quadrilateral element with Gauss-Lobatto points
      //     [sfvals,sdvals] = quad_gl_16(xi,eta)
      //
      //   Input:
      //      xi, eta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 16-by-1
      //      sdvals: vector of size 16-by-2
      //
      //     NAT_COORS = quad_gl_16
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also quad_4, quad_9, quad_16, quad_25, quad_gl_25
      ::sfe_sfuncs::quad_gl_16_ncoords(&d_sfvals[0]);
      for (int32_T i{0}; i < 16; i++) {
        int32_T natcoords_size;
        natcoords_size = i << 1;
        natcoords[2 * i] = d_sfvals[natcoords_size];
        natcoords[2 * i + 1] = d_sfvals[natcoords_size + 1];
      }
    } break;
    case 112: {
      real_T e_sfvals[50];
      natcoords.set_size(25, 2);
      // quad_25 - Biquartic quadrilateral element with equidistant points
      //     [sfvals,sdvals] = quad_25(xi,eta)
      //
      //   Input:
      //      xi, eta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 25-by-1
      //      sdvals: vector of size 25-by-2
      //
      //     nodes_nat_coors = quad_25
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also quad_4, quad_9, quad_16, quad_gl_16, quad_gl_25
      ::sfe_sfuncs::quad_25_ncoords(&e_sfvals[0]);
      for (int32_T i{0}; i < 25; i++) {
        int32_T natcoords_size;
        natcoords_size = i << 1;
        natcoords[2 * i] = e_sfvals[natcoords_size];
        natcoords[2 * i + 1] = e_sfvals[natcoords_size + 1];
      }
    } break;
    case 113: {
      real_T e_sfvals[50];
      natcoords.set_size(25, 2);
      // quad_gl_25 - Biquartic quadrilateral element with Gauss-Lobatto points
      //     [sfvals,sdvals] = quad_gl_25(xi,eta)
      //
      //   Input:
      //      xi, eta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 25-by-1
      //      sdvals: vector of size 25-by-2
      //
      //     nodes_nat_coors = quad_gl_25
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also quad_4, quad_9, quad_16, quad_gl_16, quad_25
      ::sfe_sfuncs::quad_gl_25_ncoords(&e_sfvals[0]);
      for (int32_T i{0}; i < 25; i++) {
        int32_T natcoords_size;
        natcoords_size = i << 1;
        natcoords[2 * i] = e_sfvals[natcoords_size];
        natcoords[2 * i + 1] = e_sfvals[natcoords_size + 1];
      }
    } break;
    case 116: {
      real_T f_sfvals[72];
      natcoords.set_size(36, 2);
      // quad_36   Biquintic quadrilateral element with equidistant points
      //     [sfvals,sdvals] = quad_36(xi,eta)
      //
      //   Input:
      //      xi, eta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 25-by-1
      //      sdvals: vector of size 25-by-2
      //
      //     nodes_nat_coors = quad_36
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also quad_4, quad_9, quad_16, quad_gl_16, quad_gl_25
      ::sfe_sfuncs::quad_36_ncoords(&f_sfvals[0]);
      for (int32_T i{0}; i < 36; i++) {
        int32_T natcoords_size;
        natcoords_size = i << 1;
        natcoords[2 * i] = f_sfvals[natcoords_size];
        natcoords[2 * i + 1] = f_sfvals[natcoords_size + 1];
      }
    } break;
    case 117: {
      real_T f_sfvals[72];
      natcoords.set_size(36, 2);
      // quad_gl_36 - Biquintic quadrilateral element with equidistant points
      //     [sfvals,sdvals] = quad_gl_36(xi,eta)
      //
      //   Input:
      //      xi, eta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 36-by-1
      //      sdvals: vector of size 36-by-2
      //
      //     nodes_nat_coors = quad_gl_36
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also quad_4, quad_9, quad_16, quad_gl_16, quad_gl_25
      ::sfe_sfuncs::quad_gl_36_ncoords(&f_sfvals[0]);
      for (int32_T i{0}; i < 36; i++) {
        int32_T natcoords_size;
        natcoords_size = i << 1;
        natcoords[2 * i] = f_sfvals[natcoords_size];
        natcoords[2 * i + 1] = f_sfvals[natcoords_size + 1];
      }
    } break;
    case 120: {
      real_T sfvals[98];
      natcoords.set_size(49, 2);
      // quad_49 - Bisextic quadrilateral element with equidistant points
      //     [sfvals,sdvals] = quad_49(xi,eta)
      //
      //   Input:
      //      xi, eta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 25-by-1
      //      sdvals: vector of size 25-by-2
      //
      //     nodes_nat_coors = quad_49
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also quad_4, quad_9, quad_16, quad_gl_16, quad_gl_25
      ::sfe_sfuncs::quad_49_ncoords(&sfvals[0]);
      for (int32_T i{0}; i < 49; i++) {
        int32_T natcoords_size;
        natcoords_size = i << 1;
        natcoords[2 * i] = sfvals[natcoords_size];
        natcoords[2 * i + 1] = sfvals[natcoords_size + 1];
      }
    } break;
    default: {
      real_T sfvals[98];
      natcoords.set_size(49, 2);
      // quad_gl_49 - Bisextic quadrilateral element with equidistant points
      //     [sfvals,sdvals] = quad_gl_49(xi,eta)
      //
      //   Input:
      //      xi, eta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 49-by-1
      //      sdvals: vector of size 49-by-2
      //
      //     nodes_nat_coors = quad_gl_49
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also quad_4, quad_9, quad_16, quad_gl_16, quad_gl_25
      ::sfe_sfuncs::quad_gl_49_ncoords(&sfvals[0]);
      for (int32_T i{0}; i < 49; i++) {
        int32_T natcoords_size;
        natcoords_size = i << 1;
        natcoords[2 * i] = sfvals[natcoords_size];
        natcoords[2 * i + 1] = sfvals[natcoords_size + 1];
      }
    } break;
    }
  } break;
  default: {
    // obtain_elemdim - Obtain the dimension of an element
    //
    //    dim = obtain_elemdim(etype)
    //
    //  See also obtain_elemshape
    // obtain_elemshape - Decode an element geometric shape from etype
    //
    //    shapeid = obtain_elemshape(etype)
    //
    //  RETURN
    //  ------
    //    shapeid:    Integer type of different geometry shapes:
    //                    1 - BAR
    //                    2 - TRI
    //                    3 - QUAD
    //                    4 - TET
    //                    5 - PYRAMID
    //                    6 - PRISM
    //                    7 - HEX
    //
    //  See also obtain_elemdim
    //  shapeid = (etype>>5)&0b111
    // obtain_natcoords3d - obtain coordinates for elems in 3d in param space
    switch (etype) {
    case 132: {
      real_T m_sfvals[12];
      natcoords.set_size(4, 3);
      // tet_4 - Compute shape functions and their derivatives of tet_4
      //
      //     ncoords = tet_4
      //     [sfvals,sdvals] = tet_4(xi,eta,zeta)
      //
      // Parameters
      // ----------
      //     xi,eta,zeta: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 4-by-1
      //     sdvals: vector of size 4-by-3
      ::sfe_sfuncs::tet_4_ncoords(&m_sfvals[0]);
      for (int32_T i{0}; i < 4; i++) {
        natcoords[3 * i] = m_sfvals[3 * i];
        natcoords[3 * i + 1] = m_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = m_sfvals[3 * i + 2];
      }
    } break;
    case 136: {
      real_T o_sfvals[30];
      natcoords.set_size(10, 3);
      // tet_10 - Compute shape functions and their derivatives of tet_10
      //
      //     ncoords = tet_10
      //     [sfvals,sdvals] = tet_10(xi,eta,zeta)
      //
      // Parameters
      // ----------
      //     xi,eta,zeta: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 10-by-1
      //     sdvals: vector of size 10-by-3
      ::sfe_sfuncs::tet_10_ncoords(&o_sfvals[0]);
      for (int32_T i{0}; i < 10; i++) {
        natcoords[3 * i] = o_sfvals[3 * i];
        natcoords[3 * i + 1] = o_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = o_sfvals[3 * i + 2];
      }
    } break;
    case 140: {
      real_T db_sfvals[60];
      natcoords.set_size(20, 3);
      // tet_20 - Compute shape functions and their derivatives of tet_20
      //
      //     ncoords = tet_20
      //     [sfvals,sdvals] = tet_20(xi,eta,zeta)
      //
      // Parameters
      // ----------
      //     xi,eta,zeta: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 20-by-1
      //     sdvals: vector of size 20-by-3
      ::sfe_sfuncs::tet_20_ncoords(&db_sfvals[0]);
      for (int32_T i{0}; i < 20; i++) {
        natcoords[3 * i] = db_sfvals[3 * i];
        natcoords[3 * i + 1] = db_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = db_sfvals[3 * i + 2];
      }
    } break;
    case 141: {
      real_T db_sfvals[60];
      natcoords.set_size(20, 3);
      // tet_gl_20 - Compute shape functions and their derivatives of tet_gl_20
      //
      //     ncoords = tet_gl_20
      //     [sfvals,sdvals] = tet_gl_20(xi,eta,zeta)
      //
      // Parameters
      // ----------
      //     xi,eta,zeta: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 20-by-1
      //     sdvals: vector of size 20-by-3
      ::sfe_sfuncs::tet_gl_20_ncoords(&db_sfvals[0]);
      for (int32_T i{0}; i < 20; i++) {
        natcoords[3 * i] = db_sfvals[3 * i];
        natcoords[3 * i + 1] = db_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = db_sfvals[3 * i + 2];
      }
    } break;
    case 144: {
      real_T eb_sfvals[105];
      natcoords.set_size(35, 3);
      // tet_35 - Compute shape functions and their derivatives of tet_35
      //
      //     ncoords = tet_35
      //     [sfvals,sdvals] = tet_35(xi,eta,zeta)
      //
      // Parameters
      // ----------
      //     xi,eta,zeta: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 35-by-1
      //     sdvals: vector of size 35-by-3
      ::sfe_sfuncs::tet_35_ncoords(&eb_sfvals[0]);
      for (int32_T i{0}; i < 35; i++) {
        natcoords[3 * i] = eb_sfvals[3 * i];
        natcoords[3 * i + 1] = eb_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = eb_sfvals[3 * i + 2];
      }
    } break;
    case 145: {
      real_T eb_sfvals[105];
      natcoords.set_size(35, 3);
      // tet_gl_35 - Compute shape functions and their derivatives of tet_gl_35
      //
      //     ncoords = tet_gl_35
      //     [sfvals,sdvals] = tet_gl_35(xi,eta,zeta)
      //
      // Parameters
      // ----------
      //     xi,eta,zeta: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 35-by-1
      //     sdvals: vector of size 35-by-3
      ::sfe_sfuncs::tet_gl_35_ncoords(&eb_sfvals[0]);
      for (int32_T i{0}; i < 35; i++) {
        natcoords[3 * i] = eb_sfvals[3 * i];
        natcoords[3 * i + 1] = eb_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = eb_sfvals[3 * i + 2];
      }
    } break;
    case 148: {
      real_T fb_sfvals[168];
      natcoords.set_size(56, 3);
      // tet_56 - Compute shape functions and their derivatives of tet_56
      //
      //     ncoords = tet_56
      //     [sfvals,sdvals] = tet_56(xi,eta,zeta)
      //
      // Parameters
      // ----------
      //     xi,eta,zeta: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 56-by-1
      //     sdvals: vector of size 56-by-3
      ::sfe_sfuncs::tet_56_ncoords(&fb_sfvals[0]);
      for (int32_T i{0}; i < 56; i++) {
        natcoords[3 * i] = fb_sfvals[3 * i];
        natcoords[3 * i + 1] = fb_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = fb_sfvals[3 * i + 2];
      }
    } break;
    case 152: {
      real_T gb_sfvals[252];
      natcoords.set_size(84, 3);
      // tet_84 - Compute shape functions and their derivatives of tet_84
      //
      //     ncoords = tet_84
      //     [sfvals,sdvals] = tet_84(xi,eta,zeta,varargin)
      //
      // Parameters
      // ----------
      //     xi,eta,zeta,varargin: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 84-by-1
      //     sdvals: vector of size 84-by-3
      ::sfe_sfuncs::tet_84_ncoords(&gb_sfvals[0]);
      for (int32_T i{0}; i < 84; i++) {
        natcoords[3 * i] = gb_sfvals[3 * i];
        natcoords[3 * i + 1] = gb_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = gb_sfvals[3 * i + 2];
      }
    } break;
    case 164: {
      real_T hb_sfvals[15];
      natcoords.set_size(5, 3);
      // pyra_5 - Compute shape functions and their derivatives of pyra_5
      //
      //     ncoords = pyra_5
      //     [sfvals,sdvals] = pyra_5(xi,eta,zeta)
      //
      // Parameters
      // ----------
      //     xi,eta: natural coordinates ranging between -1 and 1
      //     zeta: natural coordinate ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 5-by-1
      //     sdvals: vector of size 5-by-3
      // Note
      // ----
      //  The shape functions are based on Bedrosian rational basis functions.
      ::sfe_sfuncs::pyra_5_ncoords(&hb_sfvals[0]);
      for (int32_T i{0}; i < 5; i++) {
        natcoords[3 * i] = hb_sfvals[3 * i];
        natcoords[3 * i + 1] = hb_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = hb_sfvals[3 * i + 2];
      }
    } break;
    case 168: {
      real_T p_sfvals[42];
      natcoords.set_size(14, 3);
      // pyra_14 - Compute shape functions and their derivatives of pyra_14
      //
      //     ncoords = pyra_14
      //     [sfvals,sdvals] = pyra_14(xi,eta,zeta)
      //
      // Parameters
      // ----------
      //     xi,eta: natural coordinates ranging between -1 and 1
      //     zeta: natural coordinate ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 14-by-1
      //     sdvals: vector of size 14-by-3
      // Note
      // ----
      //  The shape functions are based on Bedrosian rational basis functions.
      ::sfe_sfuncs::pyra_14_ncoords(&p_sfvals[0]);
      for (int32_T i{0}; i < 14; i++) {
        natcoords[3 * i] = p_sfvals[3 * i];
        natcoords[3 * i + 1] = p_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = p_sfvals[3 * i + 2];
      }
    } break;
    case 172: {
      real_T ib_sfvals[90];
      natcoords.set_size(30, 3);
      // pyra_30 - Compute shape functions and their derivatives of pyra_30
      //
      //     ncoords = pyra_30
      //     [sfvals,sdvals] = pyra_30(xi,eta,zeta)
      //
      // Parameters
      // ----------
      //     xi,eta: natural coordinates ranging between -1 and 1
      //     zeta: natural coordinate ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 30-by-1
      //     sdvals: vector of size 30-by-3
      // Note
      // ----
      //  The shape functions are based on Bedrosian rational basis functions.
      ::sfe_sfuncs::pyra_30_ncoords(&ib_sfvals[0]);
      for (int32_T i{0}; i < 30; i++) {
        natcoords[3 * i] = ib_sfvals[3 * i];
        natcoords[3 * i + 1] = ib_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = ib_sfvals[3 * i + 2];
      }
    } break;
    case 173: {
      real_T ib_sfvals[90];
      natcoords.set_size(30, 3);
      // pyra_gl_30 - Compute shape functions and their derivatives of
      // pyra_gl_30
      //
      //     ncoords = pyra_gl_30
      //     [sfvals,sdvals] = pyra_gl_30(xi,eta,zeta)
      //
      // Parameters
      // ----------
      //     xi,eta: natural coordinates ranging between -1 and 1
      //     zeta: natural coordinate ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 30-by-1
      //     sdvals: vector of size 30-by-3
      // Note
      // ----
      //  The shape functions are based on Bedrosian rational basis functions.
      ::sfe_sfuncs::pyra_gl_30_ncoords(&ib_sfvals[0]);
      for (int32_T i{0}; i < 30; i++) {
        natcoords[3 * i] = ib_sfvals[3 * i];
        natcoords[3 * i + 1] = ib_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = ib_sfvals[3 * i + 2];
      }
    } break;
    case 176: {
      real_T jb_sfvals[165];
      natcoords.set_size(55, 3);
      // pyra_55 - Compute shape functions and their derivatives of pyra_55
      //
      //     ncoords = pyra_55
      //     [sfvals,sdvals] = pyra_55(xi,eta,zeta)
      //
      // Parameters
      // ----------
      //     xi,eta: natural coordinates ranging between -1 and 1
      //     zeta: natural coordinate ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 55-by-1
      //     sdvals: vector of size 55-by-3
      // Note
      // ----
      //  The shape functions are based on Bedrosian rational basis functions.
      ::sfe_sfuncs::pyra_55_ncoords(&jb_sfvals[0]);
      for (int32_T i{0}; i < 55; i++) {
        natcoords[3 * i] = jb_sfvals[3 * i];
        natcoords[3 * i + 1] = jb_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = jb_sfvals[3 * i + 2];
      }
    } break;
    case 177: {
      real_T jb_sfvals[165];
      natcoords.set_size(55, 3);
      // pyra_gl_55 - Compute shape functions and their derivatives of
      // pyra_gl_55
      //
      //     ncoords = pyra_gl_55
      //     [sfvals,sdvals] = pyra_gl_55(xi,eta,zeta)
      //
      // Parameters
      // ----------
      //     xi,eta: natural coordinates ranging between -1 and 1
      //     zeta: natural coordinate ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 55-by-1
      //     sdvals: vector of size 55-by-3
      // Note
      // ----
      //  The shape functions are based on Bedrosian rational basis functions.
      ::sfe_sfuncs::pyra_gl_55_ncoords(&jb_sfvals[0]);
      for (int32_T i{0}; i < 55; i++) {
        natcoords[3 * i] = jb_sfvals[3 * i];
        natcoords[3 * i + 1] = jb_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = jb_sfvals[3 * i + 2];
      }
    } break;
    case 180: {
      real_T kb_sfvals[273];
      natcoords.set_size(91, 3);
      // pyra_91 - Compute shape functions and their derivatives of pyra_91
      //
      //     ncoords = pyra_91
      //     [sfvals,sdvals] = pyra_91(xi,eta,zeta)
      //
      // Parameters
      // ----------
      //     xi,eta: natural coordinates ranging between -1 and 1
      //     zeta: natural coordinate ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 91-by-1
      //     sdvals: vector of size 91-by-3
      // Note
      // ----
      //  The shape functions are based on Bedrosian rational basis functions.
      ::sfe_sfuncs::pyra_91_ncoords(&kb_sfvals[0]);
      for (int32_T i{0}; i < 91; i++) {
        natcoords[3 * i] = kb_sfvals[3 * i];
        natcoords[3 * i + 1] = kb_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = kb_sfvals[3 * i + 2];
      }
    } break;
    case 196: {
      real_T c_sfvals[18];
      natcoords.set_size(6, 3);
      // prism_6 - Linear prismatic element
      //     [sfvals,sdvals] = prism_6(xi,eta,zeta)
      //
      //   Input:
      //      xi, eta, zeta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 6-by-1
      //      sdvals: vector of size 6-by-3
      //
      //     nodes_nat_coors = prism_6
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also prism_18, prism_40, prism_gl_40, prism_75, prism_gl_75
      ::sfe_sfuncs::prism_6_ncoords(&c_sfvals[0]);
      for (int32_T i{0}; i < 6; i++) {
        natcoords[3 * i] = c_sfvals[3 * i];
        natcoords[3 * i + 1] = c_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = c_sfvals[3 * i + 2];
      }
    } break;
    case 200: {
      real_T r_sfvals[54];
      natcoords.set_size(18, 3);
      // prism_18 - Quadratic prismatic element
      //     [sfvals,sdvals] = prism_18(xi,eta,zeta)
      //
      //   Input:
      //      xi, eta, zeta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 18-by-1
      //      sdvals: vector of size 18-by-3
      //
      //     nodes_nat_coors = prism_18
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also prism_6, prism_40, prism_gl_40, prism_75, prism_gl_75
      ::sfe_sfuncs::prism_18_ncoords(&r_sfvals[0]);
      for (int32_T i{0}; i < 18; i++) {
        natcoords[3 * i] = r_sfvals[3 * i];
        natcoords[3 * i + 1] = r_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = r_sfvals[3 * i + 2];
      }
    } break;
    case 204: {
      real_T s_sfvals[120];
      natcoords.set_size(40, 3);
      // prism_40 - Cubic prismatic element
      //     [sfvals,sdvals] = prism_40(xi,eta,zeta)
      //
      //   Input:
      //      xi, eta, zeta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 40-by-1
      //      sdvals: vector of size 40-by-3
      //
      //     nodes_nat_coors = prism_40
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also prism_6, prism_18, prism_gl_40, prism_75, prism_gl_75
      ::sfe_sfuncs::prism_40_ncoords(&s_sfvals[0]);
      for (int32_T i{0}; i < 40; i++) {
        natcoords[3 * i] = s_sfvals[3 * i];
        natcoords[3 * i + 1] = s_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = s_sfvals[3 * i + 2];
      }
    } break;
    case 205: {
      real_T s_sfvals[120];
      natcoords.set_size(40, 3);
      // prism_gl_40 - Quadratic prismatic element with Gauss-Lobatto nodes
      //     [sfvals,sdvals] = prism_gl_40(xi,eta,zeta)
      //
      //   Input:
      //      xi, eta, zeta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 40-by-1
      //      sdvals: vector of size 40-by-3
      //
      //     nodes_nat_coors = prism_40
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also prism_6, prism_18, prism_gl_40, prism_75, prism_gl_75
      ::sfe_sfuncs::prism_gl_40_ncoords(&s_sfvals[0]);
      for (int32_T i{0}; i < 40; i++) {
        natcoords[3 * i] = s_sfvals[3 * i];
        natcoords[3 * i + 1] = s_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = s_sfvals[3 * i + 2];
      }
    } break;
    case 208: {
      real_T t_sfvals[225];
      natcoords.set_size(75, 3);
      // prism_75 - Quartic prismatic element with equidistant nodes
      //     [sfvals,sdvals] = prism_75(xi,eta,zeta)
      //
      //   Input:
      //      xi, eta, zeta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 75-by-1
      //      sdvals: vector of size 75-by-3
      //
      //     nodes_nat_coors = prism_75
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also prism_6, prism_18, prism_40, prism_gl_40, prism_gl_75
      ::sfe_sfuncs::prism_75_ncoords(&t_sfvals[0]);
      for (int32_T i{0}; i < 75; i++) {
        natcoords[3 * i] = t_sfvals[3 * i];
        natcoords[3 * i + 1] = t_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = t_sfvals[3 * i + 2];
      }
    } break;
    case 209: {
      real_T t_sfvals[225];
      natcoords.set_size(75, 3);
      // prism_gl_75 - Quartic prismatic element with Gauss-Lobatto nodes
      //     [sfvals,sdvals] = prism_gl_75(xi,eta,zeta)
      //
      //   Input:
      //      xi, eta, zeta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 75-by-1
      //      sdvals: vector of size 75-by-3
      //
      //     nodes_nat_coors = prism_fek_75
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also prism_6, prism_18, prism_40, prism_gl_40, prism_75
      ::sfe_sfuncs::prism_gl_75_ncoords(&t_sfvals[0]);
      for (int32_T i{0}; i < 75; i++) {
        natcoords[3 * i] = t_sfvals[3 * i];
        natcoords[3 * i + 1] = t_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = t_sfvals[3 * i + 2];
      }
    } break;
    case 210: {
      real_T t_sfvals[225];
      natcoords.set_size(75, 3);
      // prism_fek_75 - Quartic prismatic element with Fekete points
      //     [sfvals,sdvals] = prism_fek_75(xi,eta,zeta)
      //
      //   Input:
      //      xi, eta, zeta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 75-by-1
      //      sdvals: vector of size 75-by-3
      //
      //     nodes_nat_coors = prism_fek_75
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also prism_6, prism_18, prism_40, prism_gl_40, prism_75
      ::sfe_sfuncs::prism_fek_75_ncoords(&t_sfvals[0]);
      for (int32_T i{0}; i < 75; i++) {
        natcoords[3 * i] = t_sfvals[3 * i];
        natcoords[3 * i + 1] = t_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = t_sfvals[3 * i + 2];
      }
    } break;
    case 212: {
      real_T ab_sfvals[378];
      natcoords.set_size(126, 3);
      // prism_126 - Quintic prismatic element with equidistant nodes
      //     [sfvals,sdvals] = prism_126(xi,eta,zeta)
      //
      //   Input:
      //      xi, eta, zeta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 126-by-1
      //      sdvals: vector of size 126-by-3
      //
      //     nodes_nat_coors = prism_126
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also prism_6, prism_18, prism_40, prism_gl_40, prism_gl_75,
      //   prism_75
      //  If no input argument, return nodal positions
      ::sfe_sfuncs::prism_126_ncoords(&ab_sfvals[0]);
      for (int32_T i{0}; i < 126; i++) {
        natcoords[3 * i] = ab_sfvals[3 * i];
        natcoords[3 * i + 1] = ab_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = ab_sfvals[3 * i + 2];
      }
    } break;
    case 216: {
      real_T bb_sfvals[588];
      natcoords.set_size(196, 3);
      // prism_196 - Sextic prismatic element with equidistant nodes
      //     [sfvals,sdvals] = prism_196(xi,eta,zeta)
      //
      //   Input:
      //      xi, eta, zeta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 196-by-1
      //      sdvals: vector of size 196-by-3
      //
      //     nodes_nat_coors = prism_196
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also prism_6, prism_18, prism_40, prism_gl_40, prism_gl_75,
      //   prism_75
      //  If no input argument, return nodal positions
      ::sfe_sfuncs::prism_196_ncoords(&bb_sfvals[0]);
      for (int32_T i{0}; i < 196; i++) {
        natcoords[3 * i] = bb_sfvals[3 * i];
        natcoords[3 * i + 1] = bb_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = bb_sfvals[3 * i + 2];
      }
    } break;
    case 228: {
      real_T u_sfvals[24];
      natcoords.set_size(8, 3);
      // hexa_8 - Trilinear hexahedral element
      //     [sfvals,sdvals] = hexa_8(xi,eta,zeta)
      //
      //   Input:
      //      xi, eta, zeta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 8-by-1
      //      sdvals: vector of size 8-by-3
      //
      //     nodes_nat_coors = hexa_8
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also hexa_27, hexa_64, hexa_gl_64, hexa_125, hexa_gl_125
      ::sfe_sfuncs::hexa_8_ncoords(&u_sfvals[0]);
      for (int32_T i{0}; i < 8; i++) {
        natcoords[3 * i] = u_sfvals[3 * i];
        natcoords[3 * i + 1] = u_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = u_sfvals[3 * i + 2];
      }
    } break;
    case 232: {
      real_T v_sfvals[81];
      natcoords.set_size(27, 3);
      // hexa_27 - Triquadratic hexahedral element with equidistant nodes
      //     [sfvals,sdvals] = hexa_27(xi,eta,zeta)
      //
      //   Input:
      //      xi, eta, zeta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 27-by-1
      //      sdvals: vector of size 27-by-3
      //
      //     nodes_nat_coors = hexa_27
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also hexa_8, hexa_64, hexa_gl_64, hexa_125, hexa_gl_125
      ::sfe_sfuncs::hexa_27_ncoords(&v_sfvals[0]);
      for (int32_T i{0}; i < 27; i++) {
        natcoords[3 * i] = v_sfvals[3 * i];
        natcoords[3 * i + 1] = v_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = v_sfvals[3 * i + 2];
      }
    } break;
    case 236: {
      real_T w_sfvals[192];
      natcoords.set_size(64, 3);
      // hexa_64 - Tricubic hexahedral element with equidistant nodes
      //     [sfvals,sdvals] = hexa_64(xi,eta,zeta)
      //
      //   Input:
      //      xi, eta, zeta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 64-by-1
      //      sdvals: vector of size 64-by-3
      //
      //     nodes_nat_coors = hexa_64
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also hexa_8, hexa_27, hexa_gl_64, hexa_125, hexa_gl_125
      ::sfe_sfuncs::hexa_64_ncoords(&w_sfvals[0]);
      for (int32_T i{0}; i < 64; i++) {
        natcoords[3 * i] = w_sfvals[3 * i];
        natcoords[3 * i + 1] = w_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = w_sfvals[3 * i + 2];
      }
    } break;
    case 237: {
      real_T w_sfvals[192];
      natcoords.set_size(64, 3);
      // hexa_gl_64 - Tricubic hexahedral element with Gauss-Lobatto nodes
      //     [sfvals,sdvals] = hexa_gl_64(xi,eta,zeta)
      //
      //   Input:
      //      xi, eta, zeta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 64-by-1
      //      sdvals: vector of size 64-by-3
      //
      //     nodes_nat_coors = hexa_gl_64
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also hexa_8, hexa_27, hexa_64, hexa_125, hexa_gl_125
      ::sfe_sfuncs::hexa_gl_64_ncoords(&w_sfvals[0]);
      for (int32_T i{0}; i < 64; i++) {
        natcoords[3 * i] = w_sfvals[3 * i];
        natcoords[3 * i + 1] = w_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = w_sfvals[3 * i + 2];
      }
    } break;
    case 240: {
      real_T x_sfvals[375];
      natcoords.set_size(125, 3);
      // hexa_125 - Triquartic hexahedral element with equidistant points
      //     [sfvals,sdvals] = hexa_125(xi,eta,zeta)
      //
      //   Input:
      //      xi, eta, zeta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 125-by-1
      //      sdvals: vector of size 125-by-3
      //
      //     nodes_nat_coors = hexa_125
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also hexa_8, hexa_27, hexa_64, hexa_gl_64, hexa_gl_125, hexa_216,
      //   hexa_gl_216
      ::sfe_sfuncs::hexa_125_ncoords(&x_sfvals[0]);
      for (int32_T i{0}; i < 125; i++) {
        natcoords[3 * i] = x_sfvals[3 * i];
        natcoords[3 * i + 1] = x_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = x_sfvals[3 * i + 2];
      }
    } break;
    case 241: {
      real_T x_sfvals[375];
      natcoords.set_size(125, 3);
      // hexa_gl_125 - Triquartic hexahedral element with Gauss-Lobatto points
      //     [sfvals,sdvals] = hexa_gl_125(xi,eta,zeta)
      //
      //   Input:
      //      xi, eta, zeta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 125-by-1
      //      sdvals: vector of size 125-by-3
      //
      //     nodes_nat_coors = hexa_gl_125
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also hexa_8, hexa_27, hexa_64, hexa_gl_64, hexa_125
      ::sfe_sfuncs::hexa_gl_125_ncoords(&x_sfvals[0]);
      for (int32_T i{0}; i < 125; i++) {
        natcoords[3 * i] = x_sfvals[3 * i];
        natcoords[3 * i + 1] = x_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = x_sfvals[3 * i + 2];
      }
    } break;
    case 244: {
      real_T cb_sfvals[648];
      natcoords.set_size(216, 3);
      // hexa_216 - Triquintic hexahedral element with equidistant points
      //     [sfvals,sdvals] = hexa_216(xi,eta,zeta)
      //
      //   Input:
      //      xi, eta, zeta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 216-by-1
      //      sdvals: vector of size 216-by-3
      //
      //     nodes_nat_coors = hexa_216
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also hexa_8, hexa_27, hexa_64, hexa_gl_64, hexa_125, hexa_gl_125,
      //   hexa_gl_216
      ::sfe_sfuncs::hexa_216_ncoords(&cb_sfvals[0]);
      for (int32_T i{0}; i < 216; i++) {
        natcoords[3 * i] = cb_sfvals[3 * i];
        natcoords[3 * i + 1] = cb_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = cb_sfvals[3 * i + 2];
      }
    } break;
    case 245: {
      real_T cb_sfvals[648];
      natcoords.set_size(216, 3);
      // hexa_gl_216 - Triquintic hexahedral element with equidistant points
      //     [sfvals,sdvals] = hexa_gl_216(xi,eta,zeta)
      //
      //   Input:
      //      xi, eta, zeta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 216-by-1
      //      sdvals: vector of size 216-by-3
      //
      //     nodes_nat_coors = hexa_gl_216
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also hexa_8, hexa_27, hexa_64, hexa_gl_64, hexa_125, hexa_gl_125,
      //   hexa_216
      ::sfe_sfuncs::hexa_gl_216_ncoords(&cb_sfvals[0]);
      for (int32_T i{0}; i < 216; i++) {
        natcoords[3 * i] = cb_sfvals[3 * i];
        natcoords[3 * i + 1] = cb_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = cb_sfvals[3 * i + 2];
      }
    } break;
    case 248: {
      real_T y_sfvals[1029];
      natcoords.set_size(343, 3);
      // hexa_343 - Trisextic hexahedral element with equidistant points
      //     [sfvals,sdvals] = hexa_343(xi,eta,zeta)
      //
      //   Input:
      //      xi, eta, zeta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 343-by-1
      //      sdvals: vector of size 343-by-3
      //
      //     nodes_nat_coors = hexa_34
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also hexa_8, hexa_27, hexa_64, hexa_gl_64, hexa_125, hexa_gl_125,
      //   hexa_gl_343
      ::sfe_sfuncs::hexa_343_ncoords(&y_sfvals[0]);
      for (int32_T i{0}; i < 343; i++) {
        natcoords[3 * i] = y_sfvals[3 * i];
        natcoords[3 * i + 1] = y_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = y_sfvals[3 * i + 2];
      }
    } break;
    default: {
      real_T y_sfvals[1029];
      natcoords.set_size(343, 3);
      // hexa_gl_343 - Trisextic hexahedral element with equidistant points
      //     [sfvals,sdvals] = hexa_gl_343(xi,eta,zeta)
      //
      //   Input:
      //      xi, eta, zeta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 343-by-1
      //      sdvals: vector of size 343-by-3
      //
      //     nodes_nat_coors = hexa_gl_343
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also hexa_8, hexa_27, hexa_64, hexa_gl_64, hexa_125, hexa_gl_125,
      //   hexa_343
      ::sfe_sfuncs::hexa_gl_343_ncoords(&y_sfvals[0]);
      for (int32_T i{0}; i < 343; i++) {
        natcoords[3 * i] = y_sfvals[3 * i];
        natcoords[3 * i + 1] = y_sfvals[3 * i + 1];
        natcoords[3 * i + 2] = y_sfvals[3 * i + 2];
      }
    } break;
    }
  } break;
  }
}

static void prism_126(real_T xi, real_T eta, real_T zeta, real_T sfvals[126],
                      real_T sdvals[378])
{
  // prism_126 - Quintic prismatic element with equidistant nodes
  //     [sfvals,sdvals] = prism_126(xi,eta,zeta)
  //
  //   Input:
  //      xi, eta, zeta: range between 0 and 1.
  //   Output:
  //      sfvals: vector of size 126-by-1
  //      sdvals: vector of size 126-by-3
  //
  //     nodes_nat_coors = prism_126
  //   If no input argument, return natural coordinates of nodes
  //
  //   See also prism_6, prism_18, prism_40, prism_gl_40, prism_gl_75, prism_75
  ::sfe_sfuncs::prism_126_sfunc(xi, eta, zeta, &sfvals[0], &sdvals[0]);
}

static void prism_196(real_T xi, real_T eta, real_T zeta, real_T sfvals[196],
                      real_T sdvals[588])
{
  // prism_196 - Sextic prismatic element with equidistant nodes
  //     [sfvals,sdvals] = prism_196(xi,eta,zeta)
  //
  //   Input:
  //      xi, eta, zeta: range between 0 and 1.
  //   Output:
  //      sfvals: vector of size 196-by-1
  //      sdvals: vector of size 196-by-3
  //
  //     nodes_nat_coors = prism_196
  //   If no input argument, return natural coordinates of nodes
  //
  //   See also prism_6, prism_18, prism_40, prism_gl_40, prism_gl_75, prism_75
  ::sfe_sfuncs::prism_196_sfunc(xi, eta, zeta, &sfvals[0], &sdvals[0]);
}

static void prism_40(real_T xi, real_T eta, real_T zeta, real_T sfvals[40],
                     real_T sdvals[120])
{
  // prism_40 - Cubic prismatic element
  //     [sfvals,sdvals] = prism_40(xi,eta,zeta)
  //
  //   Input:
  //      xi, eta, zeta: range between 0 and 1.
  //   Output:
  //      sfvals: vector of size 40-by-1
  //      sdvals: vector of size 40-by-3
  //
  //     nodes_nat_coors = prism_40
  //   If no input argument, return natural coordinates of nodes
  //
  //   See also prism_6, prism_18, prism_gl_40, prism_75, prism_gl_75
  ::sfe_sfuncs::prism_40_sfunc(xi, eta, zeta, &sfvals[0], &sdvals[0]);
}

static void prism_75(real_T xi, real_T eta, real_T zeta, real_T sfvals[75],
                     real_T sdvals[225])
{
  // prism_75 - Quartic prismatic element with equidistant nodes
  //     [sfvals,sdvals] = prism_75(xi,eta,zeta)
  //
  //   Input:
  //      xi, eta, zeta: range between 0 and 1.
  //   Output:
  //      sfvals: vector of size 75-by-1
  //      sdvals: vector of size 75-by-3
  //
  //     nodes_nat_coors = prism_75
  //   If no input argument, return natural coordinates of nodes
  //
  //   See also prism_6, prism_18, prism_40, prism_gl_40, prism_gl_75
  ::sfe_sfuncs::prism_75_sfunc(xi, eta, zeta, &sfvals[0], &sdvals[0]);
}

static void prism_gl_126(real_T xi, real_T eta, real_T zeta, real_T sfvals[126],
                         real_T sdvals[378])
{
  // prism_gl_126 - Quintic prismatic element with equidistant nodes
  //     [sfvals,sdvals] = prism_gl_126(xi,eta,zeta)
  //
  //   Input:
  //      xi, eta, zeta: range between 0 and 1.
  //   Output:
  //      sfvals: vector of size 126-by-1
  //      sdvals: vector of size 126-by-3
  //
  //     nodes_nat_coors = prism_gl_126
  //
  //   If no input argument, return natural coordinates of nodes
  //
  //   See also prism_6, prism_18, prism_40, prism_gl_40, prism_gl_75, prism_75
  ::sfe_sfuncs::prism_gl_126_sfunc(xi, eta, zeta, &sfvals[0], &sdvals[0]);
}

static void prism_gl_40(real_T xi, real_T eta, real_T zeta, real_T sfvals[40],
                        real_T sdvals[120])
{
  // prism_gl_40 - Quadratic prismatic element with Gauss-Lobatto nodes
  //     [sfvals,sdvals] = prism_gl_40(xi,eta,zeta)
  //
  //   Input:
  //      xi, eta, zeta: range between 0 and 1.
  //   Output:
  //      sfvals: vector of size 40-by-1
  //      sdvals: vector of size 40-by-3
  //
  //     nodes_nat_coors = prism_40
  //   If no input argument, return natural coordinates of nodes
  //
  //   See also prism_6, prism_18, prism_gl_40, prism_75, prism_gl_75
  ::sfe_sfuncs::prism_gl_40_sfunc(xi, eta, zeta, &sfvals[0], &sdvals[0]);
}

static void prism_gl_75(real_T xi, real_T eta, real_T zeta, real_T sfvals[75],
                        real_T sdvals[225])
{
  // prism_gl_75 - Quartic prismatic element with Gauss-Lobatto nodes
  //     [sfvals,sdvals] = prism_gl_75(xi,eta,zeta)
  //
  //   Input:
  //      xi, eta, zeta: range between 0 and 1.
  //   Output:
  //      sfvals: vector of size 75-by-1
  //      sdvals: vector of size 75-by-3
  //
  //     nodes_nat_coors = prism_fek_75
  //   If no input argument, return natural coordinates of nodes
  //
  //   See also prism_6, prism_18, prism_40, prism_gl_40, prism_75
  ::sfe_sfuncs::prism_gl_75_sfunc(xi, eta, zeta, &sfvals[0], &sdvals[0]);
}

static void pyra_30(real_T xi, real_T eta, real_T zeta, real_T sfvals[30],
                    real_T sdvals[90])
{
  // pyra_30 - Compute shape functions and their derivatives of pyra_30
  //
  //     ncoords = pyra_30
  //     [sfvals,sdvals] = pyra_30(xi,eta,zeta)
  //
  // Parameters
  // ----------
  //     xi,eta: natural coordinates ranging between -1 and 1
  //     zeta: natural coordinate ranging between 0 and 1
  //
  // Returns
  // -------
  //     ncoords: natural coordinates of nodes if nargin==0
  //
  //                          OR
  //
  //     sfvals: vector of size 30-by-1
  //     sdvals: vector of size 30-by-3
  // Note
  // ----
  //  The shape functions are based on Bedrosian rational basis functions.
  ::sfe_sfuncs::pyra_30_sfunc(xi, eta, zeta, &sfvals[0], &sdvals[0]);
}

static void pyra_55(real_T xi, real_T eta, real_T zeta, real_T sfvals[55],
                    real_T sdvals[165])
{
  // pyra_55 - Compute shape functions and their derivatives of pyra_55
  //
  //     ncoords = pyra_55
  //     [sfvals,sdvals] = pyra_55(xi,eta,zeta)
  //
  // Parameters
  // ----------
  //     xi,eta: natural coordinates ranging between -1 and 1
  //     zeta: natural coordinate ranging between 0 and 1
  //
  // Returns
  // -------
  //     ncoords: natural coordinates of nodes if nargin==0
  //
  //                          OR
  //
  //     sfvals: vector of size 55-by-1
  //     sdvals: vector of size 55-by-3
  // Note
  // ----
  //  The shape functions are based on Bedrosian rational basis functions.
  ::sfe_sfuncs::pyra_55_sfunc(xi, eta, zeta, &sfvals[0], &sdvals[0]);
}

static void pyra_gl_30(real_T xi, real_T eta, real_T zeta, real_T sfvals[30],
                       real_T sdvals[90])
{
  // pyra_gl_30 - Compute shape functions and their derivatives of pyra_gl_30
  //
  //     ncoords = pyra_gl_30
  //     [sfvals,sdvals] = pyra_gl_30(xi,eta,zeta)
  //
  // Parameters
  // ----------
  //     xi,eta: natural coordinates ranging between -1 and 1
  //     zeta: natural coordinate ranging between 0 and 1
  //
  // Returns
  // -------
  //     ncoords: natural coordinates of nodes if nargin==0
  //
  //                          OR
  //
  //     sfvals: vector of size 30-by-1
  //     sdvals: vector of size 30-by-3
  // Note
  // ----
  //  The shape functions are based on Bedrosian rational basis functions.
  ::sfe_sfuncs::pyra_gl_30_sfunc(xi, eta, zeta, &sfvals[0], &sdvals[0]);
}

static void pyra_gl_55(real_T xi, real_T eta, real_T zeta, real_T sfvals[55],
                       real_T sdvals[165])
{
  // pyra_gl_55 - Compute shape functions and their derivatives of pyra_gl_55
  //
  //     ncoords = pyra_gl_55
  //     [sfvals,sdvals] = pyra_gl_55(xi,eta,zeta)
  //
  // Parameters
  // ----------
  //     xi,eta: natural coordinates ranging between -1 and 1
  //     zeta: natural coordinate ranging between 0 and 1
  //
  // Returns
  // -------
  //     ncoords: natural coordinates of nodes if nargin==0
  //
  //                          OR
  //
  //     sfvals: vector of size 55-by-1
  //     sdvals: vector of size 55-by-3
  // Note
  // ----
  //  The shape functions are based on Bedrosian rational basis functions.
  ::sfe_sfuncs::pyra_gl_55_sfunc(xi, eta, zeta, &sfvals[0], &sdvals[0]);
}

static void pyra_quadrules(int32_T degree, ::coder::array<real_T, 2U> &cs,
                           ::coder::array<real_T, 1U> &ws)
{
  //  pyra_quadrules - Obtain quadrature points and weights of a pyramidal
  //  element.
  //
  //     [cs, ws] = pyra_quadrules
  //     [cs, ws] = pyra_quadrules(degree)
  //
  //  Parameters
  //  ----------
  //   degree: the desired degree of quadrature rule. Default is 1.
  //
  //  Returns
  //  -------
  //   cs: the natural coordinates of quadrature points (nqp-by-3)
  //   ws: the weights of quadrature points (nqp-by-1)
  //
  //  Notes
  //  -----
  //   The natural coordinates of xi and eta are between -1 and 1 and
  //   that of zeta is between 0 and 1.
  //
  //  Reference: A compendium of FEM integration formulas for symbolic work,
  //  Engineering Computation, Volume 21, Number 8, 2004, pages 867-890.
  //
  //  https://people.sc.fsu.edu/~jburkardt/datasets/quadrature_rules_pyramid/quadrature_rules_pyramid.html
  //
  //  See also bar_quadrules, tri_quadrules, quad_quadrules, tet_quadrules
  //  prism_quadrules, hexa_quadrules
  if (degree <= 1) {
    int32_T nqp;
    nqp = ::sfe_qrules::pyra_deg1_qrule();
    cs.set_size(nqp, 3);
    ws.set_size(nqp);
    ::sfe_qrules::pyra_deg1_qrule(&cs[0], &(ws.data())[0]);
  } else if (degree <= 2) {
    int32_T nqp;
    nqp = ::sfe_qrules::pyra_deg2_qrule();
    cs.set_size(nqp, 3);
    ws.set_size(nqp);
    ::sfe_qrules::pyra_deg2_qrule(&cs[0], &(ws.data())[0]);
  } else if (degree <= 3) {
    int32_T nqp;
    nqp = ::sfe_qrules::pyra_deg3_qrule();
    cs.set_size(nqp, 3);
    ws.set_size(nqp);
    ::sfe_qrules::pyra_deg3_qrule(&cs[0], &(ws.data())[0]);
  } else if (degree <= 5) {
    int32_T nqp;
    //  m2cAssert  Throw error if condition false at runtime
    //
    //    m2cAssert(cond)
    //    m2cAssert(cond,msg)
    //    m2cAssert(cond,msg,A1,...,An)
    //    m2cAssert(cond,errID,msg)
    //    m2cAssert(cond,errID,msg,A1,...,An)
    //
    //  The interface of `m2cAssert` is compatible with MATLAB's built-in
    //  `assert`,  but it generates runtime assertion instead of compile-time
    //  assertion.
    //
    //  Note
    //  ----
    //  The MATLAB built-in `assert` is mostly used for compile-time error
    //  checking, and it has no effect for runtime error checking in LIB mode.
    //  Use `m2cAssert` instead for runtime error checking. Like the built-in
    //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
    //  into a code-generation-time character string. If you want to use both
    //  code-generation-time and runtime assertions, it is recommended to put
    //  `m2cAssert` before the built-in `assert`.
    //
    //  See also assert, m2cError, m2cWarning
    m2cAssert(true, "Only support up to degree 5");
    nqp = ::sfe_qrules::pyra_deg5_qrule();
    cs.set_size(nqp, 3);
    ws.set_size(nqp);
    ::sfe_qrules::pyra_deg5_qrule(&cs[0], &(ws.data())[0]);
  } else if (degree <= 6) {
    int32_T nqp;
    nqp = ::sfe_qrules::pyra_deg6_qrule();
    cs.set_size(nqp, 3);
    ws.set_size(nqp);
    ::sfe_qrules::pyra_deg6_qrule(&cs[0], &(ws.data())[0]);
  } else if (degree <= 7) {
    int32_T nqp;
    nqp = ::sfe_qrules::pyra_deg7_qrule();
    cs.set_size(nqp, 3);
    ws.set_size(nqp);
    ::sfe_qrules::pyra_deg7_qrule(&cs[0], &(ws.data())[0]);
  } else if (degree <= 9) {
    int32_T nqp;
    //  m2cAssert  Throw error if condition false at runtime
    //
    //    m2cAssert(cond)
    //    m2cAssert(cond,msg)
    //    m2cAssert(cond,msg,A1,...,An)
    //    m2cAssert(cond,errID,msg)
    //    m2cAssert(cond,errID,msg,A1,...,An)
    //
    //  The interface of `m2cAssert` is compatible with MATLAB's built-in
    //  `assert`,  but it generates runtime assertion instead of compile-time
    //  assertion.
    //
    //  Note
    //  ----
    //  The MATLAB built-in `assert` is mostly used for compile-time error
    //  checking, and it has no effect for runtime error checking in LIB mode.
    //  Use `m2cAssert` instead for runtime error checking. Like the built-in
    //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
    //  into a code-generation-time character string. If you want to use both
    //  code-generation-time and runtime assertions, it is recommended to put
    //  `m2cAssert` before the built-in `assert`.
    //
    //  See also assert, m2cError, m2cWarning
    m2cAssert(true, "Only support up to degree 9");
    nqp = ::sfe_qrules::pyra_deg9_qrule();
    cs.set_size(nqp, 3);
    ws.set_size(nqp);
    ::sfe_qrules::pyra_deg9_qrule(&cs[0], &(ws.data())[0]);
  } else if (degree <= 11) {
    int32_T nqp;
    nqp = ::sfe_qrules::pyra_deg11_qrule();
    cs.set_size(nqp, 3);
    ws.set_size(nqp);
    ::sfe_qrules::pyra_deg11_qrule(&cs[0], &(ws.data())[0]);
  } else {
    int32_T nqp;
    if (degree > 13) {
      //  m2cWarning  Display warning message
      //
      //     m2cWarning(msg)
      //     m2cWarning(msg,A1,...,An)
      //     m2cWarning(warnID,___)
      //
      //  This function performs similar to MATLAB's built-in `warning` but it
      //  supports code generation in both MEX and LIB mode.
      //
      //  Notes
      //  -----
      //  The format must be a constant string during code-generation time.
      //
      //  See also warning, m2cError, m2cAssert
      m2cWarnMsgIdAndTxt("pyra_quadrules:UnsupportedDegree",
                         "Only support up to degree 13");
    }
    nqp = ::sfe_qrules::pyra_deg13_qrule();
    cs.set_size(nqp, 3);
    ws.set_size(nqp);
    ::sfe_qrules::pyra_deg13_qrule(&cs[0], &(ws.data())[0]);
  }
}

static void quad_25(real_T xi, real_T eta, real_T sfvals[25], real_T sdvals[50])
{
  // quad_25 - Biquartic quadrilateral element with equidistant points
  //     [sfvals,sdvals] = quad_25(xi,eta)
  //
  //   Input:
  //      xi, eta: range between 0 and 1.
  //   Output:
  //      sfvals: vector of size 25-by-1
  //      sdvals: vector of size 25-by-2
  //
  //     nodes_nat_coors = quad_25
  //   If no input argument, return natural coordinates of nodes
  //
  //   See also quad_4, quad_9, quad_16, quad_gl_16, quad_gl_25
  ::sfe_sfuncs::quad_25_sfunc(xi, eta, &sfvals[0], &sdvals[0]);
}

static void quad_36(real_T xi, real_T eta, real_T sfvals[36], real_T sdvals[72])
{
  // quad_36   Biquintic quadrilateral element with equidistant points
  //     [sfvals,sdvals] = quad_36(xi,eta)
  //
  //   Input:
  //      xi, eta: range between 0 and 1.
  //   Output:
  //      sfvals: vector of size 25-by-1
  //      sdvals: vector of size 25-by-2
  //
  //     nodes_nat_coors = quad_36
  //   If no input argument, return natural coordinates of nodes
  //
  //   See also quad_4, quad_9, quad_16, quad_gl_16, quad_gl_25
  ::sfe_sfuncs::quad_36_sfunc(xi, eta, &sfvals[0], &sdvals[0]);
}

static void quad_49(real_T xi, real_T eta, real_T sfvals[49], real_T sdvals[98])
{
  // quad_49 - Bisextic quadrilateral element with equidistant points
  //     [sfvals,sdvals] = quad_49(xi,eta)
  //
  //   Input:
  //      xi, eta: range between 0 and 1.
  //   Output:
  //      sfvals: vector of size 25-by-1
  //      sdvals: vector of size 25-by-2
  //
  //     nodes_nat_coors = quad_49
  //   If no input argument, return natural coordinates of nodes
  //
  //   See also quad_4, quad_9, quad_16, quad_gl_16, quad_gl_25
  ::sfe_sfuncs::quad_49_sfunc(xi, eta, &sfvals[0], &sdvals[0]);
}

static void quad_gl_25(real_T xi, real_T eta, real_T sfvals[25],
                       real_T sdvals[50])
{
  // quad_gl_25 - Biquartic quadrilateral element with Gauss-Lobatto points
  //     [sfvals,sdvals] = quad_gl_25(xi,eta)
  //
  //   Input:
  //      xi, eta: range between 0 and 1.
  //   Output:
  //      sfvals: vector of size 25-by-1
  //      sdvals: vector of size 25-by-2
  //
  //     nodes_nat_coors = quad_gl_25
  //   If no input argument, return natural coordinates of nodes
  //
  //   See also quad_4, quad_9, quad_16, quad_gl_16, quad_25
  ::sfe_sfuncs::quad_gl_25_sfunc(xi, eta, &sfvals[0], &sdvals[0]);
}

static void quad_gl_36(real_T xi, real_T eta, real_T sfvals[36],
                       real_T sdvals[72])
{
  // quad_gl_36 - Biquintic quadrilateral element with equidistant points
  //     [sfvals,sdvals] = quad_gl_36(xi,eta)
  //
  //   Input:
  //      xi, eta: range between 0 and 1.
  //   Output:
  //      sfvals: vector of size 36-by-1
  //      sdvals: vector of size 36-by-2
  //
  //     nodes_nat_coors = quad_gl_36
  //   If no input argument, return natural coordinates of nodes
  //
  //   See also quad_4, quad_9, quad_16, quad_gl_16, quad_gl_25
  ::sfe_sfuncs::quad_gl_36_sfunc(xi, eta, &sfvals[0], &sdvals[0]);
}

static void quad_gl_49(real_T xi, real_T eta, real_T sfvals[49],
                       real_T sdvals[98])
{
  // quad_gl_49 - Bisextic quadrilateral element with equidistant points
  //     [sfvals,sdvals] = quad_gl_49(xi,eta)
  //
  //   Input:
  //      xi, eta: range between 0 and 1.
  //   Output:
  //      sfvals: vector of size 49-by-1
  //      sdvals: vector of size 49-by-2
  //
  //     nodes_nat_coors = quad_gl_49
  //   If no input argument, return natural coordinates of nodes
  //
  //   See also quad_4, quad_9, quad_16, quad_gl_16, quad_gl_25
  ::sfe_sfuncs::quad_gl_49_sfunc(xi, eta, &sfvals[0], &sdvals[0]);
}

static void sfe1_tabulate_shapefuncs(int32_T etype,
                                     const ::coder::array<real_T, 2U> &cs,
                                     ::coder::array<real_T, 2U> &sfvals,
                                     ::coder::array<real_T, 3U> &sdvals)
{
  int32_T i;
  int32_T nqp;
  //  Tabulate shape functions and derivative at given points.
  //
  //    [sfvals, sdvals] = sfe1_tabulate_shapefuncs(etype, cs)
  //
  //  Parameters
  //  ----------
  //    etype: element type ID.
  //    cs: local coordinates of quadrature points.
  //
  //  Returns
  //  -------
  //    sfvals: tabulation of shape functions at the given points.
  //    sdvals: tabulation of derivatives at the given points.
  //
  //  See also sfe2_tabulate_shapefuncs, sfe3_tabulate_shapefuncs
  nqp = cs.size(0) - 1;
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  i = iv[etype - 1];
  sfvals.set_size(cs.size(0), i);
  sdvals.set_size(cs.size(0), i, cs.size(1));
  // obtain_elemnodepos - Decode nodal position types, e.g., equidistance, GL
  //
  //    postype = obtain_elemnodepos(etype)
  //
  //  RETURNS
  //  -------
  //    postype:    Position type tag:
  //                    0: equidistance
  //                    1: GL
  //                    2: ...
  //
  //  See also obtain_elemdegree
  //  postype = etype&0b11
  if ((etype & 3) == 0) {
    switch (etype) {
    case 36: {
      int32_T i1;
      boolean_T b;
      boolean_T b1;
      b = true;
      b1 = ((cs.size(1) <= 0) || (cs.size(0) <= 0));
      i = cs.size(1) * cs.size(0);
      i1 = 0;
      for (int32_T q{0}; q <= nqp; q++) {
        real_T N[2];
        real_T deriv[2];
        if (b1 || (q >= i)) {
          i1 = 0;
          b = true;
        } else if (b) {
          b = false;
          i1 = q % cs.size(0) * cs.size(1) + q / cs.size(0);
        } else {
          int32_T i2;
          i2 = cs.size(1) * cs.size(0) - 1;
          if (i1 > MAX_int32_T - cs.size(1)) {
            i1 = q % cs.size(0) * cs.size(1) + q / cs.size(0);
          } else {
            i1 += cs.size(1);
            if (i1 > i2) {
              i1 -= i2;
            }
          }
        }
        // bar_2 - Compute shape functions and their derivatives of bar_2
        //
        //     ncoords = bar_2
        //     [sfvals,sdvals] = bar_2(xi)
        //
        // Parameters
        // ----------
        //     xi: natural coordinates ranging between 0 and 1
        //
        // Returns
        // -------
        //     ncoords: natural coordinates of nodes if nargin==0
        //
        //                          OR
        //
        //     sfvals: vector of size 2-by-1
        //     sdvals: vector of size 2-by-1
        ::sfe_sfuncs::bar_2_sfunc(cs[i1], &N[0], &deriv[0]);
        sfvals[sfvals.size(1) * q] = N[0];
        sdvals[sdvals.size(2) * sdvals.size(1) * q] = deriv[0];
        sfvals[sfvals.size(1) * q + 1] = N[1];
        sdvals[sdvals.size(2) + sdvals.size(2) * sdvals.size(1) * q] = deriv[1];
      }
    } break;
    case 40: {
      int32_T i1;
      boolean_T b;
      boolean_T b1;
      b = true;
      b1 = ((cs.size(1) <= 0) || (cs.size(0) <= 0));
      i = cs.size(1) * cs.size(0);
      i1 = 0;
      for (int32_T q{0}; q <= nqp; q++) {
        real_T b_N[3];
        real_T b_deriv[3];
        if (b1 || (q >= i)) {
          i1 = 0;
          b = true;
        } else if (b) {
          b = false;
          i1 = q % cs.size(0) * cs.size(1) + q / cs.size(0);
        } else {
          int32_T i2;
          i2 = cs.size(1) * cs.size(0) - 1;
          if (i1 > MAX_int32_T - cs.size(1)) {
            i1 = q % cs.size(0) * cs.size(1) + q / cs.size(0);
          } else {
            i1 += cs.size(1);
            if (i1 > i2) {
              i1 -= i2;
            }
          }
        }
        // bar_3 - Compute shape functions and their derivatives of bar_3
        //
        //     ncoords = bar_3
        //     [sfvals,sdvals] = bar_3(xi)
        //
        // Parameters
        // ----------
        //     xi: natural coordinates ranging between 0 and 1
        //
        // Returns
        // -------
        //     ncoords: natural coordinates of nodes if nargin==0
        //
        //                          OR
        //
        //     sfvals: vector of size 3-by-1
        //     sdvals: vector of size 3-by-1
        ::sfe_sfuncs::bar_3_sfunc(cs[i1], &b_N[0], &b_deriv[0]);
        sfvals[sfvals.size(1) * q] = b_N[0];
        sdvals[sdvals.size(2) * sdvals.size(1) * q] = b_deriv[0];
        sfvals[sfvals.size(1) * q + 1] = b_N[1];
        sdvals[sdvals.size(2) + sdvals.size(2) * sdvals.size(1) * q] =
            b_deriv[1];
        sfvals[sfvals.size(1) * q + 2] = b_N[2];
        sdvals[sdvals.size(2) * 2 + sdvals.size(2) * sdvals.size(1) * q] =
            b_deriv[2];
      }
    } break;
    case 44: {
      int32_T i1;
      boolean_T b;
      boolean_T b1;
      b = true;
      b1 = ((cs.size(1) <= 0) || (cs.size(0) <= 0));
      i = cs.size(1) * cs.size(0);
      i1 = 0;
      for (int32_T q{0}; q <= nqp; q++) {
        real_T c_N[4];
        real_T c_deriv[4];
        if (b1 || (q >= i)) {
          i1 = 0;
          b = true;
        } else if (b) {
          b = false;
          i1 = q % cs.size(0) * cs.size(1) + q / cs.size(0);
        } else {
          int32_T i2;
          i2 = cs.size(1) * cs.size(0) - 1;
          if (i1 > MAX_int32_T - cs.size(1)) {
            i1 = q % cs.size(0) * cs.size(1) + q / cs.size(0);
          } else {
            i1 += cs.size(1);
            if (i1 > i2) {
              i1 -= i2;
            }
          }
        }
        // bar_4 - Compute shape functions and their derivatives of bar_4
        //
        //     ncoords = bar_4
        //     [sfvals,sdvals] = bar_4(xi)
        //
        // Parameters
        // ----------
        //     xi: natural coordinates ranging between 0 and 1
        //
        // Returns
        // -------
        //     ncoords: natural coordinates of nodes if nargin==0
        //
        //                          OR
        //
        //     sfvals: vector of size 4-by-1
        //     sdvals: vector of size 4-by-1
        ::sfe_sfuncs::bar_4_sfunc(cs[i1], &c_N[0], &c_deriv[0]);
        sfvals[sfvals.size(1) * q] = c_N[0];
        sdvals[sdvals.size(2) * sdvals.size(1) * q] = c_deriv[0];
        sfvals[sfvals.size(1) * q + 1] = c_N[1];
        sdvals[sdvals.size(2) + sdvals.size(2) * sdvals.size(1) * q] =
            c_deriv[1];
        sfvals[sfvals.size(1) * q + 2] = c_N[2];
        sdvals[sdvals.size(2) * 2 + sdvals.size(2) * sdvals.size(1) * q] =
            c_deriv[2];
        sfvals[sfvals.size(1) * q + 3] = c_N[3];
        sdvals[sdvals.size(2) * 3 + sdvals.size(2) * sdvals.size(1) * q] =
            c_deriv[3];
      }
    } break;
    case 48: {
      int32_T i1;
      boolean_T b;
      boolean_T b1;
      b = true;
      b1 = ((cs.size(1) <= 0) || (cs.size(0) <= 0));
      i = cs.size(1) * cs.size(0);
      i1 = 0;
      for (int32_T q{0}; q <= nqp; q++) {
        real_T d_N[5];
        real_T d_deriv[5];
        if (b1 || (q >= i)) {
          i1 = 0;
          b = true;
        } else if (b) {
          b = false;
          i1 = q % cs.size(0) * cs.size(1) + q / cs.size(0);
        } else {
          int32_T i2;
          i2 = cs.size(1) * cs.size(0) - 1;
          if (i1 > MAX_int32_T - cs.size(1)) {
            i1 = q % cs.size(0) * cs.size(1) + q / cs.size(0);
          } else {
            i1 += cs.size(1);
            if (i1 > i2) {
              i1 -= i2;
            }
          }
        }
        // bar_5 - Compute shape functions and their derivatives of bar_5
        //
        //     ncoords = bar_5
        //     [sfvals,sdvals] = bar_5(xi)
        //
        // Parameters
        // ----------
        //     xi: natural coordinates ranging between 0 and 1
        //
        // Returns
        // -------
        //     ncoords: natural coordinates of nodes if nargin==0
        //
        //                          OR
        //
        //     sfvals: vector of size 5-by-1
        //     sdvals: vector of size 5-by-1
        ::sfe_sfuncs::bar_5_sfunc(cs[i1], &d_N[0], &d_deriv[0]);
        sfvals[sfvals.size(1) * q] = d_N[0];
        sdvals[sdvals.size(2) * sdvals.size(1) * q] = d_deriv[0];
        sfvals[sfvals.size(1) * q + 1] = d_N[1];
        sdvals[sdvals.size(2) + sdvals.size(2) * sdvals.size(1) * q] =
            d_deriv[1];
        sfvals[sfvals.size(1) * q + 2] = d_N[2];
        sdvals[sdvals.size(2) * 2 + sdvals.size(2) * sdvals.size(1) * q] =
            d_deriv[2];
        sfvals[sfvals.size(1) * q + 3] = d_N[3];
        sdvals[sdvals.size(2) * 3 + sdvals.size(2) * sdvals.size(1) * q] =
            d_deriv[3];
        sfvals[sfvals.size(1) * q + 4] = d_N[4];
        sdvals[sdvals.size(2) * 4 + sdvals.size(2) * sdvals.size(1) * q] =
            d_deriv[4];
      }
    } break;
    case 52: {
      int32_T i1;
      boolean_T b;
      boolean_T b1;
      b = true;
      b1 = ((cs.size(1) <= 0) || (cs.size(0) <= 0));
      i = cs.size(1) * cs.size(0);
      i1 = 0;
      for (int32_T q{0}; q <= nqp; q++) {
        real_T e_N[6];
        real_T e_deriv[6];
        if (b1 || (q >= i)) {
          i1 = 0;
          b = true;
        } else if (b) {
          b = false;
          i1 = q % cs.size(0) * cs.size(1) + q / cs.size(0);
        } else {
          int32_T i2;
          i2 = cs.size(1) * cs.size(0) - 1;
          if (i1 > MAX_int32_T - cs.size(1)) {
            i1 = q % cs.size(0) * cs.size(1) + q / cs.size(0);
          } else {
            i1 += cs.size(1);
            if (i1 > i2) {
              i1 -= i2;
            }
          }
        }
        // bar_6 - Compute shape functions and their derivatives of bar_6
        //
        //     ncoords = bar_6
        //     [sfvals,sdvals] = bar_6(xi)
        //
        // Parameters
        // ----------
        //     xi: natural coordinates ranging between 0 and 1
        //
        // Returns
        // -------
        //     ncoords: natural coordinates of nodes if nargin==0
        //
        //                          OR
        //
        //     sfvals: vector of size 6-by-1
        //     sdvals: vector of size 6-by-1
        ::sfe_sfuncs::bar_6_sfunc(cs[i1], &e_N[0], &e_deriv[0]);
        sfvals[sfvals.size(1) * q] = e_N[0];
        sdvals[sdvals.size(2) * sdvals.size(1) * q] = e_deriv[0];
        sfvals[sfvals.size(1) * q + 1] = e_N[1];
        sdvals[sdvals.size(2) + sdvals.size(2) * sdvals.size(1) * q] =
            e_deriv[1];
        sfvals[sfvals.size(1) * q + 2] = e_N[2];
        sdvals[sdvals.size(2) * 2 + sdvals.size(2) * sdvals.size(1) * q] =
            e_deriv[2];
        sfvals[sfvals.size(1) * q + 3] = e_N[3];
        sdvals[sdvals.size(2) * 3 + sdvals.size(2) * sdvals.size(1) * q] =
            e_deriv[3];
        sfvals[sfvals.size(1) * q + 4] = e_N[4];
        sdvals[sdvals.size(2) * 4 + sdvals.size(2) * sdvals.size(1) * q] =
            e_deriv[4];
        sfvals[sfvals.size(1) * q + 5] = e_N[5];
        sdvals[sdvals.size(2) * 5 + sdvals.size(2) * sdvals.size(1) * q] =
            e_deriv[5];
      }
    } break;
    default: {
      int32_T i1;
      boolean_T b;
      boolean_T b1;
      //  m2cAssert  Throw error if condition false at runtime
      //
      //    m2cAssert(cond)
      //    m2cAssert(cond,msg)
      //    m2cAssert(cond,msg,A1,...,An)
      //    m2cAssert(cond,errID,msg)
      //    m2cAssert(cond,errID,msg,A1,...,An)
      //
      //  The interface of `m2cAssert` is compatible with MATLAB's built-in
      //  `assert`,  but it generates runtime assertion instead of compile-time
      //  assertion.
      //
      //  Note
      //  ----
      //  The MATLAB built-in `assert` is mostly used for compile-time error
      //  checking, and it has no effect for runtime error checking in LIB mode.
      //  Use `m2cAssert` instead for runtime error checking. Like the built-in
      //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
      //  into a code-generation-time character string. If you want to use both
      //  code-generation-time and runtime assertions, it is recommended to put
      //  `m2cAssert` before the built-in `assert`.
      //
      //  See also assert, m2cError, m2cWarning
      m2cAssert(etype == 56, "Only support up to sextic.");
      b = true;
      b1 = ((cs.size(1) <= 0) || (cs.size(0) <= 0));
      i = cs.size(1) * cs.size(0);
      i1 = 0;
      for (int32_T q{0}; q <= nqp; q++) {
        real_T f_N[7];
        real_T f_deriv[7];
        if (b1 || (q >= i)) {
          i1 = 0;
          b = true;
        } else if (b) {
          b = false;
          i1 = q % cs.size(0) * cs.size(1) + q / cs.size(0);
        } else {
          int32_T i2;
          i2 = cs.size(1) * cs.size(0) - 1;
          if (i1 > MAX_int32_T - cs.size(1)) {
            i1 = q % cs.size(0) * cs.size(1) + q / cs.size(0);
          } else {
            i1 += cs.size(1);
            if (i1 > i2) {
              i1 -= i2;
            }
          }
        }
        // bar_7 - Compute shape functions and their derivatives of bar_7
        //
        //     ncoords = bar_7
        //     [sfvals,sdvals] = bar_7(xi)
        //
        // Parameters
        // ----------
        //     xi: natural coordinates ranging between 0 and 1
        //
        // Returns
        // -------
        //     ncoords: natural coordinates of nodes if nargin==0
        //
        //                          OR
        //
        //     sfvals: vector of size 7-by-1
        //     sdvals: vector of size 7-by-1
        ::sfe_sfuncs::bar_7_sfunc(cs[i1], &f_N[0], &f_deriv[0]);
        sfvals[sfvals.size(1) * q] = f_N[0];
        sdvals[sdvals.size(2) * sdvals.size(1) * q] = f_deriv[0];
        sfvals[sfvals.size(1) * q + 1] = f_N[1];
        sdvals[sdvals.size(2) + sdvals.size(2) * sdvals.size(1) * q] =
            f_deriv[1];
        sfvals[sfvals.size(1) * q + 2] = f_N[2];
        sdvals[sdvals.size(2) * 2 + sdvals.size(2) * sdvals.size(1) * q] =
            f_deriv[2];
        sfvals[sfvals.size(1) * q + 3] = f_N[3];
        sdvals[sdvals.size(2) * 3 + sdvals.size(2) * sdvals.size(1) * q] =
            f_deriv[3];
        sfvals[sfvals.size(1) * q + 4] = f_N[4];
        sdvals[sdvals.size(2) * 4 + sdvals.size(2) * sdvals.size(1) * q] =
            f_deriv[4];
        sfvals[sfvals.size(1) * q + 5] = f_N[5];
        sdvals[sdvals.size(2) * 5 + sdvals.size(2) * sdvals.size(1) * q] =
            f_deriv[5];
        sfvals[sfvals.size(1) * q + 6] = f_N[6];
        sdvals[sdvals.size(2) * 6 + sdvals.size(2) * sdvals.size(1) * q] =
            f_deriv[6];
      }
    } break;
    }
  } else {
    //  GL
    switch (etype) {
    case 45: {
      int32_T i1;
      boolean_T b;
      boolean_T b1;
      b = true;
      b1 = ((cs.size(1) <= 0) || (cs.size(0) <= 0));
      i = cs.size(1) * cs.size(0);
      i1 = 0;
      for (int32_T q{0}; q <= nqp; q++) {
        real_T c_N[4];
        real_T c_deriv[4];
        if (b1 || (q >= i)) {
          i1 = 0;
          b = true;
        } else if (b) {
          b = false;
          i1 = q % cs.size(0) * cs.size(1) + q / cs.size(0);
        } else {
          int32_T i2;
          i2 = cs.size(1) * cs.size(0) - 1;
          if (i1 > MAX_int32_T - cs.size(1)) {
            i1 = q % cs.size(0) * cs.size(1) + q / cs.size(0);
          } else {
            i1 += cs.size(1);
            if (i1 > i2) {
              i1 -= i2;
            }
          }
        }
        // bar_gl_4 - Compute shape functions and their derivatives of bar_gl_4
        //
        //     ncoords = bar_gl_4
        //     [sfvals,sdvals] = bar_gl_4(xi)
        //
        // Parameters
        // ----------
        //     xi: natural coordinates ranging between 0 and 1
        //
        // Returns
        // -------
        //     ncoords: natural coordinates of nodes if nargin==0
        //
        //                          OR
        //
        //     sfvals: vector of size 4-by-1
        //     sdvals: vector of size 4-by-1
        ::sfe_sfuncs::bar_gl_4_sfunc(cs[i1], &c_N[0], &c_deriv[0]);
        sfvals[sfvals.size(1) * q] = c_N[0];
        sdvals[sdvals.size(2) * sdvals.size(1) * q] = c_deriv[0];
        sfvals[sfvals.size(1) * q + 1] = c_N[1];
        sdvals[sdvals.size(2) + sdvals.size(2) * sdvals.size(1) * q] =
            c_deriv[1];
        sfvals[sfvals.size(1) * q + 2] = c_N[2];
        sdvals[sdvals.size(2) * 2 + sdvals.size(2) * sdvals.size(1) * q] =
            c_deriv[2];
        sfvals[sfvals.size(1) * q + 3] = c_N[3];
        sdvals[sdvals.size(2) * 3 + sdvals.size(2) * sdvals.size(1) * q] =
            c_deriv[3];
      }
    } break;
    case 49: {
      int32_T i1;
      boolean_T b;
      boolean_T b1;
      b = true;
      b1 = ((cs.size(1) <= 0) || (cs.size(0) <= 0));
      i = cs.size(1) * cs.size(0);
      i1 = 0;
      for (int32_T q{0}; q <= nqp; q++) {
        real_T d_N[5];
        real_T d_deriv[5];
        if (b1 || (q >= i)) {
          i1 = 0;
          b = true;
        } else if (b) {
          b = false;
          i1 = q % cs.size(0) * cs.size(1) + q / cs.size(0);
        } else {
          int32_T i2;
          i2 = cs.size(1) * cs.size(0) - 1;
          if (i1 > MAX_int32_T - cs.size(1)) {
            i1 = q % cs.size(0) * cs.size(1) + q / cs.size(0);
          } else {
            i1 += cs.size(1);
            if (i1 > i2) {
              i1 -= i2;
            }
          }
        }
        // bar_gl_5 - Compute shape functions and their derivatives of bar_gl_5
        //
        //     ncoords = bar_gl_5
        //     [sfvals,sdvals] = bar_gl_5(xi)
        //
        // Parameters
        // ----------
        //     xi: natural coordinates ranging between 0 and 1
        //
        // Returns
        // -------
        //     ncoords: natural coordinates of nodes if nargin==0
        //
        //                          OR
        //
        //     sfvals: vector of size 5-by-1
        //     sdvals: vector of size 5-by-1
        ::sfe_sfuncs::bar_gl_5_sfunc(cs[i1], &d_N[0], &d_deriv[0]);
        sfvals[sfvals.size(1) * q] = d_N[0];
        sdvals[sdvals.size(2) * sdvals.size(1) * q] = d_deriv[0];
        sfvals[sfvals.size(1) * q + 1] = d_N[1];
        sdvals[sdvals.size(2) + sdvals.size(2) * sdvals.size(1) * q] =
            d_deriv[1];
        sfvals[sfvals.size(1) * q + 2] = d_N[2];
        sdvals[sdvals.size(2) * 2 + sdvals.size(2) * sdvals.size(1) * q] =
            d_deriv[2];
        sfvals[sfvals.size(1) * q + 3] = d_N[3];
        sdvals[sdvals.size(2) * 3 + sdvals.size(2) * sdvals.size(1) * q] =
            d_deriv[3];
        sfvals[sfvals.size(1) * q + 4] = d_N[4];
        sdvals[sdvals.size(2) * 4 + sdvals.size(2) * sdvals.size(1) * q] =
            d_deriv[4];
      }
    } break;
    case 53: {
      int32_T i1;
      boolean_T b;
      boolean_T b1;
      b = true;
      b1 = ((cs.size(1) <= 0) || (cs.size(0) <= 0));
      i = cs.size(1) * cs.size(0);
      i1 = 0;
      for (int32_T q{0}; q <= nqp; q++) {
        real_T e_N[6];
        real_T e_deriv[6];
        if (b1 || (q >= i)) {
          i1 = 0;
          b = true;
        } else if (b) {
          b = false;
          i1 = q % cs.size(0) * cs.size(1) + q / cs.size(0);
        } else {
          int32_T i2;
          i2 = cs.size(1) * cs.size(0) - 1;
          if (i1 > MAX_int32_T - cs.size(1)) {
            i1 = q % cs.size(0) * cs.size(1) + q / cs.size(0);
          } else {
            i1 += cs.size(1);
            if (i1 > i2) {
              i1 -= i2;
            }
          }
        }
        // bar_gl_6 - Compute shape functions and their derivatives of bar_gl_6
        //
        //     ncoords = bar_gl_6
        //     [sfvals,sdvals] = bar_gl_6(xi)
        //
        // Parameters
        // ----------
        //     xi: natural coordinates ranging between 0 and 1
        //
        // Returns
        // -------
        //     ncoords: natural coordinates of nodes if nargin==0
        //
        //                          OR
        //
        //     sfvals: vector of size 6-by-1
        //     sdvals: vector of size 6-by-1
        ::sfe_sfuncs::bar_gl_6_sfunc(cs[i1], &e_N[0], &e_deriv[0]);
        sfvals[sfvals.size(1) * q] = e_N[0];
        sdvals[sdvals.size(2) * sdvals.size(1) * q] = e_deriv[0];
        sfvals[sfvals.size(1) * q + 1] = e_N[1];
        sdvals[sdvals.size(2) + sdvals.size(2) * sdvals.size(1) * q] =
            e_deriv[1];
        sfvals[sfvals.size(1) * q + 2] = e_N[2];
        sdvals[sdvals.size(2) * 2 + sdvals.size(2) * sdvals.size(1) * q] =
            e_deriv[2];
        sfvals[sfvals.size(1) * q + 3] = e_N[3];
        sdvals[sdvals.size(2) * 3 + sdvals.size(2) * sdvals.size(1) * q] =
            e_deriv[3];
        sfvals[sfvals.size(1) * q + 4] = e_N[4];
        sdvals[sdvals.size(2) * 4 + sdvals.size(2) * sdvals.size(1) * q] =
            e_deriv[4];
        sfvals[sfvals.size(1) * q + 5] = e_N[5];
        sdvals[sdvals.size(2) * 5 + sdvals.size(2) * sdvals.size(1) * q] =
            e_deriv[5];
      }
    } break;
    default: {
      int32_T i1;
      boolean_T b;
      boolean_T b1;
      //  m2cAssert  Throw error if condition false at runtime
      //
      //    m2cAssert(cond)
      //    m2cAssert(cond,msg)
      //    m2cAssert(cond,msg,A1,...,An)
      //    m2cAssert(cond,errID,msg)
      //    m2cAssert(cond,errID,msg,A1,...,An)
      //
      //  The interface of `m2cAssert` is compatible with MATLAB's built-in
      //  `assert`,  but it generates runtime assertion instead of compile-time
      //  assertion.
      //
      //  Note
      //  ----
      //  The MATLAB built-in `assert` is mostly used for compile-time error
      //  checking, and it has no effect for runtime error checking in LIB mode.
      //  Use `m2cAssert` instead for runtime error checking. Like the built-in
      //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
      //  into a code-generation-time character string. If you want to use both
      //  code-generation-time and runtime assertions, it is recommended to put
      //  `m2cAssert` before the built-in `assert`.
      //
      //  See also assert, m2cError, m2cWarning
      m2cAssert(etype == 57, "Only support up to sextic.");
      b = true;
      b1 = ((cs.size(1) <= 0) || (cs.size(0) <= 0));
      i = cs.size(1) * cs.size(0);
      i1 = 0;
      for (int32_T q{0}; q <= nqp; q++) {
        real_T f_N[7];
        real_T f_deriv[7];
        if (b1 || (q >= i)) {
          i1 = 0;
          b = true;
        } else if (b) {
          b = false;
          i1 = q % cs.size(0) * cs.size(1) + q / cs.size(0);
        } else {
          int32_T i2;
          i2 = cs.size(1) * cs.size(0) - 1;
          if (i1 > MAX_int32_T - cs.size(1)) {
            i1 = q % cs.size(0) * cs.size(1) + q / cs.size(0);
          } else {
            i1 += cs.size(1);
            if (i1 > i2) {
              i1 -= i2;
            }
          }
        }
        // bar_gl_7 - Compute shape functions and their derivatives of bar_gl_7
        //
        //     ncoords = bar_gl_7
        //     [sfvals,sdvals] = bar_gl_7(xi)
        //
        // Parameters
        // ----------
        //     xi: natural coordinates ranging between 0 and 1
        //
        // Returns
        // -------
        //     ncoords: natural coordinates of nodes if nargin==0
        //
        //                          OR
        //
        //     sfvals: vector of size 7-by-1
        //     sdvals: vector of size 7-by-1
        ::sfe_sfuncs::bar_gl_7_sfunc(cs[i1], &f_N[0], &f_deriv[0]);
        sfvals[sfvals.size(1) * q] = f_N[0];
        sdvals[sdvals.size(2) * sdvals.size(1) * q] = f_deriv[0];
        sfvals[sfvals.size(1) * q + 1] = f_N[1];
        sdvals[sdvals.size(2) + sdvals.size(2) * sdvals.size(1) * q] =
            f_deriv[1];
        sfvals[sfvals.size(1) * q + 2] = f_N[2];
        sdvals[sdvals.size(2) * 2 + sdvals.size(2) * sdvals.size(1) * q] =
            f_deriv[2];
        sfvals[sfvals.size(1) * q + 3] = f_N[3];
        sdvals[sdvals.size(2) * 3 + sdvals.size(2) * sdvals.size(1) * q] =
            f_deriv[3];
        sfvals[sfvals.size(1) * q + 4] = f_N[4];
        sdvals[sdvals.size(2) * 4 + sdvals.size(2) * sdvals.size(1) * q] =
            f_deriv[4];
        sfvals[sfvals.size(1) * q + 5] = f_N[5];
        sdvals[sdvals.size(2) * 5 + sdvals.size(2) * sdvals.size(1) * q] =
            f_deriv[5];
        sfvals[sfvals.size(1) * q + 6] = f_N[6];
        sdvals[sdvals.size(2) * 6 + sdvals.size(2) * sdvals.size(1) * q] =
            f_deriv[6];
      }
    } break;
    }
  }
}

static void sfe2_tabulate_equi_quad(int32_T etype,
                                    const ::coder::array<real_T, 2U> &cs,
                                    ::coder::array<real_T, 2U> &sfvals,
                                    ::coder::array<real_T, 3U> &sdvals)
{
  real_T b_tmp_data[1029];
  real_T tmp_data[1029];
  real_T dv10[98];
  real_T dv7[72];
  real_T dv6[50];
  real_T dv11[49];
  real_T dv9[36];
  real_T dv8[25];
  int32_T b_tmp_size_idx_1;
  int32_T b_tmp_size_idx_2;
  int32_T i;
  int32_T i4;
  int32_T i5;
  int32_T i6;
  int32_T i7;
  int32_T loop_ub;
  int32_T nqp;
  int16_T b_unnamed_idx_1;
  int16_T b_unnamed_idx_2;
  //  triangular
  nqp = cs.size(0) - 1;
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  i = iv[etype - 1];
  sfvals.set_size(cs.size(0), i);
  sdvals.set_size(cs.size(0), i, cs.size(1));
  switch (etype) {
  case 100: {
    for (int32_T q{0}; q <= nqp; q++) {
      real_T dv3[8];
      real_T dv[4];
      int32_T i1;
      int32_T i2;
      int32_T tmp_size_idx_1;
      int32_T tmp_size_idx_2;
      int32_T ub_loop;
      int16_T unnamed_idx_1;
      int16_T unnamed_idx_2;
      // quad_4 - Bilinear quadrilateral element
      //     [sfvals,sdvals] = quad_4(xi,eta)
      //
      //   Input:
      //      xi, eta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 4-by-1
      //      sdvals: vector of size 4-by-2
      //
      //     nodes_nat_coors = quad_4
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also quad_9, quad_16, quad_gl_16, quad_25, quad_gl_25
      ::sfe_sfuncs::quad_4_sfunc(cs[cs.size(1) * q], cs[cs.size(1) * q + 1],
                                 &dv[0], &dv3[0]);
      ub_loop = sfvals.size(1);
      for (i = 0; i < ub_loop; i++) {
        sfvals[i + sfvals.size(1) * q] = dv[i];
      }
      unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i = 0;
      i1 = 0;
      ub_loop = 0;
      i2 = 0;
      tmp_size_idx_2 = sdvals.size(2);
      tmp_size_idx_1 = sdvals.size(1);
      for (int32_T i3{0}; i3 < unnamed_idx_1 * unnamed_idx_2; i3++) {
        tmp_data[i1 + tmp_size_idx_2 * i] = dv3[i2 + (ub_loop << 1)];
        ub_loop++;
        i++;
        if (i > tmp_size_idx_1 - 1) {
          i = 0;
          i1++;
        }
        if (ub_loop > 3) {
          ub_loop = 0;
          i2++;
        }
      }
      for (i = 0; i < tmp_size_idx_1; i++) {
        for (i1 = 0; i1 < tmp_size_idx_2; i1++) {
          sdvals[(i1 + sdvals.size(2) * i) +
                 sdvals.size(2) * sdvals.size(1) * q] =
              tmp_data[i1 + tmp_size_idx_2 * i];
        }
      }
    }
  } break;
  case 104: {
    for (int32_T q{0}; q <= nqp; q++) {
      real_T dv4[18];
      real_T dv1[9];
      int32_T i1;
      int32_T i2;
      int32_T tmp_size_idx_1;
      int32_T tmp_size_idx_2;
      int32_T ub_loop;
      int16_T unnamed_idx_1;
      int16_T unnamed_idx_2;
      // quad_9 - Bilinear quadrilateral element
      //     [sfvals,sdvals] = quad_9(xi,eta)
      //
      //   Input:
      //      xi, eta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 9-by-1
      //      sdvals: vector of size 9-by-2
      //
      //     nodes_nat_coors = quad_9
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also quad_4, quad_16, quad_gl_16, quad_25, quad_gl_25
      ::sfe_sfuncs::quad_9_sfunc(cs[cs.size(1) * q], cs[cs.size(1) * q + 1],
                                 &dv1[0], &dv4[0]);
      ub_loop = sfvals.size(1);
      for (i = 0; i < ub_loop; i++) {
        sfvals[i + sfvals.size(1) * q] = dv1[i];
      }
      unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i = 0;
      i1 = 0;
      ub_loop = 0;
      i2 = 0;
      tmp_size_idx_2 = sdvals.size(2);
      tmp_size_idx_1 = sdvals.size(1);
      for (int32_T i3{0}; i3 < unnamed_idx_1 * unnamed_idx_2; i3++) {
        tmp_data[i1 + tmp_size_idx_2 * i] = dv4[i2 + (ub_loop << 1)];
        ub_loop++;
        i++;
        if (i > tmp_size_idx_1 - 1) {
          i = 0;
          i1++;
        }
        if (ub_loop > 8) {
          ub_loop = 0;
          i2++;
        }
      }
      for (i = 0; i < tmp_size_idx_1; i++) {
        for (i1 = 0; i1 < tmp_size_idx_2; i1++) {
          sdvals[(i1 + sdvals.size(2) * i) +
                 sdvals.size(2) * sdvals.size(1) * q] =
              tmp_data[i1 + tmp_size_idx_2 * i];
        }
      }
    }
  } break;
  case 108: {
    for (int32_T q{0}; q <= nqp; q++) {
      real_T dv5[32];
      real_T dv2[16];
      int32_T i1;
      int32_T i2;
      int32_T tmp_size_idx_1;
      int32_T tmp_size_idx_2;
      int32_T ub_loop;
      int16_T unnamed_idx_1;
      int16_T unnamed_idx_2;
      // quad_16 - Bicubic quadrilateral element with equidistant points
      //     [sfvals,sdvals] = quad_16(xi,eta)
      //
      //   Input:
      //      xi, eta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 16-by-1
      //      sdvals: vector of size 16-by-2
      //
      //     nodes_nat_coors = quad_16
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also quad_4, quad_9, quad_gl_16, quad_25, quad_gl_25
      ::sfe_sfuncs::quad_16_sfunc(cs[cs.size(1) * q], cs[cs.size(1) * q + 1],
                                  &dv2[0], &dv5[0]);
      ub_loop = sfvals.size(1);
      for (i = 0; i < ub_loop; i++) {
        sfvals[i + sfvals.size(1) * q] = dv2[i];
      }
      unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i = 0;
      i1 = 0;
      ub_loop = 0;
      i2 = 0;
      tmp_size_idx_2 = sdvals.size(2);
      tmp_size_idx_1 = sdvals.size(1);
      for (int32_T i3{0}; i3 < unnamed_idx_1 * unnamed_idx_2; i3++) {
        tmp_data[i1 + tmp_size_idx_2 * i] = dv5[i2 + (ub_loop << 1)];
        ub_loop++;
        i++;
        if (i > tmp_size_idx_1 - 1) {
          i = 0;
          i1++;
        }
        if (ub_loop > 15) {
          ub_loop = 0;
          i2++;
        }
      }
      for (i = 0; i < tmp_size_idx_1; i++) {
        for (i1 = 0; i1 < tmp_size_idx_2; i1++) {
          sdvals[(i1 + sdvals.size(2) * i) +
                 sdvals.size(2) * sdvals.size(1) * q] =
              tmp_data[i1 + tmp_size_idx_2 * i];
        }
      }
    }
  } break;
  case 112: {
    int32_T ub_loop;
//  Choose a mode for parfor
// ompForSerial - Transform a parfor loop to run in serial
//
//       ompForSerial
//
//  Note
//  ----
//
//  This directive must appear immediately before the parfor loop to be
//  affected.
//
//  Example
//  -------
//     ompForSerial;
//     parfor i=1:N
//        x(i) = y(i) + z(i);
//     end
//
//  See also ompSimd, ompSimdWithFor, ompForWithPar, ompForInPar
#pragma m2c ompForSerial();
    //  Serial mode
    ub_loop = cs.size(0) - 1;
#pragma omp parallel for num_threads(omp_get_max_threads()) private(           \
    dv6, dv8, loop_ub, i4, b_unnamed_idx_1, b_unnamed_idx_2, i5, i6,           \
    b_tmp_size_idx_2, b_tmp_size_idx_1, i7, b_tmp_data)

    for (int32_T b_q = 0; b_q <= ub_loop; b_q++) {
      quad_25(cs[cs.size(1) * b_q], cs[cs.size(1) * b_q + 1], dv8, dv6);
      loop_ub = sfvals.size(1);
      for (i4 = 0; i4 < loop_ub; i4++) {
        sfvals[i4 + sfvals.size(1) * b_q] = dv8[i4];
      }
      b_unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      b_unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i4 = 0;
      i5 = 0;
      loop_ub = 0;
      i6 = 0;
      b_tmp_size_idx_2 = sdvals.size(2);
      b_tmp_size_idx_1 = sdvals.size(1);
      for (i7 = 0; i7 < b_unnamed_idx_1 * b_unnamed_idx_2; i7++) {
        b_tmp_data[i5 + b_tmp_size_idx_2 * i4] = dv6[i6 + (loop_ub << 1)];
        loop_ub++;
        i4++;
        if (i4 > b_tmp_size_idx_1 - 1) {
          i4 = 0;
          i5++;
        }
        if (loop_ub > 24) {
          loop_ub = 0;
          i6++;
        }
      }
      for (i4 = 0; i4 < b_tmp_size_idx_1; i4++) {
        for (i5 = 0; i5 < b_tmp_size_idx_2; i5++) {
          sdvals[(i5 + sdvals.size(2) * i4) +
                 sdvals.size(2) * sdvals.size(1) * b_q] =
              b_tmp_data[i5 + b_tmp_size_idx_2 * i4];
        }
      }
    }
  } break;
  case 116: {
    int32_T ub_loop;
//  Choose a mode for parfor
// ompForSerial - Transform a parfor loop to run in serial
//
//       ompForSerial
//
//  Note
//  ----
//
//  This directive must appear immediately before the parfor loop to be
//  affected.
//
//  Example
//  -------
//     ompForSerial;
//     parfor i=1:N
//        x(i) = y(i) + z(i);
//     end
//
//  See also ompSimd, ompSimdWithFor, ompForWithPar, ompForInPar
#pragma m2c ompForSerial();
    //  Serial mode
    ub_loop = cs.size(0) - 1;
#pragma omp parallel for num_threads(omp_get_max_threads()) private(           \
    dv7, dv9, loop_ub, i4, b_unnamed_idx_1, b_unnamed_idx_2, i5, i6,           \
    b_tmp_size_idx_2, b_tmp_size_idx_1, i7, b_tmp_data)

    for (int32_T b_q = 0; b_q <= ub_loop; b_q++) {
      quad_36(cs[cs.size(1) * b_q], cs[cs.size(1) * b_q + 1], dv9, dv7);
      loop_ub = sfvals.size(1);
      for (i4 = 0; i4 < loop_ub; i4++) {
        sfvals[i4 + sfvals.size(1) * b_q] = dv9[i4];
      }
      b_unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      b_unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i4 = 0;
      i5 = 0;
      loop_ub = 0;
      i6 = 0;
      b_tmp_size_idx_2 = sdvals.size(2);
      b_tmp_size_idx_1 = sdvals.size(1);
      for (i7 = 0; i7 < b_unnamed_idx_1 * b_unnamed_idx_2; i7++) {
        b_tmp_data[i5 + b_tmp_size_idx_2 * i4] = dv7[i6 + (loop_ub << 1)];
        loop_ub++;
        i4++;
        if (i4 > b_tmp_size_idx_1 - 1) {
          i4 = 0;
          i5++;
        }
        if (loop_ub > 35) {
          loop_ub = 0;
          i6++;
        }
      }
      for (i4 = 0; i4 < b_tmp_size_idx_1; i4++) {
        for (i5 = 0; i5 < b_tmp_size_idx_2; i5++) {
          sdvals[(i5 + sdvals.size(2) * i4) +
                 sdvals.size(2) * sdvals.size(1) * b_q] =
              b_tmp_data[i5 + b_tmp_size_idx_2 * i4];
        }
      }
    }
  } break;
  default: {
    int32_T ub_loop;
    //  m2cAssert  Throw error if condition false at runtime
    //
    //    m2cAssert(cond)
    //    m2cAssert(cond,msg)
    //    m2cAssert(cond,msg,A1,...,An)
    //    m2cAssert(cond,errID,msg)
    //    m2cAssert(cond,errID,msg,A1,...,An)
    //
    //  The interface of `m2cAssert` is compatible with MATLAB's built-in
    //  `assert`,  but it generates runtime assertion instead of compile-time
    //  assertion.
    //
    //  Note
    //  ----
    //  The MATLAB built-in `assert` is mostly used for compile-time error
    //  checking, and it has no effect for runtime error checking in LIB mode.
    //  Use `m2cAssert` instead for runtime error checking. Like the built-in
    //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
    //  into a code-generation-time character string. If you want to use both
    //  code-generation-time and runtime assertions, it is recommended to put
    //  `m2cAssert` before the built-in `assert`.
    //
    //  See also assert, m2cError, m2cWarning
    m2cAssert(etype == 120, "Only supports up to sextic.");
//  Choose a mode for parfor
// ompForSerial - Transform a parfor loop to run in serial
//
//       ompForSerial
//
//  Note
//  ----
//
//  This directive must appear immediately before the parfor loop to be
//  affected.
//
//  Example
//  -------
//     ompForSerial;
//     parfor i=1:N
//        x(i) = y(i) + z(i);
//     end
//
//  See also ompSimd, ompSimdWithFor, ompForWithPar, ompForInPar
#pragma m2c ompForSerial();
    //  Serial mode
    ub_loop = cs.size(0) - 1;
#pragma omp parallel for num_threads(omp_get_max_threads()) private(           \
    dv10, dv11, loop_ub, i4, b_unnamed_idx_1, b_unnamed_idx_2, i5, i6,         \
    b_tmp_size_idx_2, b_tmp_size_idx_1, i7, b_tmp_data)

    for (int32_T b_q = 0; b_q <= ub_loop; b_q++) {
      quad_49(cs[cs.size(1) * b_q], cs[cs.size(1) * b_q + 1], dv11, dv10);
      loop_ub = sfvals.size(1);
      for (i4 = 0; i4 < loop_ub; i4++) {
        sfvals[i4 + sfvals.size(1) * b_q] = dv11[i4];
      }
      b_unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      b_unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i4 = 0;
      i5 = 0;
      loop_ub = 0;
      i6 = 0;
      b_tmp_size_idx_2 = sdvals.size(2);
      b_tmp_size_idx_1 = sdvals.size(1);
      for (i7 = 0; i7 < b_unnamed_idx_1 * b_unnamed_idx_2; i7++) {
        b_tmp_data[i5 + b_tmp_size_idx_2 * i4] = dv10[i6 + (loop_ub << 1)];
        loop_ub++;
        i4++;
        if (i4 > b_tmp_size_idx_1 - 1) {
          i4 = 0;
          i5++;
        }
        if (loop_ub > 48) {
          loop_ub = 0;
          i6++;
        }
      }
      for (i4 = 0; i4 < b_tmp_size_idx_1; i4++) {
        for (i5 = 0; i5 < b_tmp_size_idx_2; i5++) {
          sdvals[(i5 + sdvals.size(2) * i4) +
                 sdvals.size(2) * sdvals.size(1) * b_q] =
              b_tmp_data[i5 + b_tmp_size_idx_2 * i4];
        }
      }
    }
  } break;
  }
}

static void sfe2_tabulate_equi_tri(int32_T etype,
                                   const ::coder::array<real_T, 2U> &cs,
                                   ::coder::array<real_T, 2U> &sfvals,
                                   ::coder::array<real_T, 3U> &sdvals)
{
  real_T b_tmp_data[1029];
  real_T tmp_data[1029];
  real_T dv9[56];
  real_T dv7[42];
  real_T dv10[28];
  real_T dv8[21];
  int32_T b_tmp_size_idx_1;
  int32_T b_tmp_size_idx_2;
  int32_T i;
  int32_T i3;
  int32_T i5;
  int32_T i6;
  int32_T i7;
  int32_T loop_ub;
  int32_T nqp;
  int16_T b_unnamed_idx_1;
  int16_T b_unnamed_idx_2;
  //  triangular
  nqp = cs.size(0) - 1;
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  i = iv[etype - 1];
  sfvals.set_size(cs.size(0), i);
  sdvals.set_size(cs.size(0), i, cs.size(1));
  switch (etype) {
  case 68: {
    for (int32_T q{0}; q <= nqp; q++) {
      real_T dv1[6];
      real_T dv[3];
      int32_T i1;
      int32_T i2;
      int32_T tmp_size_idx_1;
      int32_T tmp_size_idx_2;
      int32_T ub_loop;
      int16_T unnamed_idx_1;
      int16_T unnamed_idx_2;
      // tri_3 - Compute shape functions and their derivatives of tri_3
      //
      //     ncoords = tri_3
      //     [sfvals,sdvals] = tri_3(xi,eta)
      //
      // Parameters
      // ----------
      //     xi,eta: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 3-by-1
      //     sdvals: vector of size 3-by-2
      ::sfe_sfuncs::tri_3_sfunc(cs[cs.size(1) * q], cs[cs.size(1) * q + 1],
                                &dv[0], &dv1[0]);
      ub_loop = sfvals.size(1);
      for (i = 0; i < ub_loop; i++) {
        sfvals[i + sfvals.size(1) * q] = dv[i];
      }
      unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i = 0;
      i1 = 0;
      ub_loop = 0;
      i2 = 0;
      tmp_size_idx_2 = sdvals.size(2);
      tmp_size_idx_1 = sdvals.size(1);
      for (int32_T i4{0}; i4 < unnamed_idx_1 * unnamed_idx_2; i4++) {
        tmp_data[i1 + tmp_size_idx_2 * i] = dv1[i2 + (ub_loop << 1)];
        ub_loop++;
        i++;
        if (i > tmp_size_idx_1 - 1) {
          i = 0;
          i1++;
        }
        if (ub_loop > 2) {
          ub_loop = 0;
          i2++;
        }
      }
      for (i = 0; i < tmp_size_idx_1; i++) {
        for (i1 = 0; i1 < tmp_size_idx_2; i1++) {
          sdvals[(i1 + sdvals.size(2) * i) +
                 sdvals.size(2) * sdvals.size(1) * q] =
              tmp_data[i1 + tmp_size_idx_2 * i];
        }
      }
    }
  } break;
  case 72: {
    for (int32_T q{0}; q <= nqp; q++) {
      real_T dv4[12];
      real_T dv1[6];
      int32_T i1;
      int32_T i2;
      int32_T tmp_size_idx_1;
      int32_T tmp_size_idx_2;
      int32_T ub_loop;
      int16_T unnamed_idx_1;
      int16_T unnamed_idx_2;
      // tri_6 - Compute shape functions and their derivatives of tri_6
      //
      //     ncoords = tri_6
      //     [sfvals,sdvals] = tri_6(xi,eta)
      //
      // Parameters
      // ----------
      //     xi,eta: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 6-by-1
      //     sdvals: vector of size 6-by-2
      ::sfe_sfuncs::tri_6_sfunc(cs[cs.size(1) * q], cs[cs.size(1) * q + 1],
                                &dv1[0], &dv4[0]);
      ub_loop = sfvals.size(1);
      for (i = 0; i < ub_loop; i++) {
        sfvals[i + sfvals.size(1) * q] = dv1[i];
      }
      unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i = 0;
      i1 = 0;
      ub_loop = 0;
      i2 = 0;
      tmp_size_idx_2 = sdvals.size(2);
      tmp_size_idx_1 = sdvals.size(1);
      for (int32_T i4{0}; i4 < unnamed_idx_1 * unnamed_idx_2; i4++) {
        tmp_data[i1 + tmp_size_idx_2 * i] = dv4[i2 + (ub_loop << 1)];
        ub_loop++;
        i++;
        if (i > tmp_size_idx_1 - 1) {
          i = 0;
          i1++;
        }
        if (ub_loop > 5) {
          ub_loop = 0;
          i2++;
        }
      }
      for (i = 0; i < tmp_size_idx_1; i++) {
        for (i1 = 0; i1 < tmp_size_idx_2; i1++) {
          sdvals[(i1 + sdvals.size(2) * i) +
                 sdvals.size(2) * sdvals.size(1) * q] =
              tmp_data[i1 + tmp_size_idx_2 * i];
        }
      }
    }
  } break;
  case 76: {
    for (int32_T q{0}; q <= nqp; q++) {
      real_T dv5[20];
      real_T dv2[10];
      int32_T i1;
      int32_T i2;
      int32_T tmp_size_idx_1;
      int32_T tmp_size_idx_2;
      int32_T ub_loop;
      int16_T unnamed_idx_1;
      int16_T unnamed_idx_2;
      // tri_10 - Compute shape functions and their derivatives of tri_10
      //
      //     ncoords = tri_10
      //     [sfvals,sdvals] = tri_10(xi,eta)
      //
      // Parameters
      // ----------
      //     xi,eta: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 10-by-1
      //     sdvals: vector of size 10-by-2
      ::sfe_sfuncs::tri_10_sfunc(cs[cs.size(1) * q], cs[cs.size(1) * q + 1],
                                 &dv2[0], &dv5[0]);
      ub_loop = sfvals.size(1);
      for (i = 0; i < ub_loop; i++) {
        sfvals[i + sfvals.size(1) * q] = dv2[i];
      }
      unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i = 0;
      i1 = 0;
      ub_loop = 0;
      i2 = 0;
      tmp_size_idx_2 = sdvals.size(2);
      tmp_size_idx_1 = sdvals.size(1);
      for (int32_T i4{0}; i4 < unnamed_idx_1 * unnamed_idx_2; i4++) {
        tmp_data[i1 + tmp_size_idx_2 * i] = dv5[i2 + (ub_loop << 1)];
        ub_loop++;
        i++;
        if (i > tmp_size_idx_1 - 1) {
          i = 0;
          i1++;
        }
        if (ub_loop > 9) {
          ub_loop = 0;
          i2++;
        }
      }
      for (i = 0; i < tmp_size_idx_1; i++) {
        for (i1 = 0; i1 < tmp_size_idx_2; i1++) {
          sdvals[(i1 + sdvals.size(2) * i) +
                 sdvals.size(2) * sdvals.size(1) * q] =
              tmp_data[i1 + tmp_size_idx_2 * i];
        }
      }
    }
  } break;
  case 80: {
    for (int32_T q{0}; q <= nqp; q++) {
      real_T dv6[30];
      real_T dv3[15];
      int32_T i1;
      int32_T i2;
      int32_T tmp_size_idx_1;
      int32_T tmp_size_idx_2;
      int32_T ub_loop;
      int16_T unnamed_idx_1;
      int16_T unnamed_idx_2;
      // tri_15 - Compute shape functions and their derivatives of tri_15
      //
      //     ncoords = tri_15
      //     [sfvals,sdvals] = tri_15(xi,eta)
      //
      // Parameters
      // ----------
      //     xi,eta: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 15-by-1
      //     sdvals: vector of size 15-by-2
      ::sfe_sfuncs::tri_15_sfunc(cs[cs.size(1) * q], cs[cs.size(1) * q + 1],
                                 &dv3[0], &dv6[0]);
      ub_loop = sfvals.size(1);
      for (i = 0; i < ub_loop; i++) {
        sfvals[i + sfvals.size(1) * q] = dv3[i];
      }
      unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i = 0;
      i1 = 0;
      ub_loop = 0;
      i2 = 0;
      tmp_size_idx_2 = sdvals.size(2);
      tmp_size_idx_1 = sdvals.size(1);
      for (int32_T i4{0}; i4 < unnamed_idx_1 * unnamed_idx_2; i4++) {
        tmp_data[i1 + tmp_size_idx_2 * i] = dv6[i2 + (ub_loop << 1)];
        ub_loop++;
        i++;
        if (i > tmp_size_idx_1 - 1) {
          i = 0;
          i1++;
        }
        if (ub_loop > 14) {
          ub_loop = 0;
          i2++;
        }
      }
      for (i = 0; i < tmp_size_idx_1; i++) {
        for (i1 = 0; i1 < tmp_size_idx_2; i1++) {
          sdvals[(i1 + sdvals.size(2) * i) +
                 sdvals.size(2) * sdvals.size(1) * q] =
              tmp_data[i1 + tmp_size_idx_2 * i];
        }
      }
    }
  } break;
  case 84: {
    int32_T ub_loop;
//  Choose a mode for parfor
// ompForSerial - Transform a parfor loop to run in serial
//
//       ompForSerial
//
//  Note
//  ----
//
//  This directive must appear immediately before the parfor loop to be
//  affected.
//
//  Example
//  -------
//     ompForSerial;
//     parfor i=1:N
//        x(i) = y(i) + z(i);
//     end
//
//  See also ompSimd, ompSimdWithFor, ompForWithPar, ompForInPar
#pragma m2c ompForSerial();
    //  Serial mode
    ub_loop = cs.size(0) - 1;
#pragma omp parallel for num_threads(omp_get_max_threads()) private(           \
    dv7, dv8, loop_ub, i3, b_unnamed_idx_1, b_unnamed_idx_2, i5, i6,           \
    b_tmp_size_idx_2, b_tmp_size_idx_1, i7, b_tmp_data)

    for (int32_T b_q = 0; b_q <= ub_loop; b_q++) {
      tri_21(cs[cs.size(1) * b_q], cs[cs.size(1) * b_q + 1], dv8, dv7);
      loop_ub = sfvals.size(1);
      for (i3 = 0; i3 < loop_ub; i3++) {
        sfvals[i3 + sfvals.size(1) * b_q] = dv8[i3];
      }
      b_unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      b_unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i3 = 0;
      i5 = 0;
      loop_ub = 0;
      i6 = 0;
      b_tmp_size_idx_2 = sdvals.size(2);
      b_tmp_size_idx_1 = sdvals.size(1);
      for (i7 = 0; i7 < b_unnamed_idx_1 * b_unnamed_idx_2; i7++) {
        b_tmp_data[i5 + b_tmp_size_idx_2 * i3] = dv7[i6 + (loop_ub << 1)];
        loop_ub++;
        i3++;
        if (i3 > b_tmp_size_idx_1 - 1) {
          i3 = 0;
          i5++;
        }
        if (loop_ub > 20) {
          loop_ub = 0;
          i6++;
        }
      }
      for (i3 = 0; i3 < b_tmp_size_idx_1; i3++) {
        for (i5 = 0; i5 < b_tmp_size_idx_2; i5++) {
          sdvals[(i5 + sdvals.size(2) * i3) +
                 sdvals.size(2) * sdvals.size(1) * b_q] =
              b_tmp_data[i5 + b_tmp_size_idx_2 * i3];
        }
      }
    }
  } break;
  default: {
    int32_T ub_loop;
    //  m2cAssert  Throw error if condition false at runtime
    //
    //    m2cAssert(cond)
    //    m2cAssert(cond,msg)
    //    m2cAssert(cond,msg,A1,...,An)
    //    m2cAssert(cond,errID,msg)
    //    m2cAssert(cond,errID,msg,A1,...,An)
    //
    //  The interface of `m2cAssert` is compatible with MATLAB's built-in
    //  `assert`,  but it generates runtime assertion instead of compile-time
    //  assertion.
    //
    //  Note
    //  ----
    //  The MATLAB built-in `assert` is mostly used for compile-time error
    //  checking, and it has no effect for runtime error checking in LIB mode.
    //  Use `m2cAssert` instead for runtime error checking. Like the built-in
    //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
    //  into a code-generation-time character string. If you want to use both
    //  code-generation-time and runtime assertions, it is recommended to put
    //  `m2cAssert` before the built-in `assert`.
    //
    //  See also assert, m2cError, m2cWarning
    m2cAssert(etype == 88, "Only support up to sextic.");
//  Choose a mode for parfor
// ompForSerial - Transform a parfor loop to run in serial
//
//       ompForSerial
//
//  Note
//  ----
//
//  This directive must appear immediately before the parfor loop to be
//  affected.
//
//  Example
//  -------
//     ompForSerial;
//     parfor i=1:N
//        x(i) = y(i) + z(i);
//     end
//
//  See also ompSimd, ompSimdWithFor, ompForWithPar, ompForInPar
#pragma m2c ompForSerial();
    //  Serial mode
    ub_loop = cs.size(0) - 1;
#pragma omp parallel for num_threads(omp_get_max_threads()) private(           \
    dv9, dv10, loop_ub, i3, b_unnamed_idx_1, b_unnamed_idx_2, i5, i6,          \
    b_tmp_size_idx_2, b_tmp_size_idx_1, i7, b_tmp_data)

    for (int32_T b_q = 0; b_q <= ub_loop; b_q++) {
      tri_28(cs[cs.size(1) * b_q], cs[cs.size(1) * b_q + 1], dv10, dv9);
      loop_ub = sfvals.size(1);
      for (i3 = 0; i3 < loop_ub; i3++) {
        sfvals[i3 + sfvals.size(1) * b_q] = dv10[i3];
      }
      b_unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      b_unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i3 = 0;
      i5 = 0;
      loop_ub = 0;
      i6 = 0;
      b_tmp_size_idx_2 = sdvals.size(2);
      b_tmp_size_idx_1 = sdvals.size(1);
      for (i7 = 0; i7 < b_unnamed_idx_1 * b_unnamed_idx_2; i7++) {
        b_tmp_data[i5 + b_tmp_size_idx_2 * i3] = dv9[i6 + (loop_ub << 1)];
        loop_ub++;
        i3++;
        if (i3 > b_tmp_size_idx_1 - 1) {
          i3 = 0;
          i5++;
        }
        if (loop_ub > 27) {
          loop_ub = 0;
          i6++;
        }
      }
      for (i3 = 0; i3 < b_tmp_size_idx_1; i3++) {
        for (i5 = 0; i5 < b_tmp_size_idx_2; i5++) {
          sdvals[(i5 + sdvals.size(2) * i3) +
                 sdvals.size(2) * sdvals.size(1) * b_q] =
              b_tmp_data[i5 + b_tmp_size_idx_2 * i3];
        }
      }
    }
  } break;
  }
}

static void sfe2_tabulate_fek_tri(int32_T etype,
                                  const ::coder::array<real_T, 2U> &cs,
                                  ::coder::array<real_T, 2U> &sfvals,
                                  ::coder::array<real_T, 3U> &sdvals)
{
  real_T tmp_data[1029];
  real_T dv4[56];
  real_T dv1[42];
  real_T dv[30];
  real_T dv5[28];
  real_T dv3[21];
  real_T dv2[15];
  int32_T i;
  int32_T i1;
  int32_T i2;
  int32_T i3;
  int32_T loop_ub;
  int32_T tmp_size_idx_1;
  int32_T tmp_size_idx_2;
  int32_T ub_loop;
  int16_T unnamed_idx_1;
  int16_T unnamed_idx_2;
  //  triangular
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  ub_loop = iv[etype - 1];
  sfvals.set_size(cs.size(0), ub_loop);
  sdvals.set_size(cs.size(0), ub_loop, cs.size(1));
  switch (etype) {
  case 82:
//  Choose a mode for parfor
// ompForSerial - Transform a parfor loop to run in serial
//
//       ompForSerial
//
//  Note
//  ----
//
//  This directive must appear immediately before the parfor loop to be
//  affected.
//
//  Example
//  -------
//     ompForSerial;
//     parfor i=1:N
//        x(i) = y(i) + z(i);
//     end
//
//  See also ompSimd, ompSimdWithFor, ompForWithPar, ompForInPar
#pragma m2c ompForSerial();
    //  Serial mode
    ub_loop = cs.size(0) - 1;
#pragma omp parallel for num_threads(omp_get_max_threads()) private(           \
    dv, dv2, loop_ub, i, unnamed_idx_1, unnamed_idx_2, i1, i2, tmp_size_idx_2, \
    tmp_size_idx_1, i3, tmp_data)

    for (int32_T q = 0; q <= ub_loop; q++) {
      tri_fek_15(cs[cs.size(1) * q], cs[cs.size(1) * q + 1], dv2, dv);
      loop_ub = sfvals.size(1);
      for (i = 0; i < loop_ub; i++) {
        sfvals[i + sfvals.size(1) * q] = dv2[i];
      }
      unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i = 0;
      i1 = 0;
      loop_ub = 0;
      i2 = 0;
      tmp_size_idx_2 = sdvals.size(2);
      tmp_size_idx_1 = sdvals.size(1);
      for (i3 = 0; i3 < unnamed_idx_1 * unnamed_idx_2; i3++) {
        tmp_data[i1 + tmp_size_idx_2 * i] = dv[i2 + (loop_ub << 1)];
        loop_ub++;
        i++;
        if (i > tmp_size_idx_1 - 1) {
          i = 0;
          i1++;
        }
        if (loop_ub > 14) {
          loop_ub = 0;
          i2++;
        }
      }
      for (i = 0; i < tmp_size_idx_1; i++) {
        for (i1 = 0; i1 < tmp_size_idx_2; i1++) {
          sdvals[(i1 + sdvals.size(2) * i) +
                 sdvals.size(2) * sdvals.size(1) * q] =
              tmp_data[i1 + tmp_size_idx_2 * i];
        }
      }
    }
    break;
  case 86:
//  Choose a mode for parfor
// ompForSerial - Transform a parfor loop to run in serial
//
//       ompForSerial
//
//  Note
//  ----
//
//  This directive must appear immediately before the parfor loop to be
//  affected.
//
//  Example
//  -------
//     ompForSerial;
//     parfor i=1:N
//        x(i) = y(i) + z(i);
//     end
//
//  See also ompSimd, ompSimdWithFor, ompForWithPar, ompForInPar
#pragma m2c ompForSerial();
    //  Serial mode
    ub_loop = cs.size(0) - 1;
#pragma omp parallel for num_threads(omp_get_max_threads()) private(           \
    dv1, dv3, loop_ub, i, unnamed_idx_1, unnamed_idx_2, i1, i2,                \
    tmp_size_idx_2, tmp_size_idx_1, i3, tmp_data)

    for (int32_T q = 0; q <= ub_loop; q++) {
      tri_fek_21(cs[cs.size(1) * q], cs[cs.size(1) * q + 1], dv3, dv1);
      loop_ub = sfvals.size(1);
      for (i = 0; i < loop_ub; i++) {
        sfvals[i + sfvals.size(1) * q] = dv3[i];
      }
      unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i = 0;
      i1 = 0;
      loop_ub = 0;
      i2 = 0;
      tmp_size_idx_2 = sdvals.size(2);
      tmp_size_idx_1 = sdvals.size(1);
      for (i3 = 0; i3 < unnamed_idx_1 * unnamed_idx_2; i3++) {
        tmp_data[i1 + tmp_size_idx_2 * i] = dv1[i2 + (loop_ub << 1)];
        loop_ub++;
        i++;
        if (i > tmp_size_idx_1 - 1) {
          i = 0;
          i1++;
        }
        if (loop_ub > 20) {
          loop_ub = 0;
          i2++;
        }
      }
      for (i = 0; i < tmp_size_idx_1; i++) {
        for (i1 = 0; i1 < tmp_size_idx_2; i1++) {
          sdvals[(i1 + sdvals.size(2) * i) +
                 sdvals.size(2) * sdvals.size(1) * q] =
              tmp_data[i1 + tmp_size_idx_2 * i];
        }
      }
    }
    break;
  default:
    //  m2cAssert  Throw error if condition false at runtime
    //
    //    m2cAssert(cond)
    //    m2cAssert(cond,msg)
    //    m2cAssert(cond,msg,A1,...,An)
    //    m2cAssert(cond,errID,msg)
    //    m2cAssert(cond,errID,msg,A1,...,An)
    //
    //  The interface of `m2cAssert` is compatible with MATLAB's built-in
    //  `assert`,  but it generates runtime assertion instead of compile-time
    //  assertion.
    //
    //  Note
    //  ----
    //  The MATLAB built-in `assert` is mostly used for compile-time error
    //  checking, and it has no effect for runtime error checking in LIB mode.
    //  Use `m2cAssert` instead for runtime error checking. Like the built-in
    //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
    //  into a code-generation-time character string. If you want to use both
    //  code-generation-time and runtime assertions, it is recommended to put
    //  `m2cAssert` before the built-in `assert`.
    //
    //  See also assert, m2cError, m2cWarning
    m2cAssert(etype == 90, "Only supports up to sextic.");
//  Choose a mode for parfor
// ompForSerial - Transform a parfor loop to run in serial
//
//       ompForSerial
//
//  Note
//  ----
//
//  This directive must appear immediately before the parfor loop to be
//  affected.
//
//  Example
//  -------
//     ompForSerial;
//     parfor i=1:N
//        x(i) = y(i) + z(i);
//     end
//
//  See also ompSimd, ompSimdWithFor, ompForWithPar, ompForInPar
#pragma m2c ompForSerial();
    //  Serial mode
    ub_loop = cs.size(0) - 1;
#pragma omp parallel for num_threads(omp_get_max_threads()) private(           \
    dv4, dv5, loop_ub, i, unnamed_idx_1, unnamed_idx_2, i1, i2,                \
    tmp_size_idx_2, tmp_size_idx_1, i3, tmp_data)

    for (int32_T q = 0; q <= ub_loop; q++) {
      tri_fek_28(cs[cs.size(1) * q], cs[cs.size(1) * q + 1], dv5, dv4);
      loop_ub = sfvals.size(1);
      for (i = 0; i < loop_ub; i++) {
        sfvals[i + sfvals.size(1) * q] = dv5[i];
      }
      unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i = 0;
      i1 = 0;
      loop_ub = 0;
      i2 = 0;
      tmp_size_idx_2 = sdvals.size(2);
      tmp_size_idx_1 = sdvals.size(1);
      for (i3 = 0; i3 < unnamed_idx_1 * unnamed_idx_2; i3++) {
        tmp_data[i1 + tmp_size_idx_2 * i] = dv4[i2 + (loop_ub << 1)];
        loop_ub++;
        i++;
        if (i > tmp_size_idx_1 - 1) {
          i = 0;
          i1++;
        }
        if (loop_ub > 27) {
          loop_ub = 0;
          i2++;
        }
      }
      for (i = 0; i < tmp_size_idx_1; i++) {
        for (i1 = 0; i1 < tmp_size_idx_2; i1++) {
          sdvals[(i1 + sdvals.size(2) * i) +
                 sdvals.size(2) * sdvals.size(1) * q] =
              tmp_data[i1 + tmp_size_idx_2 * i];
        }
      }
    }
    break;
  }
}

static void sfe2_tabulate_gl_quad(int32_T etype,
                                  const ::coder::array<real_T, 2U> &cs,
                                  ::coder::array<real_T, 2U> &sfvals,
                                  ::coder::array<real_T, 3U> &sdvals)
{
  real_T b_tmp_data[1029];
  real_T tmp_data[1029];
  real_T dv6[98];
  real_T dv3[72];
  real_T dv2[50];
  real_T dv7[49];
  real_T dv5[36];
  real_T dv4[25];
  int32_T b_tmp_size_idx_1;
  int32_T b_tmp_size_idx_2;
  int32_T i;
  int32_T i4;
  int32_T i5;
  int32_T i6;
  int32_T i7;
  int32_T loop_ub;
  int32_T nqp;
  int16_T b_unnamed_idx_1;
  int16_T b_unnamed_idx_2;
  //  quad
  nqp = cs.size(0);
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  i = iv[etype - 1];
  sfvals.set_size(cs.size(0), i);
  sdvals.set_size(cs.size(0), i, cs.size(1));
  switch (etype) {
  case 109: {
    for (int32_T q{0}; q < nqp; q++) {
      real_T dv1[32];
      real_T dv[16];
      int32_T i1;
      int32_T i2;
      int32_T tmp_size_idx_1;
      int32_T tmp_size_idx_2;
      int32_T ub_loop;
      int16_T unnamed_idx_1;
      int16_T unnamed_idx_2;
      // quad_gl_16 - Bicubic quadrilateral element with Gauss-Lobatto points
      //     [sfvals,sdvals] = quad_gl_16(xi,eta)
      //
      //   Input:
      //      xi, eta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 16-by-1
      //      sdvals: vector of size 16-by-2
      //
      //     NAT_COORS = quad_gl_16
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also quad_4, quad_9, quad_16, quad_25, quad_gl_25
      ::sfe_sfuncs::quad_gl_16_sfunc(cs[cs.size(1) * q], cs[cs.size(1) * q + 1],
                                     &dv[0], &dv1[0]);
      ub_loop = sfvals.size(1);
      for (i = 0; i < ub_loop; i++) {
        sfvals[i + sfvals.size(1) * q] = dv[i];
      }
      unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i = 0;
      i1 = 0;
      ub_loop = 0;
      i2 = 0;
      tmp_size_idx_2 = sdvals.size(2);
      tmp_size_idx_1 = sdvals.size(1);
      for (int32_T i3{0}; i3 < unnamed_idx_1 * unnamed_idx_2; i3++) {
        tmp_data[i1 + tmp_size_idx_2 * i] = dv1[i2 + (ub_loop << 1)];
        ub_loop++;
        i++;
        if (i > tmp_size_idx_1 - 1) {
          i = 0;
          i1++;
        }
        if (ub_loop > 15) {
          ub_loop = 0;
          i2++;
        }
      }
      for (i = 0; i < tmp_size_idx_1; i++) {
        for (i1 = 0; i1 < tmp_size_idx_2; i1++) {
          sdvals[(i1 + sdvals.size(2) * i) +
                 sdvals.size(2) * sdvals.size(1) * q] =
              tmp_data[i1 + tmp_size_idx_2 * i];
        }
      }
    }
  } break;
  case 113: {
    int32_T ub_loop;
//  Choose a mode for parfor
// ompForSerial - Transform a parfor loop to run in serial
//
//       ompForSerial
//
//  Note
//  ----
//
//  This directive must appear immediately before the parfor loop to be
//  affected.
//
//  Example
//  -------
//     ompForSerial;
//     parfor i=1:N
//        x(i) = y(i) + z(i);
//     end
//
//  See also ompSimd, ompSimdWithFor, ompForWithPar, ompForInPar
#pragma m2c ompForSerial();
    //  Serial mode
    ub_loop = cs.size(0) - 1;
#pragma omp parallel for num_threads(omp_get_max_threads()) private(           \
    dv2, dv4, loop_ub, i4, b_unnamed_idx_1, b_unnamed_idx_2, i5, i6,           \
    b_tmp_size_idx_2, b_tmp_size_idx_1, i7, b_tmp_data)

    for (int32_T b_q = 0; b_q <= ub_loop; b_q++) {
      quad_gl_25(cs[cs.size(1) * b_q], cs[cs.size(1) * b_q + 1], dv4, dv2);
      loop_ub = sfvals.size(1);
      for (i4 = 0; i4 < loop_ub; i4++) {
        sfvals[i4 + sfvals.size(1) * b_q] = dv4[i4];
      }
      b_unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      b_unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i4 = 0;
      i5 = 0;
      loop_ub = 0;
      i6 = 0;
      b_tmp_size_idx_2 = sdvals.size(2);
      b_tmp_size_idx_1 = sdvals.size(1);
      for (i7 = 0; i7 < b_unnamed_idx_1 * b_unnamed_idx_2; i7++) {
        b_tmp_data[i5 + b_tmp_size_idx_2 * i4] = dv2[i6 + (loop_ub << 1)];
        loop_ub++;
        i4++;
        if (i4 > b_tmp_size_idx_1 - 1) {
          i4 = 0;
          i5++;
        }
        if (loop_ub > 24) {
          loop_ub = 0;
          i6++;
        }
      }
      for (i4 = 0; i4 < b_tmp_size_idx_1; i4++) {
        for (i5 = 0; i5 < b_tmp_size_idx_2; i5++) {
          sdvals[(i5 + sdvals.size(2) * i4) +
                 sdvals.size(2) * sdvals.size(1) * b_q] =
              b_tmp_data[i5 + b_tmp_size_idx_2 * i4];
        }
      }
    }
  } break;
  case 117: {
    int32_T ub_loop;
//  Choose a mode for parfor
// ompForSerial - Transform a parfor loop to run in serial
//
//       ompForSerial
//
//  Note
//  ----
//
//  This directive must appear immediately before the parfor loop to be
//  affected.
//
//  Example
//  -------
//     ompForSerial;
//     parfor i=1:N
//        x(i) = y(i) + z(i);
//     end
//
//  See also ompSimd, ompSimdWithFor, ompForWithPar, ompForInPar
#pragma m2c ompForSerial();
    //  Serial mode
    ub_loop = cs.size(0) - 1;
#pragma omp parallel for num_threads(omp_get_max_threads()) private(           \
    dv3, dv5, loop_ub, i4, b_unnamed_idx_1, b_unnamed_idx_2, i5, i6,           \
    b_tmp_size_idx_2, b_tmp_size_idx_1, i7, b_tmp_data)

    for (int32_T b_q = 0; b_q <= ub_loop; b_q++) {
      quad_gl_36(cs[cs.size(1) * b_q], cs[cs.size(1) * b_q + 1], dv5, dv3);
      loop_ub = sfvals.size(1);
      for (i4 = 0; i4 < loop_ub; i4++) {
        sfvals[i4 + sfvals.size(1) * b_q] = dv5[i4];
      }
      b_unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      b_unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i4 = 0;
      i5 = 0;
      loop_ub = 0;
      i6 = 0;
      b_tmp_size_idx_2 = sdvals.size(2);
      b_tmp_size_idx_1 = sdvals.size(1);
      for (i7 = 0; i7 < b_unnamed_idx_1 * b_unnamed_idx_2; i7++) {
        b_tmp_data[i5 + b_tmp_size_idx_2 * i4] = dv3[i6 + (loop_ub << 1)];
        loop_ub++;
        i4++;
        if (i4 > b_tmp_size_idx_1 - 1) {
          i4 = 0;
          i5++;
        }
        if (loop_ub > 35) {
          loop_ub = 0;
          i6++;
        }
      }
      for (i4 = 0; i4 < b_tmp_size_idx_1; i4++) {
        for (i5 = 0; i5 < b_tmp_size_idx_2; i5++) {
          sdvals[(i5 + sdvals.size(2) * i4) +
                 sdvals.size(2) * sdvals.size(1) * b_q] =
              b_tmp_data[i5 + b_tmp_size_idx_2 * i4];
        }
      }
    }
  } break;
  default: {
    int32_T ub_loop;
    //  m2cAssert  Throw error if condition false at runtime
    //
    //    m2cAssert(cond)
    //    m2cAssert(cond,msg)
    //    m2cAssert(cond,msg,A1,...,An)
    //    m2cAssert(cond,errID,msg)
    //    m2cAssert(cond,errID,msg,A1,...,An)
    //
    //  The interface of `m2cAssert` is compatible with MATLAB's built-in
    //  `assert`,  but it generates runtime assertion instead of compile-time
    //  assertion.
    //
    //  Note
    //  ----
    //  The MATLAB built-in `assert` is mostly used for compile-time error
    //  checking, and it has no effect for runtime error checking in LIB mode.
    //  Use `m2cAssert` instead for runtime error checking. Like the built-in
    //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
    //  into a code-generation-time character string. If you want to use both
    //  code-generation-time and runtime assertions, it is recommended to put
    //  `m2cAssert` before the built-in `assert`.
    //
    //  See also assert, m2cError, m2cWarning
    m2cAssert(etype == 121, "Only supports up to sextic.");
//  Choose a mode for parfor
// ompForSerial - Transform a parfor loop to run in serial
//
//       ompForSerial
//
//  Note
//  ----
//
//  This directive must appear immediately before the parfor loop to be
//  affected.
//
//  Example
//  -------
//     ompForSerial;
//     parfor i=1:N
//        x(i) = y(i) + z(i);
//     end
//
//  See also ompSimd, ompSimdWithFor, ompForWithPar, ompForInPar
#pragma m2c ompForSerial();
    //  Serial mode
    ub_loop = cs.size(0) - 1;
#pragma omp parallel for num_threads(omp_get_max_threads()) private(           \
    dv6, dv7, loop_ub, i4, b_unnamed_idx_1, b_unnamed_idx_2, i5, i6,           \
    b_tmp_size_idx_2, b_tmp_size_idx_1, i7, b_tmp_data)

    for (int32_T b_q = 0; b_q <= ub_loop; b_q++) {
      quad_gl_49(cs[cs.size(1) * b_q], cs[cs.size(1) * b_q + 1], dv7, dv6);
      loop_ub = sfvals.size(1);
      for (i4 = 0; i4 < loop_ub; i4++) {
        sfvals[i4 + sfvals.size(1) * b_q] = dv7[i4];
      }
      b_unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      b_unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i4 = 0;
      i5 = 0;
      loop_ub = 0;
      i6 = 0;
      b_tmp_size_idx_2 = sdvals.size(2);
      b_tmp_size_idx_1 = sdvals.size(1);
      for (i7 = 0; i7 < b_unnamed_idx_1 * b_unnamed_idx_2; i7++) {
        b_tmp_data[i5 + b_tmp_size_idx_2 * i4] = dv6[i6 + (loop_ub << 1)];
        loop_ub++;
        i4++;
        if (i4 > b_tmp_size_idx_1 - 1) {
          i4 = 0;
          i5++;
        }
        if (loop_ub > 48) {
          loop_ub = 0;
          i6++;
        }
      }
      for (i4 = 0; i4 < b_tmp_size_idx_1; i4++) {
        for (i5 = 0; i5 < b_tmp_size_idx_2; i5++) {
          sdvals[(i5 + sdvals.size(2) * i4) +
                 sdvals.size(2) * sdvals.size(1) * b_q] =
              b_tmp_data[i5 + b_tmp_size_idx_2 * i4];
        }
      }
    }
  } break;
  }
}

static void sfe2_tabulate_gl_tri(int32_T etype,
                                 const ::coder::array<real_T, 2U> &cs,
                                 ::coder::array<real_T, 2U> &sfvals,
                                 ::coder::array<real_T, 3U> &sdvals)
{
  real_T b_tmp_data[1029];
  real_T tmp_data[1029];
  real_T dv6[56];
  real_T dv4[42];
  real_T dv7[28];
  real_T dv5[21];
  int32_T b_tmp_size_idx_1;
  int32_T b_tmp_size_idx_2;
  int32_T i;
  int32_T i3;
  int32_T i5;
  int32_T i6;
  int32_T i7;
  int32_T loop_ub;
  int32_T nqp;
  int16_T b_unnamed_idx_1;
  int16_T b_unnamed_idx_2;
  //  triangular
  nqp = cs.size(0) - 1;
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  i = iv[etype - 1];
  sfvals.set_size(cs.size(0), i);
  sdvals.set_size(cs.size(0), i, cs.size(1));
  switch (etype) {
  case 77: {
    for (int32_T q{0}; q <= nqp; q++) {
      real_T dv2[20];
      real_T dv[10];
      int32_T i1;
      int32_T i2;
      int32_T tmp_size_idx_1;
      int32_T tmp_size_idx_2;
      int32_T ub_loop;
      int16_T unnamed_idx_1;
      int16_T unnamed_idx_2;
      // tri_gl_10 - Compute shape functions and their derivatives of tri_gl_10
      //
      //     ncoords = tri_gl_10
      //     [sfvals,sdvals] = tri_gl_10(xi,eta)
      //
      // Parameters
      // ----------
      //     xi,eta: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 10-by-1
      //     sdvals: vector of size 10-by-2
      ::sfe_sfuncs::tri_gl_10_sfunc(cs[cs.size(1) * q], cs[cs.size(1) * q + 1],
                                    &dv[0], &dv2[0]);
      ub_loop = sfvals.size(1);
      for (i = 0; i < ub_loop; i++) {
        sfvals[i + sfvals.size(1) * q] = dv[i];
      }
      unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i = 0;
      i1 = 0;
      ub_loop = 0;
      i2 = 0;
      tmp_size_idx_2 = sdvals.size(2);
      tmp_size_idx_1 = sdvals.size(1);
      for (int32_T i4{0}; i4 < unnamed_idx_1 * unnamed_idx_2; i4++) {
        tmp_data[i1 + tmp_size_idx_2 * i] = dv2[i2 + (ub_loop << 1)];
        ub_loop++;
        i++;
        if (i > tmp_size_idx_1 - 1) {
          i = 0;
          i1++;
        }
        if (ub_loop > 9) {
          ub_loop = 0;
          i2++;
        }
      }
      for (i = 0; i < tmp_size_idx_1; i++) {
        for (i1 = 0; i1 < tmp_size_idx_2; i1++) {
          sdvals[(i1 + sdvals.size(2) * i) +
                 sdvals.size(2) * sdvals.size(1) * q] =
              tmp_data[i1 + tmp_size_idx_2 * i];
        }
      }
    }
  } break;
  case 81: {
    for (int32_T q{0}; q <= nqp; q++) {
      real_T dv3[30];
      real_T dv1[15];
      int32_T i1;
      int32_T i2;
      int32_T tmp_size_idx_1;
      int32_T tmp_size_idx_2;
      int32_T ub_loop;
      int16_T unnamed_idx_1;
      int16_T unnamed_idx_2;
      // tri_gl_15 - Compute shape functions and their derivatives of tri_gl_15
      //
      //     ncoords = tri_gl_15
      //     [sfvals,sdvals] = tri_gl_15(xi,eta)
      //
      // Parameters
      // ----------
      //     xi,eta: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 15-by-1
      //     sdvals: vector of size 15-by-2
      ::sfe_sfuncs::tri_gl_15_sfunc(cs[cs.size(1) * q], cs[cs.size(1) * q + 1],
                                    &dv1[0], &dv3[0]);
      ub_loop = sfvals.size(1);
      for (i = 0; i < ub_loop; i++) {
        sfvals[i + sfvals.size(1) * q] = dv1[i];
      }
      unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i = 0;
      i1 = 0;
      ub_loop = 0;
      i2 = 0;
      tmp_size_idx_2 = sdvals.size(2);
      tmp_size_idx_1 = sdvals.size(1);
      for (int32_T i4{0}; i4 < unnamed_idx_1 * unnamed_idx_2; i4++) {
        tmp_data[i1 + tmp_size_idx_2 * i] = dv3[i2 + (ub_loop << 1)];
        ub_loop++;
        i++;
        if (i > tmp_size_idx_1 - 1) {
          i = 0;
          i1++;
        }
        if (ub_loop > 14) {
          ub_loop = 0;
          i2++;
        }
      }
      for (i = 0; i < tmp_size_idx_1; i++) {
        for (i1 = 0; i1 < tmp_size_idx_2; i1++) {
          sdvals[(i1 + sdvals.size(2) * i) +
                 sdvals.size(2) * sdvals.size(1) * q] =
              tmp_data[i1 + tmp_size_idx_2 * i];
        }
      }
    }
  } break;
  case 85: {
    int32_T ub_loop;
//  Choose a mode for parfor
// ompForSerial - Transform a parfor loop to run in serial
//
//       ompForSerial
//
//  Note
//  ----
//
//  This directive must appear immediately before the parfor loop to be
//  affected.
//
//  Example
//  -------
//     ompForSerial;
//     parfor i=1:N
//        x(i) = y(i) + z(i);
//     end
//
//  See also ompSimd, ompSimdWithFor, ompForWithPar, ompForInPar
#pragma m2c ompForSerial();
    //  Serial mode
    ub_loop = cs.size(0) - 1;
#pragma omp parallel for num_threads(omp_get_max_threads()) private(           \
    dv4, dv5, loop_ub, i3, b_unnamed_idx_1, b_unnamed_idx_2, i5, i6,           \
    b_tmp_size_idx_2, b_tmp_size_idx_1, i7, b_tmp_data)

    for (int32_T b_q = 0; b_q <= ub_loop; b_q++) {
      tri_gl_21(cs[cs.size(1) * b_q], cs[cs.size(1) * b_q + 1], dv5, dv4);
      loop_ub = sfvals.size(1);
      for (i3 = 0; i3 < loop_ub; i3++) {
        sfvals[i3 + sfvals.size(1) * b_q] = dv5[i3];
      }
      b_unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      b_unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i3 = 0;
      i5 = 0;
      loop_ub = 0;
      i6 = 0;
      b_tmp_size_idx_2 = sdvals.size(2);
      b_tmp_size_idx_1 = sdvals.size(1);
      for (i7 = 0; i7 < b_unnamed_idx_1 * b_unnamed_idx_2; i7++) {
        b_tmp_data[i5 + b_tmp_size_idx_2 * i3] = dv4[i6 + (loop_ub << 1)];
        loop_ub++;
        i3++;
        if (i3 > b_tmp_size_idx_1 - 1) {
          i3 = 0;
          i5++;
        }
        if (loop_ub > 20) {
          loop_ub = 0;
          i6++;
        }
      }
      for (i3 = 0; i3 < b_tmp_size_idx_1; i3++) {
        for (i5 = 0; i5 < b_tmp_size_idx_2; i5++) {
          sdvals[(i5 + sdvals.size(2) * i3) +
                 sdvals.size(2) * sdvals.size(1) * b_q] =
              b_tmp_data[i5 + b_tmp_size_idx_2 * i3];
        }
      }
    }
  } break;
  default: {
    int32_T ub_loop;
    //  m2cAssert  Throw error if condition false at runtime
    //
    //    m2cAssert(cond)
    //    m2cAssert(cond,msg)
    //    m2cAssert(cond,msg,A1,...,An)
    //    m2cAssert(cond,errID,msg)
    //    m2cAssert(cond,errID,msg,A1,...,An)
    //
    //  The interface of `m2cAssert` is compatible with MATLAB's built-in
    //  `assert`,  but it generates runtime assertion instead of compile-time
    //  assertion.
    //
    //  Note
    //  ----
    //  The MATLAB built-in `assert` is mostly used for compile-time error
    //  checking, and it has no effect for runtime error checking in LIB mode.
    //  Use `m2cAssert` instead for runtime error checking. Like the built-in
    //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
    //  into a code-generation-time character string. If you want to use both
    //  code-generation-time and runtime assertions, it is recommended to put
    //  `m2cAssert` before the built-in `assert`.
    //
    //  See also assert, m2cError, m2cWarning
    m2cAssert(etype == 85, "Only support up to sextic");
//  Sextic GL points do not exist. Use Fekete points instead.
//  Choose a mode for parfor
// ompForSerial - Transform a parfor loop to run in serial
//
//       ompForSerial
//
//  Note
//  ----
//
//  This directive must appear immediately before the parfor loop to be
//  affected.
//
//  Example
//  -------
//     ompForSerial;
//     parfor i=1:N
//        x(i) = y(i) + z(i);
//     end
//
//  See also ompSimd, ompSimdWithFor, ompForWithPar, ompForInPar
#pragma m2c ompForSerial();
    //  Serial mode
    ub_loop = cs.size(0) - 1;
#pragma omp parallel for num_threads(omp_get_max_threads()) private(           \
    dv6, dv7, loop_ub, i3, b_unnamed_idx_1, b_unnamed_idx_2, i5, i6,           \
    b_tmp_size_idx_2, b_tmp_size_idx_1, i7, b_tmp_data)

    for (int32_T b_q = 0; b_q <= ub_loop; b_q++) {
      tri_fek_28(cs[cs.size(1) * b_q], cs[cs.size(1) * b_q + 1], dv7, dv6);
      loop_ub = sfvals.size(1);
      for (i3 = 0; i3 < loop_ub; i3++) {
        sfvals[i3 + sfvals.size(1) * b_q] = dv7[i3];
      }
      b_unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      b_unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i3 = 0;
      i5 = 0;
      loop_ub = 0;
      i6 = 0;
      b_tmp_size_idx_2 = sdvals.size(2);
      b_tmp_size_idx_1 = sdvals.size(1);
      for (i7 = 0; i7 < b_unnamed_idx_1 * b_unnamed_idx_2; i7++) {
        b_tmp_data[i5 + b_tmp_size_idx_2 * i3] = dv6[i6 + (loop_ub << 1)];
        loop_ub++;
        i3++;
        if (i3 > b_tmp_size_idx_1 - 1) {
          i3 = 0;
          i5++;
        }
        if (loop_ub > 27) {
          loop_ub = 0;
          i6++;
        }
      }
      for (i3 = 0; i3 < b_tmp_size_idx_1; i3++) {
        for (i5 = 0; i5 < b_tmp_size_idx_2; i5++) {
          sdvals[(i5 + sdvals.size(2) * i3) +
                 sdvals.size(2) * sdvals.size(1) * b_q] =
              b_tmp_data[i5 + b_tmp_size_idx_2 * i3];
        }
      }
    }
  } break;
  }
}

static void sfe2_tabulate_shapefuncs(int32_T etype,
                                     const ::coder::array<real_T, 2U> &cs,
                                     ::coder::array<real_T, 2U> &sfvals,
                                     ::coder::array<real_T, 3U> &sdvals)
{
  // sfe2_tabulate_shapefuncs - Tabulate shape functions and sdvals at given
  // points
  //
  //    [sfvals, sdvals] = sfe2_tabulate_shapefuncs(etype, cs)
  //    [sfvals, sdvals] = sfe2_tabulate_shapefuncs(etype, cs, []) ** Advanced
  //    OpenMP ** [sfvals, sdvals] = sfe2_tabulate_shapefuncs(etype, cs, [],
  //    nthreads)  ** Basic OpenMP **
  //
  //  See also sfe1_tabulate_shapefuncs, sfe3_tabulate_shapefuncs
  // obtain_elemnodepos - Decode nodal position types, e.g., equidistance, GL
  //
  //    postype = obtain_elemnodepos(etype)
  //
  //  RETURNS
  //  -------
  //    postype:    Position type tag:
  //                    0: equidistance
  //                    1: GL
  //                    2: ...
  //
  //  See also obtain_elemdegree
  //  postype = etype&0b11
  switch (etype & 3) {
  case 0:
    //  equi kernel
    // obtain_elemshape - Decode an element geometric shape from etype
    //
    //    shapeid = obtain_elemshape(etype)
    //
    //  RETURN
    //  ------
    //    shapeid:    Integer type of different geometry shapes:
    //                    1 - BAR
    //                    2 - TRI
    //                    3 - QUAD
    //                    4 - TET
    //                    5 - PYRAMID
    //                    6 - PRISM
    //                    7 - HEX
    //
    //  See also obtain_elemdim
    //  shapeid = (etype>>5)&0b111
    if ((etype >> 5 & 7) == 2) {
      sfe2_tabulate_equi_tri(etype, cs, sfvals, sdvals);
    } else {
      sfe2_tabulate_equi_quad(etype, cs, sfvals, sdvals);
    }
    break;
  case 1:
    //  GL kernel
    // obtain_elemshape - Decode an element geometric shape from etype
    //
    //    shapeid = obtain_elemshape(etype)
    //
    //  RETURN
    //  ------
    //    shapeid:    Integer type of different geometry shapes:
    //                    1 - BAR
    //                    2 - TRI
    //                    3 - QUAD
    //                    4 - TET
    //                    5 - PYRAMID
    //                    6 - PRISM
    //                    7 - HEX
    //
    //  See also obtain_elemdim
    //  shapeid = (etype>>5)&0b111
    if ((etype >> 5 & 7) == 2) {
      sfe2_tabulate_gl_tri(etype, cs, sfvals, sdvals);
    } else {
      sfe2_tabulate_gl_quad(etype, cs, sfvals, sdvals);
    }
    break;
  default:
    //  FEK kernel
    //  Must be tri
    sfe2_tabulate_fek_tri(etype, cs, sfvals, sdvals);
    break;
  }
}

static void sfe3_tabulate_equi_hexa(int32_T etype,
                                    const ::coder::array<real_T, 2U> &cs,
                                    ::coder::array<real_T, 2U> &sfvals,
                                    ::coder::array<real_T, 3U> &sdvals)
{
  real_T b_tmp_data[1029];
  real_T dv10[1029];
  real_T tmp_data[1029];
  real_T dv6[648];
  real_T dv5[375];
  real_T dv11[343];
  real_T dv9[216];
  real_T dv4[192];
  real_T dv8[125];
  real_T dv7[64];
  int32_T b_tmp_size_idx_1;
  int32_T b_tmp_size_idx_2;
  int32_T i;
  int32_T i4;
  int32_T i5;
  int32_T i6;
  int32_T i7;
  int32_T loop_ub;
  int32_T nqp;
  int16_T b_unnamed_idx_1;
  int16_T b_unnamed_idx_2;
  //  hex
  nqp = cs.size(0) - 1;
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  i = iv[etype - 1];
  sfvals.set_size(cs.size(0), i);
  sdvals.set_size(cs.size(0), i, cs.size(1));
  switch (etype) {
  case 228: {
    for (int32_T q{0}; q <= nqp; q++) {
      real_T dv2[24];
      real_T dv[8];
      int32_T i1;
      int32_T i2;
      int32_T tmp_size_idx_1;
      int32_T tmp_size_idx_2;
      int32_T ub_loop;
      int16_T unnamed_idx_1;
      int16_T unnamed_idx_2;
      // hexa_8 - Trilinear hexahedral element
      //     [sfvals,sdvals] = hexa_8(xi,eta,zeta)
      //
      //   Input:
      //      xi, eta, zeta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 8-by-1
      //      sdvals: vector of size 8-by-3
      //
      //     nodes_nat_coors = hexa_8
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also hexa_27, hexa_64, hexa_gl_64, hexa_125, hexa_gl_125
      ::sfe_sfuncs::hexa_8_sfunc(cs[cs.size(1) * q], cs[cs.size(1) * q + 1],
                                 cs[cs.size(1) * q + 2], &dv[0], &dv2[0]);
      ub_loop = sfvals.size(1);
      for (i = 0; i < ub_loop; i++) {
        sfvals[i + sfvals.size(1) * q] = dv[i];
      }
      unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i = 0;
      i1 = 0;
      ub_loop = 0;
      i2 = 0;
      tmp_size_idx_2 = sdvals.size(2);
      tmp_size_idx_1 = sdvals.size(1);
      for (int32_T i3{0}; i3 < unnamed_idx_1 * unnamed_idx_2; i3++) {
        tmp_data[i1 + tmp_size_idx_2 * i] = dv2[i2 + 3 * ub_loop];
        ub_loop++;
        i++;
        if (i > tmp_size_idx_1 - 1) {
          i = 0;
          i1++;
        }
        if (ub_loop > 7) {
          ub_loop = 0;
          i2++;
        }
      }
      for (i = 0; i < tmp_size_idx_1; i++) {
        for (i1 = 0; i1 < tmp_size_idx_2; i1++) {
          sdvals[(i1 + sdvals.size(2) * i) +
                 sdvals.size(2) * sdvals.size(1) * q] =
              tmp_data[i1 + tmp_size_idx_2 * i];
        }
      }
    }
  } break;
  case 232: {
    for (int32_T q{0}; q <= nqp; q++) {
      real_T dv3[81];
      real_T dv1[27];
      int32_T i1;
      int32_T i2;
      int32_T tmp_size_idx_1;
      int32_T tmp_size_idx_2;
      int32_T ub_loop;
      int16_T unnamed_idx_1;
      int16_T unnamed_idx_2;
      // hexa_27 - Triquadratic hexahedral element with equidistant nodes
      //     [sfvals,sdvals] = hexa_27(xi,eta,zeta)
      //
      //   Input:
      //      xi, eta, zeta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 27-by-1
      //      sdvals: vector of size 27-by-3
      //
      //     nodes_nat_coors = hexa_27
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also hexa_8, hexa_64, hexa_gl_64, hexa_125, hexa_gl_125
      ::sfe_sfuncs::hexa_27_sfunc(cs[cs.size(1) * q], cs[cs.size(1) * q + 1],
                                  cs[cs.size(1) * q + 2], &dv1[0], &dv3[0]);
      ub_loop = sfvals.size(1);
      for (i = 0; i < ub_loop; i++) {
        sfvals[i + sfvals.size(1) * q] = dv1[i];
      }
      unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i = 0;
      i1 = 0;
      ub_loop = 0;
      i2 = 0;
      tmp_size_idx_2 = sdvals.size(2);
      tmp_size_idx_1 = sdvals.size(1);
      for (int32_T i3{0}; i3 < unnamed_idx_1 * unnamed_idx_2; i3++) {
        tmp_data[i1 + tmp_size_idx_2 * i] = dv3[i2 + 3 * ub_loop];
        ub_loop++;
        i++;
        if (i > tmp_size_idx_1 - 1) {
          i = 0;
          i1++;
        }
        if (ub_loop > 26) {
          ub_loop = 0;
          i2++;
        }
      }
      for (i = 0; i < tmp_size_idx_1; i++) {
        for (i1 = 0; i1 < tmp_size_idx_2; i1++) {
          sdvals[(i1 + sdvals.size(2) * i) +
                 sdvals.size(2) * sdvals.size(1) * q] =
              tmp_data[i1 + tmp_size_idx_2 * i];
        }
      }
    }
  } break;
  case 236: {
    int32_T ub_loop;
//  Choose a mode for parfor
// ompForSerial - Transform a parfor loop to run in serial
//
//       ompForSerial
//
//  Note
//  ----
//
//  This directive must appear immediately before the parfor loop to be
//  affected.
//
//  Example
//  -------
//     ompForSerial;
//     parfor i=1:N
//        x(i) = y(i) + z(i);
//     end
//
//  See also ompSimd, ompSimdWithFor, ompForWithPar, ompForInPar
#pragma m2c ompForSerial();
    //  Serial mode
    ub_loop = cs.size(0) - 1;
#pragma omp parallel for num_threads(omp_get_max_threads()) private(           \
    dv4, dv7, loop_ub, i4, b_unnamed_idx_1, b_unnamed_idx_2, i5, i6,           \
    b_tmp_size_idx_2, b_tmp_size_idx_1, i7, b_tmp_data)

    for (int32_T b_q = 0; b_q <= ub_loop; b_q++) {
      hexa_64(cs[cs.size(1) * b_q], cs[cs.size(1) * b_q + 1],
              cs[cs.size(1) * b_q + 2], dv7, dv4);
      loop_ub = sfvals.size(1);
      for (i4 = 0; i4 < loop_ub; i4++) {
        sfvals[i4 + sfvals.size(1) * b_q] = dv7[i4];
      }
      b_unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      b_unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i4 = 0;
      i5 = 0;
      loop_ub = 0;
      i6 = 0;
      b_tmp_size_idx_2 = sdvals.size(2);
      b_tmp_size_idx_1 = sdvals.size(1);
      for (i7 = 0; i7 < b_unnamed_idx_1 * b_unnamed_idx_2; i7++) {
        b_tmp_data[i5 + b_tmp_size_idx_2 * i4] = dv4[i6 + 3 * loop_ub];
        loop_ub++;
        i4++;
        if (i4 > b_tmp_size_idx_1 - 1) {
          i4 = 0;
          i5++;
        }
        if (loop_ub > 63) {
          loop_ub = 0;
          i6++;
        }
      }
      for (i4 = 0; i4 < b_tmp_size_idx_1; i4++) {
        for (i5 = 0; i5 < b_tmp_size_idx_2; i5++) {
          sdvals[(i5 + sdvals.size(2) * i4) +
                 sdvals.size(2) * sdvals.size(1) * b_q] =
              b_tmp_data[i5 + b_tmp_size_idx_2 * i4];
        }
      }
    }
  } break;
  case 240: {
    int32_T ub_loop;
//  Choose a mode for parfor
// ompForSerial - Transform a parfor loop to run in serial
//
//       ompForSerial
//
//  Note
//  ----
//
//  This directive must appear immediately before the parfor loop to be
//  affected.
//
//  Example
//  -------
//     ompForSerial;
//     parfor i=1:N
//        x(i) = y(i) + z(i);
//     end
//
//  See also ompSimd, ompSimdWithFor, ompForWithPar, ompForInPar
#pragma m2c ompForSerial();
    //  Serial mode
    ub_loop = cs.size(0) - 1;
#pragma omp parallel for num_threads(omp_get_max_threads()) private(           \
    dv5, dv8, loop_ub, i4, b_unnamed_idx_1, b_unnamed_idx_2, i5, i6,           \
    b_tmp_size_idx_2, b_tmp_size_idx_1, i7, b_tmp_data)

    for (int32_T b_q = 0; b_q <= ub_loop; b_q++) {
      hexa_125(cs[cs.size(1) * b_q], cs[cs.size(1) * b_q + 1],
               cs[cs.size(1) * b_q + 2], dv8, dv5);
      loop_ub = sfvals.size(1);
      for (i4 = 0; i4 < loop_ub; i4++) {
        sfvals[i4 + sfvals.size(1) * b_q] = dv8[i4];
      }
      b_unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      b_unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i4 = 0;
      i5 = 0;
      loop_ub = 0;
      i6 = 0;
      b_tmp_size_idx_2 = sdvals.size(2);
      b_tmp_size_idx_1 = sdvals.size(1);
      for (i7 = 0; i7 < b_unnamed_idx_1 * b_unnamed_idx_2; i7++) {
        b_tmp_data[i5 + b_tmp_size_idx_2 * i4] = dv5[i6 + 3 * loop_ub];
        loop_ub++;
        i4++;
        if (i4 > b_tmp_size_idx_1 - 1) {
          i4 = 0;
          i5++;
        }
        if (loop_ub > 124) {
          loop_ub = 0;
          i6++;
        }
      }
      for (i4 = 0; i4 < b_tmp_size_idx_1; i4++) {
        for (i5 = 0; i5 < b_tmp_size_idx_2; i5++) {
          sdvals[(i5 + sdvals.size(2) * i4) +
                 sdvals.size(2) * sdvals.size(1) * b_q] =
              b_tmp_data[i5 + b_tmp_size_idx_2 * i4];
        }
      }
    }
  } break;
  case 244: {
    int32_T ub_loop;
//  Choose a mode for parfor
// ompForSerial - Transform a parfor loop to run in serial
//
//       ompForSerial
//
//  Note
//  ----
//
//  This directive must appear immediately before the parfor loop to be
//  affected.
//
//  Example
//  -------
//     ompForSerial;
//     parfor i=1:N
//        x(i) = y(i) + z(i);
//     end
//
//  See also ompSimd, ompSimdWithFor, ompForWithPar, ompForInPar
#pragma m2c ompForSerial();
    //  Serial mode
    ub_loop = cs.size(0) - 1;
#pragma omp parallel for num_threads(omp_get_max_threads()) private(           \
    dv6, dv9, loop_ub, i4, b_unnamed_idx_1, b_unnamed_idx_2, i5, i6,           \
    b_tmp_size_idx_2, b_tmp_size_idx_1, i7, b_tmp_data)

    for (int32_T b_q = 0; b_q <= ub_loop; b_q++) {
      hexa_216(cs[cs.size(1) * b_q], cs[cs.size(1) * b_q + 1],
               cs[cs.size(1) * b_q + 2], dv9, dv6);
      loop_ub = sfvals.size(1);
      for (i4 = 0; i4 < loop_ub; i4++) {
        sfvals[i4 + sfvals.size(1) * b_q] = dv9[i4];
      }
      b_unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      b_unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i4 = 0;
      i5 = 0;
      loop_ub = 0;
      i6 = 0;
      b_tmp_size_idx_2 = sdvals.size(2);
      b_tmp_size_idx_1 = sdvals.size(1);
      for (i7 = 0; i7 < b_unnamed_idx_1 * b_unnamed_idx_2; i7++) {
        b_tmp_data[i5 + b_tmp_size_idx_2 * i4] = dv6[i6 + 3 * loop_ub];
        loop_ub++;
        i4++;
        if (i4 > b_tmp_size_idx_1 - 1) {
          i4 = 0;
          i5++;
        }
        if (loop_ub > 215) {
          loop_ub = 0;
          i6++;
        }
      }
      for (i4 = 0; i4 < b_tmp_size_idx_1; i4++) {
        for (i5 = 0; i5 < b_tmp_size_idx_2; i5++) {
          sdvals[(i5 + sdvals.size(2) * i4) +
                 sdvals.size(2) * sdvals.size(1) * b_q] =
              b_tmp_data[i5 + b_tmp_size_idx_2 * i4];
        }
      }
    }
  } break;
  default: {
    int32_T ub_loop;
    //  m2cAssert  Throw error if condition false at runtime
    //
    //    m2cAssert(cond)
    //    m2cAssert(cond,msg)
    //    m2cAssert(cond,msg,A1,...,An)
    //    m2cAssert(cond,errID,msg)
    //    m2cAssert(cond,errID,msg,A1,...,An)
    //
    //  The interface of `m2cAssert` is compatible with MATLAB's built-in
    //  `assert`,  but it generates runtime assertion instead of compile-time
    //  assertion.
    //
    //  Note
    //  ----
    //  The MATLAB built-in `assert` is mostly used for compile-time error
    //  checking, and it has no effect for runtime error checking in LIB mode.
    //  Use `m2cAssert` instead for runtime error checking. Like the built-in
    //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
    //  into a code-generation-time character string. If you want to use both
    //  code-generation-time and runtime assertions, it is recommended to put
    //  `m2cAssert` before the built-in `assert`.
    //
    //  See also assert, m2cError, m2cWarning
    m2cAssert(etype == 248, "Hex elements supports up to sextic.");
//  Choose a mode for parfor
// ompForSerial - Transform a parfor loop to run in serial
//
//       ompForSerial
//
//  Note
//  ----
//
//  This directive must appear immediately before the parfor loop to be
//  affected.
//
//  Example
//  -------
//     ompForSerial;
//     parfor i=1:N
//        x(i) = y(i) + z(i);
//     end
//
//  See also ompSimd, ompSimdWithFor, ompForWithPar, ompForInPar
#pragma m2c ompForSerial();
    //  Serial mode
    ub_loop = cs.size(0) - 1;
#pragma omp parallel for num_threads(omp_get_max_threads()) private(           \
    dv10, dv11, loop_ub, i4, b_unnamed_idx_1, b_unnamed_idx_2, i5, i6,         \
    b_tmp_size_idx_2, b_tmp_size_idx_1, i7, b_tmp_data)

    for (int32_T b_q = 0; b_q <= ub_loop; b_q++) {
      hexa_343(cs[cs.size(1) * b_q], cs[cs.size(1) * b_q + 1],
               cs[cs.size(1) * b_q + 2], dv11, dv10);
      loop_ub = sfvals.size(1);
      for (i4 = 0; i4 < loop_ub; i4++) {
        sfvals[i4 + sfvals.size(1) * b_q] = dv11[i4];
      }
      b_unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      b_unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i4 = 0;
      i5 = 0;
      loop_ub = 0;
      i6 = 0;
      b_tmp_size_idx_2 = sdvals.size(2);
      b_tmp_size_idx_1 = sdvals.size(1);
      for (i7 = 0; i7 < b_unnamed_idx_1 * b_unnamed_idx_2; i7++) {
        b_tmp_data[i5 + b_tmp_size_idx_2 * i4] = dv10[i6 + 3 * loop_ub];
        loop_ub++;
        i4++;
        if (i4 > b_tmp_size_idx_1 - 1) {
          i4 = 0;
          i5++;
        }
        if (loop_ub > 342) {
          loop_ub = 0;
          i6++;
        }
      }
      for (i4 = 0; i4 < b_tmp_size_idx_1; i4++) {
        for (i5 = 0; i5 < b_tmp_size_idx_2; i5++) {
          sdvals[(i5 + sdvals.size(2) * i4) +
                 sdvals.size(2) * sdvals.size(1) * b_q] =
              b_tmp_data[i5 + b_tmp_size_idx_2 * i4];
        }
      }
    }
  } break;
  }
}

static void sfe3_tabulate_equi_prism(int32_T etype,
                                     const ::coder::array<real_T, 2U> &cs,
                                     ::coder::array<real_T, 2U> &sfvals,
                                     ::coder::array<real_T, 3U> &sdvals)
{
  real_T b_tmp_data[1029];
  real_T tmp_data[1029];
  real_T dv9[588];
  real_T dv5[378];
  real_T dv4[225];
  real_T dv10[196];
  real_T dv8[126];
  real_T dv3[120];
  real_T dv7[75];
  real_T dv6[40];
  int32_T b_tmp_size_idx_1;
  int32_T b_tmp_size_idx_2;
  int32_T i;
  int32_T i4;
  int32_T i5;
  int32_T i6;
  int32_T i7;
  int32_T loop_ub;
  int32_T nqp;
  int16_T b_unnamed_idx_1;
  int16_T b_unnamed_idx_2;
  //  prisms
  nqp = cs.size(0) - 1;
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  i = iv[etype - 1];
  sfvals.set_size(cs.size(0), i);
  sdvals.set_size(cs.size(0), i, cs.size(1));
  switch (etype) {
  case 196: {
    for (int32_T q{0}; q <= nqp; q++) {
      real_T dv1[18];
      real_T dv[6];
      int32_T i1;
      int32_T i2;
      int32_T tmp_size_idx_1;
      int32_T tmp_size_idx_2;
      int32_T ub_loop;
      int16_T unnamed_idx_1;
      int16_T unnamed_idx_2;
      // prism_6 - Linear prismatic element
      //     [sfvals,sdvals] = prism_6(xi,eta,zeta)
      //
      //   Input:
      //      xi, eta, zeta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 6-by-1
      //      sdvals: vector of size 6-by-3
      //
      //     nodes_nat_coors = prism_6
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also prism_18, prism_40, prism_gl_40, prism_75, prism_gl_75
      ::sfe_sfuncs::prism_6_sfunc(cs[cs.size(1) * q], cs[cs.size(1) * q + 1],
                                  cs[cs.size(1) * q + 2], &dv[0], &dv1[0]);
      ub_loop = sfvals.size(1);
      for (i = 0; i < ub_loop; i++) {
        sfvals[i + sfvals.size(1) * q] = dv[i];
      }
      unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i = 0;
      i1 = 0;
      ub_loop = 0;
      i2 = 0;
      tmp_size_idx_2 = sdvals.size(2);
      tmp_size_idx_1 = sdvals.size(1);
      for (int32_T i3{0}; i3 < unnamed_idx_1 * unnamed_idx_2; i3++) {
        tmp_data[i1 + tmp_size_idx_2 * i] = dv1[i2 + 3 * ub_loop];
        ub_loop++;
        i++;
        if (i > tmp_size_idx_1 - 1) {
          i = 0;
          i1++;
        }
        if (ub_loop > 5) {
          ub_loop = 0;
          i2++;
        }
      }
      for (i = 0; i < tmp_size_idx_1; i++) {
        for (i1 = 0; i1 < tmp_size_idx_2; i1++) {
          sdvals[(i1 + sdvals.size(2) * i) +
                 sdvals.size(2) * sdvals.size(1) * q] =
              tmp_data[i1 + tmp_size_idx_2 * i];
        }
      }
    }
  } break;
  case 200: {
    for (int32_T q{0}; q <= nqp; q++) {
      real_T dv2[54];
      real_T dv1[18];
      int32_T i1;
      int32_T i2;
      int32_T tmp_size_idx_1;
      int32_T tmp_size_idx_2;
      int32_T ub_loop;
      int16_T unnamed_idx_1;
      int16_T unnamed_idx_2;
      // prism_18 - Quadratic prismatic element
      //     [sfvals,sdvals] = prism_18(xi,eta,zeta)
      //
      //   Input:
      //      xi, eta, zeta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 18-by-1
      //      sdvals: vector of size 18-by-3
      //
      //     nodes_nat_coors = prism_18
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also prism_6, prism_40, prism_gl_40, prism_75, prism_gl_75
      ::sfe_sfuncs::prism_18_sfunc(cs[cs.size(1) * q], cs[cs.size(1) * q + 1],
                                   cs[cs.size(1) * q + 2], &dv1[0], &dv2[0]);
      ub_loop = sfvals.size(1);
      for (i = 0; i < ub_loop; i++) {
        sfvals[i + sfvals.size(1) * q] = dv1[i];
      }
      unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i = 0;
      i1 = 0;
      ub_loop = 0;
      i2 = 0;
      tmp_size_idx_2 = sdvals.size(2);
      tmp_size_idx_1 = sdvals.size(1);
      for (int32_T i3{0}; i3 < unnamed_idx_1 * unnamed_idx_2; i3++) {
        tmp_data[i1 + tmp_size_idx_2 * i] = dv2[i2 + 3 * ub_loop];
        ub_loop++;
        i++;
        if (i > tmp_size_idx_1 - 1) {
          i = 0;
          i1++;
        }
        if (ub_loop > 17) {
          ub_loop = 0;
          i2++;
        }
      }
      for (i = 0; i < tmp_size_idx_1; i++) {
        for (i1 = 0; i1 < tmp_size_idx_2; i1++) {
          sdvals[(i1 + sdvals.size(2) * i) +
                 sdvals.size(2) * sdvals.size(1) * q] =
              tmp_data[i1 + tmp_size_idx_2 * i];
        }
      }
    }
  } break;
  case 204: {
    int32_T ub_loop;
//  Choose a mode for parfor
// ompForSerial - Transform a parfor loop to run in serial
//
//       ompForSerial
//
//  Note
//  ----
//
//  This directive must appear immediately before the parfor loop to be
//  affected.
//
//  Example
//  -------
//     ompForSerial;
//     parfor i=1:N
//        x(i) = y(i) + z(i);
//     end
//
//  See also ompSimd, ompSimdWithFor, ompForWithPar, ompForInPar
#pragma m2c ompForSerial();
    //  Serial mode
    ub_loop = cs.size(0) - 1;
#pragma omp parallel for num_threads(omp_get_max_threads()) private(           \
    dv3, dv6, loop_ub, i4, b_unnamed_idx_1, b_unnamed_idx_2, i5, i6,           \
    b_tmp_size_idx_2, b_tmp_size_idx_1, i7, b_tmp_data)

    for (int32_T b_q = 0; b_q <= ub_loop; b_q++) {
      prism_40(cs[cs.size(1) * b_q], cs[cs.size(1) * b_q + 1],
               cs[cs.size(1) * b_q + 2], dv6, dv3);
      loop_ub = sfvals.size(1);
      for (i4 = 0; i4 < loop_ub; i4++) {
        sfvals[i4 + sfvals.size(1) * b_q] = dv6[i4];
      }
      b_unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      b_unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i4 = 0;
      i5 = 0;
      loop_ub = 0;
      i6 = 0;
      b_tmp_size_idx_2 = sdvals.size(2);
      b_tmp_size_idx_1 = sdvals.size(1);
      for (i7 = 0; i7 < b_unnamed_idx_1 * b_unnamed_idx_2; i7++) {
        b_tmp_data[i5 + b_tmp_size_idx_2 * i4] = dv3[i6 + 3 * loop_ub];
        loop_ub++;
        i4++;
        if (i4 > b_tmp_size_idx_1 - 1) {
          i4 = 0;
          i5++;
        }
        if (loop_ub > 39) {
          loop_ub = 0;
          i6++;
        }
      }
      for (i4 = 0; i4 < b_tmp_size_idx_1; i4++) {
        for (i5 = 0; i5 < b_tmp_size_idx_2; i5++) {
          sdvals[(i5 + sdvals.size(2) * i4) +
                 sdvals.size(2) * sdvals.size(1) * b_q] =
              b_tmp_data[i5 + b_tmp_size_idx_2 * i4];
        }
      }
    }
  } break;
  case 208: {
    int32_T ub_loop;
//  Choose a mode for parfor
// ompForSerial - Transform a parfor loop to run in serial
//
//       ompForSerial
//
//  Note
//  ----
//
//  This directive must appear immediately before the parfor loop to be
//  affected.
//
//  Example
//  -------
//     ompForSerial;
//     parfor i=1:N
//        x(i) = y(i) + z(i);
//     end
//
//  See also ompSimd, ompSimdWithFor, ompForWithPar, ompForInPar
#pragma m2c ompForSerial();
    //  Serial mode
    ub_loop = cs.size(0) - 1;
#pragma omp parallel for num_threads(omp_get_max_threads()) private(           \
    dv4, dv7, loop_ub, i4, b_unnamed_idx_1, b_unnamed_idx_2, i5, i6,           \
    b_tmp_size_idx_2, b_tmp_size_idx_1, i7, b_tmp_data)

    for (int32_T b_q = 0; b_q <= ub_loop; b_q++) {
      prism_75(cs[cs.size(1) * b_q], cs[cs.size(1) * b_q + 1],
               cs[cs.size(1) * b_q + 2], dv7, dv4);
      loop_ub = sfvals.size(1);
      for (i4 = 0; i4 < loop_ub; i4++) {
        sfvals[i4 + sfvals.size(1) * b_q] = dv7[i4];
      }
      b_unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      b_unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i4 = 0;
      i5 = 0;
      loop_ub = 0;
      i6 = 0;
      b_tmp_size_idx_2 = sdvals.size(2);
      b_tmp_size_idx_1 = sdvals.size(1);
      for (i7 = 0; i7 < b_unnamed_idx_1 * b_unnamed_idx_2; i7++) {
        b_tmp_data[i5 + b_tmp_size_idx_2 * i4] = dv4[i6 + 3 * loop_ub];
        loop_ub++;
        i4++;
        if (i4 > b_tmp_size_idx_1 - 1) {
          i4 = 0;
          i5++;
        }
        if (loop_ub > 74) {
          loop_ub = 0;
          i6++;
        }
      }
      for (i4 = 0; i4 < b_tmp_size_idx_1; i4++) {
        for (i5 = 0; i5 < b_tmp_size_idx_2; i5++) {
          sdvals[(i5 + sdvals.size(2) * i4) +
                 sdvals.size(2) * sdvals.size(1) * b_q] =
              b_tmp_data[i5 + b_tmp_size_idx_2 * i4];
        }
      }
    }
  } break;
  case 212: {
    int32_T ub_loop;
//  Choose a mode for parfor
// ompForSerial - Transform a parfor loop to run in serial
//
//       ompForSerial
//
//  Note
//  ----
//
//  This directive must appear immediately before the parfor loop to be
//  affected.
//
//  Example
//  -------
//     ompForSerial;
//     parfor i=1:N
//        x(i) = y(i) + z(i);
//     end
//
//  See also ompSimd, ompSimdWithFor, ompForWithPar, ompForInPar
#pragma m2c ompForSerial();
    //  Serial mode
    ub_loop = cs.size(0) - 1;
#pragma omp parallel for num_threads(omp_get_max_threads()) private(           \
    dv5, dv8, loop_ub, i4, b_unnamed_idx_1, b_unnamed_idx_2, i5, i6,           \
    b_tmp_size_idx_2, b_tmp_size_idx_1, i7, b_tmp_data)

    for (int32_T b_q = 0; b_q <= ub_loop; b_q++) {
      prism_126(cs[cs.size(1) * b_q], cs[cs.size(1) * b_q + 1],
                cs[cs.size(1) * b_q + 2], dv8, dv5);
      loop_ub = sfvals.size(1);
      for (i4 = 0; i4 < loop_ub; i4++) {
        sfvals[i4 + sfvals.size(1) * b_q] = dv8[i4];
      }
      b_unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      b_unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i4 = 0;
      i5 = 0;
      loop_ub = 0;
      i6 = 0;
      b_tmp_size_idx_2 = sdvals.size(2);
      b_tmp_size_idx_1 = sdvals.size(1);
      for (i7 = 0; i7 < b_unnamed_idx_1 * b_unnamed_idx_2; i7++) {
        b_tmp_data[i5 + b_tmp_size_idx_2 * i4] = dv5[i6 + 3 * loop_ub];
        loop_ub++;
        i4++;
        if (i4 > b_tmp_size_idx_1 - 1) {
          i4 = 0;
          i5++;
        }
        if (loop_ub > 125) {
          loop_ub = 0;
          i6++;
        }
      }
      for (i4 = 0; i4 < b_tmp_size_idx_1; i4++) {
        for (i5 = 0; i5 < b_tmp_size_idx_2; i5++) {
          sdvals[(i5 + sdvals.size(2) * i4) +
                 sdvals.size(2) * sdvals.size(1) * b_q] =
              b_tmp_data[i5 + b_tmp_size_idx_2 * i4];
        }
      }
    }
  } break;
  default: {
    int32_T ub_loop;
    //  m2cAssert  Throw error if condition false at runtime
    //
    //    m2cAssert(cond)
    //    m2cAssert(cond,msg)
    //    m2cAssert(cond,msg,A1,...,An)
    //    m2cAssert(cond,errID,msg)
    //    m2cAssert(cond,errID,msg,A1,...,An)
    //
    //  The interface of `m2cAssert` is compatible with MATLAB's built-in
    //  `assert`,  but it generates runtime assertion instead of compile-time
    //  assertion.
    //
    //  Note
    //  ----
    //  The MATLAB built-in `assert` is mostly used for compile-time error
    //  checking, and it has no effect for runtime error checking in LIB mode.
    //  Use `m2cAssert` instead for runtime error checking. Like the built-in
    //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
    //  into a code-generation-time character string. If you want to use both
    //  code-generation-time and runtime assertions, it is recommended to put
    //  `m2cAssert` before the built-in `assert`.
    //
    //  See also assert, m2cError, m2cWarning
    m2cAssert(etype == 216, "prismatic elements supports up to sextic.");
//  Choose a mode for parfor
// ompForSerial - Transform a parfor loop to run in serial
//
//       ompForSerial
//
//  Note
//  ----
//
//  This directive must appear immediately before the parfor loop to be
//  affected.
//
//  Example
//  -------
//     ompForSerial;
//     parfor i=1:N
//        x(i) = y(i) + z(i);
//     end
//
//  See also ompSimd, ompSimdWithFor, ompForWithPar, ompForInPar
#pragma m2c ompForSerial();
    //  Serial mode
    ub_loop = cs.size(0) - 1;
#pragma omp parallel for num_threads(omp_get_max_threads()) private(           \
    dv9, dv10, loop_ub, i4, b_unnamed_idx_1, b_unnamed_idx_2, i5, i6,          \
    b_tmp_size_idx_2, b_tmp_size_idx_1, i7, b_tmp_data)

    for (int32_T b_q = 0; b_q <= ub_loop; b_q++) {
      prism_196(cs[cs.size(1) * b_q], cs[cs.size(1) * b_q + 1],
                cs[cs.size(1) * b_q + 2], dv10, dv9);
      loop_ub = sfvals.size(1);
      for (i4 = 0; i4 < loop_ub; i4++) {
        sfvals[i4 + sfvals.size(1) * b_q] = dv10[i4];
      }
      b_unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      b_unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i4 = 0;
      i5 = 0;
      loop_ub = 0;
      i6 = 0;
      b_tmp_size_idx_2 = sdvals.size(2);
      b_tmp_size_idx_1 = sdvals.size(1);
      for (i7 = 0; i7 < b_unnamed_idx_1 * b_unnamed_idx_2; i7++) {
        b_tmp_data[i5 + b_tmp_size_idx_2 * i4] = dv9[i6 + 3 * loop_ub];
        loop_ub++;
        i4++;
        if (i4 > b_tmp_size_idx_1 - 1) {
          i4 = 0;
          i5++;
        }
        if (loop_ub > 195) {
          loop_ub = 0;
          i6++;
        }
      }
      for (i4 = 0; i4 < b_tmp_size_idx_1; i4++) {
        for (i5 = 0; i5 < b_tmp_size_idx_2; i5++) {
          sdvals[(i5 + sdvals.size(2) * i4) +
                 sdvals.size(2) * sdvals.size(1) * b_q] =
              b_tmp_data[i5 + b_tmp_size_idx_2 * i4];
        }
      }
    }
  } break;
  }
}

static void sfe3_tabulate_equi_pyra(int32_T etype,
                                    const ::coder::array<real_T, 2U> &cs,
                                    ::coder::array<real_T, 2U> &sfvals,
                                    ::coder::array<real_T, 3U> &sdvals)
{
  real_T b_tmp_data[1029];
  real_T tmp_data[1029];
  real_T dv6[165];
  real_T dv4[90];
  real_T dv7[55];
  real_T dv5[30];
  int32_T b_tmp_size_idx_1;
  int32_T b_tmp_size_idx_2;
  int32_T i;
  int32_T i2;
  int32_T i5;
  int32_T i6;
  int32_T i7;
  int32_T loop_ub;
  int32_T nqp;
  int16_T b_unnamed_idx_1;
  int16_T b_unnamed_idx_2;
  //  pyra
  nqp = cs.size(0) - 1;
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  i = iv[etype - 1];
  sfvals.set_size(cs.size(0), i);
  sdvals.set_size(cs.size(0), i, cs.size(1));
  switch (etype) {
  case 164: {
    for (int32_T q{0}; q <= nqp; q++) {
      real_T dv2[15];
      real_T dv[5];
      int32_T i1;
      int32_T i3;
      int32_T tmp_size_idx_1;
      int32_T tmp_size_idx_2;
      int32_T ub_loop;
      int16_T unnamed_idx_1;
      int16_T unnamed_idx_2;
      // pyra_5 - Compute shape functions and their derivatives of pyra_5
      //
      //     ncoords = pyra_5
      //     [sfvals,sdvals] = pyra_5(xi,eta,zeta)
      //
      // Parameters
      // ----------
      //     xi,eta: natural coordinates ranging between -1 and 1
      //     zeta: natural coordinate ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 5-by-1
      //     sdvals: vector of size 5-by-3
      // Note
      // ----
      //  The shape functions are based on Bedrosian rational basis functions.
      ::sfe_sfuncs::pyra_5_sfunc(cs[cs.size(1) * q], cs[cs.size(1) * q + 1],
                                 cs[cs.size(1) * q + 2], &dv[0], &dv2[0]);
      ub_loop = sfvals.size(1);
      for (i = 0; i < ub_loop; i++) {
        sfvals[i + sfvals.size(1) * q] = dv[i];
      }
      unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i = 0;
      i1 = 0;
      ub_loop = 0;
      i3 = 0;
      tmp_size_idx_2 = sdvals.size(2);
      tmp_size_idx_1 = sdvals.size(1);
      for (int32_T i4{0}; i4 < unnamed_idx_1 * unnamed_idx_2; i4++) {
        tmp_data[i1 + tmp_size_idx_2 * i] = dv2[i3 + 3 * ub_loop];
        ub_loop++;
        i++;
        if (i > tmp_size_idx_1 - 1) {
          i = 0;
          i1++;
        }
        if (ub_loop > 4) {
          ub_loop = 0;
          i3++;
        }
      }
      for (i = 0; i < tmp_size_idx_1; i++) {
        for (i1 = 0; i1 < tmp_size_idx_2; i1++) {
          sdvals[(i1 + sdvals.size(2) * i) +
                 sdvals.size(2) * sdvals.size(1) * q] =
              tmp_data[i1 + tmp_size_idx_2 * i];
        }
      }
    }
  } break;
  case 168: {
    for (int32_T q{0}; q <= nqp; q++) {
      real_T dv3[42];
      real_T dv1[14];
      int32_T i1;
      int32_T i3;
      int32_T tmp_size_idx_1;
      int32_T tmp_size_idx_2;
      int32_T ub_loop;
      int16_T unnamed_idx_1;
      int16_T unnamed_idx_2;
      // pyra_14 - Compute shape functions and their derivatives of pyra_14
      //
      //     ncoords = pyra_14
      //     [sfvals,sdvals] = pyra_14(xi,eta,zeta)
      //
      // Parameters
      // ----------
      //     xi,eta: natural coordinates ranging between -1 and 1
      //     zeta: natural coordinate ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 14-by-1
      //     sdvals: vector of size 14-by-3
      // Note
      // ----
      //  The shape functions are based on Bedrosian rational basis functions.
      ::sfe_sfuncs::pyra_14_sfunc(cs[cs.size(1) * q], cs[cs.size(1) * q + 1],
                                  cs[cs.size(1) * q + 2], &dv1[0], &dv3[0]);
      ub_loop = sfvals.size(1);
      for (i = 0; i < ub_loop; i++) {
        sfvals[i + sfvals.size(1) * q] = dv1[i];
      }
      unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i = 0;
      i1 = 0;
      ub_loop = 0;
      i3 = 0;
      tmp_size_idx_2 = sdvals.size(2);
      tmp_size_idx_1 = sdvals.size(1);
      for (int32_T i4{0}; i4 < unnamed_idx_1 * unnamed_idx_2; i4++) {
        tmp_data[i1 + tmp_size_idx_2 * i] = dv3[i3 + 3 * ub_loop];
        ub_loop++;
        i++;
        if (i > tmp_size_idx_1 - 1) {
          i = 0;
          i1++;
        }
        if (ub_loop > 13) {
          ub_loop = 0;
          i3++;
        }
      }
      for (i = 0; i < tmp_size_idx_1; i++) {
        for (i1 = 0; i1 < tmp_size_idx_2; i1++) {
          sdvals[(i1 + sdvals.size(2) * i) +
                 sdvals.size(2) * sdvals.size(1) * q] =
              tmp_data[i1 + tmp_size_idx_2 * i];
        }
      }
    }
  } break;
  case 172: {
    int32_T ub_loop;
//  Choose a mode for parfor
// ompForSerial - Transform a parfor loop to run in serial
//
//       ompForSerial
//
//  Note
//  ----
//
//  This directive must appear immediately before the parfor loop to be
//  affected.
//
//  Example
//  -------
//     ompForSerial;
//     parfor i=1:N
//        x(i) = y(i) + z(i);
//     end
//
//  See also ompSimd, ompSimdWithFor, ompForWithPar, ompForInPar
#pragma m2c ompForSerial();
    //  Serial mode
    ub_loop = cs.size(0) - 1;
#pragma omp parallel for num_threads(omp_get_max_threads()) private(           \
    dv4, dv5, loop_ub, i2, b_unnamed_idx_1, b_unnamed_idx_2, i5, i6,           \
    b_tmp_size_idx_2, b_tmp_size_idx_1, i7, b_tmp_data)

    for (int32_T b_q = 0; b_q <= ub_loop; b_q++) {
      pyra_30(cs[cs.size(1) * b_q], cs[cs.size(1) * b_q + 1],
              cs[cs.size(1) * b_q + 2], dv5, dv4);
      loop_ub = sfvals.size(1);
      for (i2 = 0; i2 < loop_ub; i2++) {
        sfvals[i2 + sfvals.size(1) * b_q] = dv5[i2];
      }
      b_unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      b_unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i2 = 0;
      i5 = 0;
      loop_ub = 0;
      i6 = 0;
      b_tmp_size_idx_2 = sdvals.size(2);
      b_tmp_size_idx_1 = sdvals.size(1);
      for (i7 = 0; i7 < b_unnamed_idx_1 * b_unnamed_idx_2; i7++) {
        b_tmp_data[i5 + b_tmp_size_idx_2 * i2] = dv4[i6 + 3 * loop_ub];
        loop_ub++;
        i2++;
        if (i2 > b_tmp_size_idx_1 - 1) {
          i2 = 0;
          i5++;
        }
        if (loop_ub > 29) {
          loop_ub = 0;
          i6++;
        }
      }
      for (i2 = 0; i2 < b_tmp_size_idx_1; i2++) {
        for (i5 = 0; i5 < b_tmp_size_idx_2; i5++) {
          sdvals[(i5 + sdvals.size(2) * i2) +
                 sdvals.size(2) * sdvals.size(1) * b_q] =
              b_tmp_data[i5 + b_tmp_size_idx_2 * i2];
        }
      }
    }
  } break;
  default: {
    int32_T ub_loop;
    //  m2cAssert  Throw error if condition false at runtime
    //
    //    m2cAssert(cond)
    //    m2cAssert(cond,msg)
    //    m2cAssert(cond,msg,A1,...,An)
    //    m2cAssert(cond,errID,msg)
    //    m2cAssert(cond,errID,msg,A1,...,An)
    //
    //  The interface of `m2cAssert` is compatible with MATLAB's built-in
    //  `assert`,  but it generates runtime assertion instead of compile-time
    //  assertion.
    //
    //  Note
    //  ----
    //  The MATLAB built-in `assert` is mostly used for compile-time error
    //  checking, and it has no effect for runtime error checking in LIB mode.
    //  Use `m2cAssert` instead for runtime error checking. Like the built-in
    //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
    //  into a code-generation-time character string. If you want to use both
    //  code-generation-time and runtime assertions, it is recommended to put
    //  `m2cAssert` before the built-in `assert`.
    //
    //  See also assert, m2cError, m2cWarning
    m2cAssert(etype == 176, "Pyramid only support up to quartic");
//  Choose a mode for parfor
// ompForSerial - Transform a parfor loop to run in serial
//
//       ompForSerial
//
//  Note
//  ----
//
//  This directive must appear immediately before the parfor loop to be
//  affected.
//
//  Example
//  -------
//     ompForSerial;
//     parfor i=1:N
//        x(i) = y(i) + z(i);
//     end
//
//  See also ompSimd, ompSimdWithFor, ompForWithPar, ompForInPar
#pragma m2c ompForSerial();
    //  Serial mode
    ub_loop = cs.size(0) - 1;
#pragma omp parallel for num_threads(omp_get_max_threads()) private(           \
    dv6, dv7, loop_ub, i2, b_unnamed_idx_1, b_unnamed_idx_2, i5, i6,           \
    b_tmp_size_idx_2, b_tmp_size_idx_1, i7, b_tmp_data)

    for (int32_T b_q = 0; b_q <= ub_loop; b_q++) {
      pyra_55(cs[cs.size(1) * b_q], cs[cs.size(1) * b_q + 1],
              cs[cs.size(1) * b_q + 2], dv7, dv6);
      loop_ub = sfvals.size(1);
      for (i2 = 0; i2 < loop_ub; i2++) {
        sfvals[i2 + sfvals.size(1) * b_q] = dv7[i2];
      }
      b_unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      b_unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i2 = 0;
      i5 = 0;
      loop_ub = 0;
      i6 = 0;
      b_tmp_size_idx_2 = sdvals.size(2);
      b_tmp_size_idx_1 = sdvals.size(1);
      for (i7 = 0; i7 < b_unnamed_idx_1 * b_unnamed_idx_2; i7++) {
        b_tmp_data[i5 + b_tmp_size_idx_2 * i2] = dv6[i6 + 3 * loop_ub];
        loop_ub++;
        i2++;
        if (i2 > b_tmp_size_idx_1 - 1) {
          i2 = 0;
          i5++;
        }
        if (loop_ub > 54) {
          loop_ub = 0;
          i6++;
        }
      }
      for (i2 = 0; i2 < b_tmp_size_idx_1; i2++) {
        for (i5 = 0; i5 < b_tmp_size_idx_2; i5++) {
          sdvals[(i5 + sdvals.size(2) * i2) +
                 sdvals.size(2) * sdvals.size(1) * b_q] =
              b_tmp_data[i5 + b_tmp_size_idx_2 * i2];
        }
      }
    }
  } break;
  }
}

static void sfe3_tabulate_equi_tet(int32_T etype,
                                   const ::coder::array<real_T, 2U> &cs,
                                   ::coder::array<real_T, 2U> &sfvals,
                                   ::coder::array<real_T, 3U> &sdvals)
{
  real_T b_tmp_data[1029];
  real_T tmp_data[1029];
  real_T dv10[252];
  real_T dv6[168];
  real_T dv5[105];
  real_T dv11[84];
  real_T dv4[60];
  real_T dv9[56];
  real_T dv8[35];
  real_T dv7[20];
  int32_T b_tmp_size_idx_1;
  int32_T b_tmp_size_idx_2;
  int32_T i;
  int32_T i3;
  int32_T i5;
  int32_T i6;
  int32_T i7;
  int32_T loop_ub;
  int32_T nqp;
  int16_T b_unnamed_idx_1;
  int16_T b_unnamed_idx_2;
  //  tet
  nqp = cs.size(0) - 1;
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  i = iv[etype - 1];
  sfvals.set_size(cs.size(0), i);
  sdvals.set_size(cs.size(0), i, cs.size(1));
  switch (etype) {
  case 132: {
    for (int32_T q{0}; q <= nqp; q++) {
      real_T dv2[12];
      real_T dv[4];
      int32_T i1;
      int32_T i2;
      int32_T tmp_size_idx_1;
      int32_T tmp_size_idx_2;
      int32_T ub_loop;
      int16_T unnamed_idx_1;
      int16_T unnamed_idx_2;
      // tet_4 - Compute shape functions and their derivatives of tet_4
      //
      //     ncoords = tet_4
      //     [sfvals,sdvals] = tet_4(xi,eta,zeta)
      //
      // Parameters
      // ----------
      //     xi,eta,zeta: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 4-by-1
      //     sdvals: vector of size 4-by-3
      ::sfe_sfuncs::tet_4_sfunc(cs[cs.size(1) * q], cs[cs.size(1) * q + 1],
                                cs[cs.size(1) * q + 2], &dv[0], &dv2[0]);
      ub_loop = sfvals.size(1);
      for (i = 0; i < ub_loop; i++) {
        sfvals[i + sfvals.size(1) * q] = dv[i];
      }
      unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i = 0;
      i1 = 0;
      ub_loop = 0;
      i2 = 0;
      tmp_size_idx_2 = sdvals.size(2);
      tmp_size_idx_1 = sdvals.size(1);
      for (int32_T i4{0}; i4 < unnamed_idx_1 * unnamed_idx_2; i4++) {
        tmp_data[i1 + tmp_size_idx_2 * i] = dv2[i2 + 3 * ub_loop];
        ub_loop++;
        i++;
        if (i > tmp_size_idx_1 - 1) {
          i = 0;
          i1++;
        }
        if (ub_loop > 3) {
          ub_loop = 0;
          i2++;
        }
      }
      for (i = 0; i < tmp_size_idx_1; i++) {
        for (i1 = 0; i1 < tmp_size_idx_2; i1++) {
          sdvals[(i1 + sdvals.size(2) * i) +
                 sdvals.size(2) * sdvals.size(1) * q] =
              tmp_data[i1 + tmp_size_idx_2 * i];
        }
      }
    }
  } break;
  case 136: {
    for (int32_T q{0}; q <= nqp; q++) {
      real_T dv3[30];
      real_T dv1[10];
      int32_T i1;
      int32_T i2;
      int32_T tmp_size_idx_1;
      int32_T tmp_size_idx_2;
      int32_T ub_loop;
      int16_T unnamed_idx_1;
      int16_T unnamed_idx_2;
      // tet_10 - Compute shape functions and their derivatives of tet_10
      //
      //     ncoords = tet_10
      //     [sfvals,sdvals] = tet_10(xi,eta,zeta)
      //
      // Parameters
      // ----------
      //     xi,eta,zeta: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 10-by-1
      //     sdvals: vector of size 10-by-3
      ::sfe_sfuncs::tet_10_sfunc(cs[cs.size(1) * q], cs[cs.size(1) * q + 1],
                                 cs[cs.size(1) * q + 2], &dv1[0], &dv3[0]);
      ub_loop = sfvals.size(1);
      for (i = 0; i < ub_loop; i++) {
        sfvals[i + sfvals.size(1) * q] = dv1[i];
      }
      unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i = 0;
      i1 = 0;
      ub_loop = 0;
      i2 = 0;
      tmp_size_idx_2 = sdvals.size(2);
      tmp_size_idx_1 = sdvals.size(1);
      for (int32_T i4{0}; i4 < unnamed_idx_1 * unnamed_idx_2; i4++) {
        tmp_data[i1 + tmp_size_idx_2 * i] = dv3[i2 + 3 * ub_loop];
        ub_loop++;
        i++;
        if (i > tmp_size_idx_1 - 1) {
          i = 0;
          i1++;
        }
        if (ub_loop > 9) {
          ub_loop = 0;
          i2++;
        }
      }
      for (i = 0; i < tmp_size_idx_1; i++) {
        for (i1 = 0; i1 < tmp_size_idx_2; i1++) {
          sdvals[(i1 + sdvals.size(2) * i) +
                 sdvals.size(2) * sdvals.size(1) * q] =
              tmp_data[i1 + tmp_size_idx_2 * i];
        }
      }
    }
  } break;
  case 140: {
    int32_T ub_loop;
//  Choose a mode for parfor
// ompForSerial - Transform a parfor loop to run in serial
//
//       ompForSerial
//
//  Note
//  ----
//
//  This directive must appear immediately before the parfor loop to be
//  affected.
//
//  Example
//  -------
//     ompForSerial;
//     parfor i=1:N
//        x(i) = y(i) + z(i);
//     end
//
//  See also ompSimd, ompSimdWithFor, ompForWithPar, ompForInPar
#pragma m2c ompForSerial();
    //  Serial mode
    ub_loop = cs.size(0) - 1;
#pragma omp parallel for num_threads(omp_get_max_threads()) private(           \
    dv4, dv7, loop_ub, i3, b_unnamed_idx_1, b_unnamed_idx_2, i5, i6,           \
    b_tmp_size_idx_2, b_tmp_size_idx_1, i7, b_tmp_data)

    for (int32_T b_q = 0; b_q <= ub_loop; b_q++) {
      tet_20(cs[cs.size(1) * b_q], cs[cs.size(1) * b_q + 1],
             cs[cs.size(1) * b_q + 2], dv7, dv4);
      loop_ub = sfvals.size(1);
      for (i3 = 0; i3 < loop_ub; i3++) {
        sfvals[i3 + sfvals.size(1) * b_q] = dv7[i3];
      }
      b_unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      b_unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i3 = 0;
      i5 = 0;
      loop_ub = 0;
      i6 = 0;
      b_tmp_size_idx_2 = sdvals.size(2);
      b_tmp_size_idx_1 = sdvals.size(1);
      for (i7 = 0; i7 < b_unnamed_idx_1 * b_unnamed_idx_2; i7++) {
        b_tmp_data[i5 + b_tmp_size_idx_2 * i3] = dv4[i6 + 3 * loop_ub];
        loop_ub++;
        i3++;
        if (i3 > b_tmp_size_idx_1 - 1) {
          i3 = 0;
          i5++;
        }
        if (loop_ub > 19) {
          loop_ub = 0;
          i6++;
        }
      }
      for (i3 = 0; i3 < b_tmp_size_idx_1; i3++) {
        for (i5 = 0; i5 < b_tmp_size_idx_2; i5++) {
          sdvals[(i5 + sdvals.size(2) * i3) +
                 sdvals.size(2) * sdvals.size(1) * b_q] =
              b_tmp_data[i5 + b_tmp_size_idx_2 * i3];
        }
      }
    }
  } break;
  case 144: {
    int32_T ub_loop;
//  Choose a mode for parfor
// ompForSerial - Transform a parfor loop to run in serial
//
//       ompForSerial
//
//  Note
//  ----
//
//  This directive must appear immediately before the parfor loop to be
//  affected.
//
//  Example
//  -------
//     ompForSerial;
//     parfor i=1:N
//        x(i) = y(i) + z(i);
//     end
//
//  See also ompSimd, ompSimdWithFor, ompForWithPar, ompForInPar
#pragma m2c ompForSerial();
    //  Serial mode
    ub_loop = cs.size(0) - 1;
#pragma omp parallel for num_threads(omp_get_max_threads()) private(           \
    dv5, dv8, loop_ub, i3, b_unnamed_idx_1, b_unnamed_idx_2, i5, i6,           \
    b_tmp_size_idx_2, b_tmp_size_idx_1, i7, b_tmp_data)

    for (int32_T b_q = 0; b_q <= ub_loop; b_q++) {
      tet_35(cs[cs.size(1) * b_q], cs[cs.size(1) * b_q + 1],
             cs[cs.size(1) * b_q + 2], dv8, dv5);
      loop_ub = sfvals.size(1);
      for (i3 = 0; i3 < loop_ub; i3++) {
        sfvals[i3 + sfvals.size(1) * b_q] = dv8[i3];
      }
      b_unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      b_unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i3 = 0;
      i5 = 0;
      loop_ub = 0;
      i6 = 0;
      b_tmp_size_idx_2 = sdvals.size(2);
      b_tmp_size_idx_1 = sdvals.size(1);
      for (i7 = 0; i7 < b_unnamed_idx_1 * b_unnamed_idx_2; i7++) {
        b_tmp_data[i5 + b_tmp_size_idx_2 * i3] = dv5[i6 + 3 * loop_ub];
        loop_ub++;
        i3++;
        if (i3 > b_tmp_size_idx_1 - 1) {
          i3 = 0;
          i5++;
        }
        if (loop_ub > 34) {
          loop_ub = 0;
          i6++;
        }
      }
      for (i3 = 0; i3 < b_tmp_size_idx_1; i3++) {
        for (i5 = 0; i5 < b_tmp_size_idx_2; i5++) {
          sdvals[(i5 + sdvals.size(2) * i3) +
                 sdvals.size(2) * sdvals.size(1) * b_q] =
              b_tmp_data[i5 + b_tmp_size_idx_2 * i3];
        }
      }
    }
  } break;
  case 148: {
    int32_T ub_loop;
//  Choose a mode for parfor
// ompForSerial - Transform a parfor loop to run in serial
//
//       ompForSerial
//
//  Note
//  ----
//
//  This directive must appear immediately before the parfor loop to be
//  affected.
//
//  Example
//  -------
//     ompForSerial;
//     parfor i=1:N
//        x(i) = y(i) + z(i);
//     end
//
//  See also ompSimd, ompSimdWithFor, ompForWithPar, ompForInPar
#pragma m2c ompForSerial();
    //  Serial mode
    ub_loop = cs.size(0) - 1;
#pragma omp parallel for num_threads(omp_get_max_threads()) private(           \
    dv6, dv9, loop_ub, i3, b_unnamed_idx_1, b_unnamed_idx_2, i5, i6,           \
    b_tmp_size_idx_2, b_tmp_size_idx_1, i7, b_tmp_data)

    for (int32_T b_q = 0; b_q <= ub_loop; b_q++) {
      tet_56(cs[cs.size(1) * b_q], cs[cs.size(1) * b_q + 1],
             cs[cs.size(1) * b_q + 2], dv9, dv6);
      loop_ub = sfvals.size(1);
      for (i3 = 0; i3 < loop_ub; i3++) {
        sfvals[i3 + sfvals.size(1) * b_q] = dv9[i3];
      }
      b_unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      b_unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i3 = 0;
      i5 = 0;
      loop_ub = 0;
      i6 = 0;
      b_tmp_size_idx_2 = sdvals.size(2);
      b_tmp_size_idx_1 = sdvals.size(1);
      for (i7 = 0; i7 < b_unnamed_idx_1 * b_unnamed_idx_2; i7++) {
        b_tmp_data[i5 + b_tmp_size_idx_2 * i3] = dv6[i6 + 3 * loop_ub];
        loop_ub++;
        i3++;
        if (i3 > b_tmp_size_idx_1 - 1) {
          i3 = 0;
          i5++;
        }
        if (loop_ub > 55) {
          loop_ub = 0;
          i6++;
        }
      }
      for (i3 = 0; i3 < b_tmp_size_idx_1; i3++) {
        for (i5 = 0; i5 < b_tmp_size_idx_2; i5++) {
          sdvals[(i5 + sdvals.size(2) * i3) +
                 sdvals.size(2) * sdvals.size(1) * b_q] =
              b_tmp_data[i5 + b_tmp_size_idx_2 * i3];
        }
      }
    }
  } break;
  default: {
    int32_T ub_loop;
    //  m2cAssert  Throw error if condition false at runtime
    //
    //    m2cAssert(cond)
    //    m2cAssert(cond,msg)
    //    m2cAssert(cond,msg,A1,...,An)
    //    m2cAssert(cond,errID,msg)
    //    m2cAssert(cond,errID,msg,A1,...,An)
    //
    //  The interface of `m2cAssert` is compatible with MATLAB's built-in
    //  `assert`,  but it generates runtime assertion instead of compile-time
    //  assertion.
    //
    //  Note
    //  ----
    //  The MATLAB built-in `assert` is mostly used for compile-time error
    //  checking, and it has no effect for runtime error checking in LIB mode.
    //  Use `m2cAssert` instead for runtime error checking. Like the built-in
    //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
    //  into a code-generation-time character string. If you want to use both
    //  code-generation-time and runtime assertions, it is recommended to put
    //  `m2cAssert` before the built-in `assert`.
    //
    //  See also assert, m2cError, m2cWarning
    m2cAssert(etype == 152, "equidistant tets only supported up to sextic");
//  Choose a mode for parfor
// ompForSerial - Transform a parfor loop to run in serial
//
//       ompForSerial
//
//  Note
//  ----
//
//  This directive must appear immediately before the parfor loop to be
//  affected.
//
//  Example
//  -------
//     ompForSerial;
//     parfor i=1:N
//        x(i) = y(i) + z(i);
//     end
//
//  See also ompSimd, ompSimdWithFor, ompForWithPar, ompForInPar
#pragma m2c ompForSerial();
    //  Serial mode
    ub_loop = cs.size(0) - 1;
#pragma omp parallel for num_threads(omp_get_max_threads()) private(           \
    dv10, dv11, loop_ub, i3, b_unnamed_idx_1, b_unnamed_idx_2, i5, i6,         \
    b_tmp_size_idx_2, b_tmp_size_idx_1, i7, b_tmp_data)

    for (int32_T b_q = 0; b_q <= ub_loop; b_q++) {
      tet_84(cs[cs.size(1) * b_q], cs[cs.size(1) * b_q + 1],
             cs[cs.size(1) * b_q + 2], dv11, dv10);
      loop_ub = sfvals.size(1);
      for (i3 = 0; i3 < loop_ub; i3++) {
        sfvals[i3 + sfvals.size(1) * b_q] = dv11[i3];
      }
      b_unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      b_unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i3 = 0;
      i5 = 0;
      loop_ub = 0;
      i6 = 0;
      b_tmp_size_idx_2 = sdvals.size(2);
      b_tmp_size_idx_1 = sdvals.size(1);
      for (i7 = 0; i7 < b_unnamed_idx_1 * b_unnamed_idx_2; i7++) {
        b_tmp_data[i5 + b_tmp_size_idx_2 * i3] = dv10[i6 + 3 * loop_ub];
        loop_ub++;
        i3++;
        if (i3 > b_tmp_size_idx_1 - 1) {
          i3 = 0;
          i5++;
        }
        if (loop_ub > 83) {
          loop_ub = 0;
          i6++;
        }
      }
      for (i3 = 0; i3 < b_tmp_size_idx_1; i3++) {
        for (i5 = 0; i5 < b_tmp_size_idx_2; i5++) {
          sdvals[(i5 + sdvals.size(2) * i3) +
                 sdvals.size(2) * sdvals.size(1) * b_q] =
              b_tmp_data[i5 + b_tmp_size_idx_2 * i3];
        }
      }
    }
  } break;
  }
}

static void sfe3_tabulate_gl_hexa(int32_T etype,
                                  const ::coder::array<real_T, 2U> &cs,
                                  ::coder::array<real_T, 2U> &sfvals,
                                  ::coder::array<real_T, 3U> &sdvals)
{
  real_T dv6[1029];
  real_T tmp_data[1029];
  real_T dv2[648];
  real_T dv1[375];
  real_T dv7[343];
  real_T dv5[216];
  real_T dv[192];
  real_T dv4[125];
  real_T dv3[64];
  int32_T i;
  int32_T i1;
  int32_T i2;
  int32_T i3;
  int32_T loop_ub;
  int32_T tmp_size_idx_1;
  int32_T tmp_size_idx_2;
  int32_T ub_loop;
  int16_T unnamed_idx_1;
  int16_T unnamed_idx_2;
  //  hex
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  ub_loop = iv[etype - 1];
  sfvals.set_size(cs.size(0), ub_loop);
  sdvals.set_size(cs.size(0), ub_loop, cs.size(1));
  switch (etype) {
  case 237:
//  Choose a mode for parfor
// ompForSerial - Transform a parfor loop to run in serial
//
//       ompForSerial
//
//  Note
//  ----
//
//  This directive must appear immediately before the parfor loop to be
//  affected.
//
//  Example
//  -------
//     ompForSerial;
//     parfor i=1:N
//        x(i) = y(i) + z(i);
//     end
//
//  See also ompSimd, ompSimdWithFor, ompForWithPar, ompForInPar
#pragma m2c ompForSerial();
    //  Serial mode
    ub_loop = cs.size(0) - 1;
#pragma omp parallel for num_threads(omp_get_max_threads()) private(           \
    dv, dv3, loop_ub, i, unnamed_idx_1, unnamed_idx_2, i1, i2, tmp_size_idx_2, \
    tmp_size_idx_1, i3, tmp_data)

    for (int32_T q = 0; q <= ub_loop; q++) {
      hexa_gl_64(cs[cs.size(1) * q], cs[cs.size(1) * q + 1],
                 cs[cs.size(1) * q + 2], dv3, dv);
      loop_ub = sfvals.size(1);
      for (i = 0; i < loop_ub; i++) {
        sfvals[i + sfvals.size(1) * q] = dv3[i];
      }
      unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i = 0;
      i1 = 0;
      loop_ub = 0;
      i2 = 0;
      tmp_size_idx_2 = sdvals.size(2);
      tmp_size_idx_1 = sdvals.size(1);
      for (i3 = 0; i3 < unnamed_idx_1 * unnamed_idx_2; i3++) {
        tmp_data[i1 + tmp_size_idx_2 * i] = dv[i2 + 3 * loop_ub];
        loop_ub++;
        i++;
        if (i > tmp_size_idx_1 - 1) {
          i = 0;
          i1++;
        }
        if (loop_ub > 63) {
          loop_ub = 0;
          i2++;
        }
      }
      for (i = 0; i < tmp_size_idx_1; i++) {
        for (i1 = 0; i1 < tmp_size_idx_2; i1++) {
          sdvals[(i1 + sdvals.size(2) * i) +
                 sdvals.size(2) * sdvals.size(1) * q] =
              tmp_data[i1 + tmp_size_idx_2 * i];
        }
      }
    }
    break;
  case 241:
//  Choose a mode for parfor
// ompForSerial - Transform a parfor loop to run in serial
//
//       ompForSerial
//
//  Note
//  ----
//
//  This directive must appear immediately before the parfor loop to be
//  affected.
//
//  Example
//  -------
//     ompForSerial;
//     parfor i=1:N
//        x(i) = y(i) + z(i);
//     end
//
//  See also ompSimd, ompSimdWithFor, ompForWithPar, ompForInPar
#pragma m2c ompForSerial();
    //  Serial mode
    ub_loop = cs.size(0) - 1;
#pragma omp parallel for num_threads(omp_get_max_threads()) private(           \
    dv1, dv4, loop_ub, i, unnamed_idx_1, unnamed_idx_2, i1, i2,                \
    tmp_size_idx_2, tmp_size_idx_1, i3, tmp_data)

    for (int32_T q = 0; q <= ub_loop; q++) {
      hexa_gl_125(cs[cs.size(1) * q], cs[cs.size(1) * q + 1],
                  cs[cs.size(1) * q + 2], dv4, dv1);
      loop_ub = sfvals.size(1);
      for (i = 0; i < loop_ub; i++) {
        sfvals[i + sfvals.size(1) * q] = dv4[i];
      }
      unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i = 0;
      i1 = 0;
      loop_ub = 0;
      i2 = 0;
      tmp_size_idx_2 = sdvals.size(2);
      tmp_size_idx_1 = sdvals.size(1);
      for (i3 = 0; i3 < unnamed_idx_1 * unnamed_idx_2; i3++) {
        tmp_data[i1 + tmp_size_idx_2 * i] = dv1[i2 + 3 * loop_ub];
        loop_ub++;
        i++;
        if (i > tmp_size_idx_1 - 1) {
          i = 0;
          i1++;
        }
        if (loop_ub > 124) {
          loop_ub = 0;
          i2++;
        }
      }
      for (i = 0; i < tmp_size_idx_1; i++) {
        for (i1 = 0; i1 < tmp_size_idx_2; i1++) {
          sdvals[(i1 + sdvals.size(2) * i) +
                 sdvals.size(2) * sdvals.size(1) * q] =
              tmp_data[i1 + tmp_size_idx_2 * i];
        }
      }
    }
    break;
  case 245:
//  Choose a mode for parfor
// ompForSerial - Transform a parfor loop to run in serial
//
//       ompForSerial
//
//  Note
//  ----
//
//  This directive must appear immediately before the parfor loop to be
//  affected.
//
//  Example
//  -------
//     ompForSerial;
//     parfor i=1:N
//        x(i) = y(i) + z(i);
//     end
//
//  See also ompSimd, ompSimdWithFor, ompForWithPar, ompForInPar
#pragma m2c ompForSerial();
    //  Serial mode
    ub_loop = cs.size(0) - 1;
#pragma omp parallel for num_threads(omp_get_max_threads()) private(           \
    dv2, dv5, loop_ub, i, unnamed_idx_1, unnamed_idx_2, i1, i2,                \
    tmp_size_idx_2, tmp_size_idx_1, i3, tmp_data)

    for (int32_T q = 0; q <= ub_loop; q++) {
      hexa_gl_216(cs[cs.size(1) * q], cs[cs.size(1) * q + 1],
                  cs[cs.size(1) * q + 2], dv5, dv2);
      loop_ub = sfvals.size(1);
      for (i = 0; i < loop_ub; i++) {
        sfvals[i + sfvals.size(1) * q] = dv5[i];
      }
      unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i = 0;
      i1 = 0;
      loop_ub = 0;
      i2 = 0;
      tmp_size_idx_2 = sdvals.size(2);
      tmp_size_idx_1 = sdvals.size(1);
      for (i3 = 0; i3 < unnamed_idx_1 * unnamed_idx_2; i3++) {
        tmp_data[i1 + tmp_size_idx_2 * i] = dv2[i2 + 3 * loop_ub];
        loop_ub++;
        i++;
        if (i > tmp_size_idx_1 - 1) {
          i = 0;
          i1++;
        }
        if (loop_ub > 215) {
          loop_ub = 0;
          i2++;
        }
      }
      for (i = 0; i < tmp_size_idx_1; i++) {
        for (i1 = 0; i1 < tmp_size_idx_2; i1++) {
          sdvals[(i1 + sdvals.size(2) * i) +
                 sdvals.size(2) * sdvals.size(1) * q] =
              tmp_data[i1 + tmp_size_idx_2 * i];
        }
      }
    }
    break;
  default:
    //  m2cAssert  Throw error if condition false at runtime
    //
    //    m2cAssert(cond)
    //    m2cAssert(cond,msg)
    //    m2cAssert(cond,msg,A1,...,An)
    //    m2cAssert(cond,errID,msg)
    //    m2cAssert(cond,errID,msg,A1,...,An)
    //
    //  The interface of `m2cAssert` is compatible with MATLAB's built-in
    //  `assert`,  but it generates runtime assertion instead of compile-time
    //  assertion.
    //
    //  Note
    //  ----
    //  The MATLAB built-in `assert` is mostly used for compile-time error
    //  checking, and it has no effect for runtime error checking in LIB mode.
    //  Use `m2cAssert` instead for runtime error checking. Like the built-in
    //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
    //  into a code-generation-time character string. If you want to use both
    //  code-generation-time and runtime assertions, it is recommended to put
    //  `m2cAssert` before the built-in `assert`.
    //
    //  See also assert, m2cError, m2cWarning
    m2cAssert(etype == 249, "Gauss-Lobatto only supports up to sextic.");
//  Choose a mode for parfor
// ompForSerial - Transform a parfor loop to run in serial
//
//       ompForSerial
//
//  Note
//  ----
//
//  This directive must appear immediately before the parfor loop to be
//  affected.
//
//  Example
//  -------
//     ompForSerial;
//     parfor i=1:N
//        x(i) = y(i) + z(i);
//     end
//
//  See also ompSimd, ompSimdWithFor, ompForWithPar, ompForInPar
#pragma m2c ompForSerial();
    //  Serial mode
    ub_loop = cs.size(0) - 1;
#pragma omp parallel for num_threads(omp_get_max_threads()) private(           \
    dv6, dv7, loop_ub, i, unnamed_idx_1, unnamed_idx_2, i1, i2,                \
    tmp_size_idx_2, tmp_size_idx_1, i3, tmp_data)

    for (int32_T q = 0; q <= ub_loop; q++) {
      hexa_gl_343(cs[cs.size(1) * q], cs[cs.size(1) * q + 1],
                  cs[cs.size(1) * q + 2], dv7, dv6);
      loop_ub = sfvals.size(1);
      for (i = 0; i < loop_ub; i++) {
        sfvals[i + sfvals.size(1) * q] = dv7[i];
      }
      unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i = 0;
      i1 = 0;
      loop_ub = 0;
      i2 = 0;
      tmp_size_idx_2 = sdvals.size(2);
      tmp_size_idx_1 = sdvals.size(1);
      for (i3 = 0; i3 < unnamed_idx_1 * unnamed_idx_2; i3++) {
        tmp_data[i1 + tmp_size_idx_2 * i] = dv6[i2 + 3 * loop_ub];
        loop_ub++;
        i++;
        if (i > tmp_size_idx_1 - 1) {
          i = 0;
          i1++;
        }
        if (loop_ub > 342) {
          loop_ub = 0;
          i2++;
        }
      }
      for (i = 0; i < tmp_size_idx_1; i++) {
        for (i1 = 0; i1 < tmp_size_idx_2; i1++) {
          sdvals[(i1 + sdvals.size(2) * i) +
                 sdvals.size(2) * sdvals.size(1) * q] =
              tmp_data[i1 + tmp_size_idx_2 * i];
        }
      }
    }
    break;
  }
}

static void sfe3_tabulate_gl_prism(int32_T etype,
                                   const ::coder::array<real_T, 2U> &cs,
                                   ::coder::array<real_T, 2U> &sfvals,
                                   ::coder::array<real_T, 3U> &sdvals)
{
  real_T tmp_data[1029];
  real_T dv4[378];
  real_T dv1[225];
  real_T dv5[126];
  real_T dv[120];
  real_T dv3[75];
  real_T dv2[40];
  int32_T i;
  int32_T i1;
  int32_T i2;
  int32_T i3;
  int32_T loop_ub;
  int32_T tmp_size_idx_1;
  int32_T tmp_size_idx_2;
  int32_T ub_loop;
  int16_T unnamed_idx_1;
  int16_T unnamed_idx_2;
  //  prisms
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  ub_loop = iv[etype - 1];
  sfvals.set_size(cs.size(0), ub_loop);
  sdvals.set_size(cs.size(0), ub_loop, cs.size(1));
  switch (etype) {
  case 205:
//  Choose a mode for parfor
// ompForSerial - Transform a parfor loop to run in serial
//
//       ompForSerial
//
//  Note
//  ----
//
//  This directive must appear immediately before the parfor loop to be
//  affected.
//
//  Example
//  -------
//     ompForSerial;
//     parfor i=1:N
//        x(i) = y(i) + z(i);
//     end
//
//  See also ompSimd, ompSimdWithFor, ompForWithPar, ompForInPar
#pragma m2c ompForSerial();
    //  Serial mode
    ub_loop = cs.size(0) - 1;
#pragma omp parallel for num_threads(omp_get_max_threads()) private(           \
    dv, dv2, loop_ub, i, unnamed_idx_1, unnamed_idx_2, i1, i2, tmp_size_idx_2, \
    tmp_size_idx_1, i3, tmp_data)

    for (int32_T q = 0; q <= ub_loop; q++) {
      prism_gl_40(cs[cs.size(1) * q], cs[cs.size(1) * q + 1],
                  cs[cs.size(1) * q + 2], dv2, dv);
      loop_ub = sfvals.size(1);
      for (i = 0; i < loop_ub; i++) {
        sfvals[i + sfvals.size(1) * q] = dv2[i];
      }
      unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i = 0;
      i1 = 0;
      loop_ub = 0;
      i2 = 0;
      tmp_size_idx_2 = sdvals.size(2);
      tmp_size_idx_1 = sdvals.size(1);
      for (i3 = 0; i3 < unnamed_idx_1 * unnamed_idx_2; i3++) {
        tmp_data[i1 + tmp_size_idx_2 * i] = dv[i2 + 3 * loop_ub];
        loop_ub++;
        i++;
        if (i > tmp_size_idx_1 - 1) {
          i = 0;
          i1++;
        }
        if (loop_ub > 39) {
          loop_ub = 0;
          i2++;
        }
      }
      for (i = 0; i < tmp_size_idx_1; i++) {
        for (i1 = 0; i1 < tmp_size_idx_2; i1++) {
          sdvals[(i1 + sdvals.size(2) * i) +
                 sdvals.size(2) * sdvals.size(1) * q] =
              tmp_data[i1 + tmp_size_idx_2 * i];
        }
      }
    }
    break;
  case 209:
//  Choose a mode for parfor
// ompForSerial - Transform a parfor loop to run in serial
//
//       ompForSerial
//
//  Note
//  ----
//
//  This directive must appear immediately before the parfor loop to be
//  affected.
//
//  Example
//  -------
//     ompForSerial;
//     parfor i=1:N
//        x(i) = y(i) + z(i);
//     end
//
//  See also ompSimd, ompSimdWithFor, ompForWithPar, ompForInPar
#pragma m2c ompForSerial();
    //  Serial mode
    ub_loop = cs.size(0) - 1;
#pragma omp parallel for num_threads(omp_get_max_threads()) private(           \
    dv1, dv3, loop_ub, i, unnamed_idx_1, unnamed_idx_2, i1, i2,                \
    tmp_size_idx_2, tmp_size_idx_1, i3, tmp_data)

    for (int32_T q = 0; q <= ub_loop; q++) {
      prism_gl_75(cs[cs.size(1) * q], cs[cs.size(1) * q + 1],
                  cs[cs.size(1) * q + 2], dv3, dv1);
      loop_ub = sfvals.size(1);
      for (i = 0; i < loop_ub; i++) {
        sfvals[i + sfvals.size(1) * q] = dv3[i];
      }
      unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i = 0;
      i1 = 0;
      loop_ub = 0;
      i2 = 0;
      tmp_size_idx_2 = sdvals.size(2);
      tmp_size_idx_1 = sdvals.size(1);
      for (i3 = 0; i3 < unnamed_idx_1 * unnamed_idx_2; i3++) {
        tmp_data[i1 + tmp_size_idx_2 * i] = dv1[i2 + 3 * loop_ub];
        loop_ub++;
        i++;
        if (i > tmp_size_idx_1 - 1) {
          i = 0;
          i1++;
        }
        if (loop_ub > 74) {
          loop_ub = 0;
          i2++;
        }
      }
      for (i = 0; i < tmp_size_idx_1; i++) {
        for (i1 = 0; i1 < tmp_size_idx_2; i1++) {
          sdvals[(i1 + sdvals.size(2) * i) +
                 sdvals.size(2) * sdvals.size(1) * q] =
              tmp_data[i1 + tmp_size_idx_2 * i];
        }
      }
    }
    break;
  default:
    //  m2cAssert  Throw error if condition false at runtime
    //
    //    m2cAssert(cond)
    //    m2cAssert(cond,msg)
    //    m2cAssert(cond,msg,A1,...,An)
    //    m2cAssert(cond,errID,msg)
    //    m2cAssert(cond,errID,msg,A1,...,An)
    //
    //  The interface of `m2cAssert` is compatible with MATLAB's built-in
    //  `assert`,  but it generates runtime assertion instead of compile-time
    //  assertion.
    //
    //  Note
    //  ----
    //  The MATLAB built-in `assert` is mostly used for compile-time error
    //  checking, and it has no effect for runtime error checking in LIB mode.
    //  Use `m2cAssert` instead for runtime error checking. Like the built-in
    //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
    //  into a code-generation-time character string. If you want to use both
    //  code-generation-time and runtime assertions, it is recommended to put
    //  `m2cAssert` before the built-in `assert`.
    //
    //  See also assert, m2cError, m2cWarning
    m2cAssert(etype == 213, "Gauss-Lobatto only supports up to quintic.");
//  Choose a mode for parfor
// ompForSerial - Transform a parfor loop to run in serial
//
//       ompForSerial
//
//  Note
//  ----
//
//  This directive must appear immediately before the parfor loop to be
//  affected.
//
//  Example
//  -------
//     ompForSerial;
//     parfor i=1:N
//        x(i) = y(i) + z(i);
//     end
//
//  See also ompSimd, ompSimdWithFor, ompForWithPar, ompForInPar
#pragma m2c ompForSerial();
    //  Serial mode
    ub_loop = cs.size(0) - 1;
#pragma omp parallel for num_threads(omp_get_max_threads()) private(           \
    dv4, dv5, loop_ub, i, unnamed_idx_1, unnamed_idx_2, i1, i2,                \
    tmp_size_idx_2, tmp_size_idx_1, i3, tmp_data)

    for (int32_T q = 0; q <= ub_loop; q++) {
      prism_gl_126(cs[cs.size(1) * q], cs[cs.size(1) * q + 1],
                   cs[cs.size(1) * q + 2], dv5, dv4);
      loop_ub = sfvals.size(1);
      for (i = 0; i < loop_ub; i++) {
        sfvals[i + sfvals.size(1) * q] = dv5[i];
      }
      unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i = 0;
      i1 = 0;
      loop_ub = 0;
      i2 = 0;
      tmp_size_idx_2 = sdvals.size(2);
      tmp_size_idx_1 = sdvals.size(1);
      for (i3 = 0; i3 < unnamed_idx_1 * unnamed_idx_2; i3++) {
        tmp_data[i1 + tmp_size_idx_2 * i] = dv4[i2 + 3 * loop_ub];
        loop_ub++;
        i++;
        if (i > tmp_size_idx_1 - 1) {
          i = 0;
          i1++;
        }
        if (loop_ub > 125) {
          loop_ub = 0;
          i2++;
        }
      }
      for (i = 0; i < tmp_size_idx_1; i++) {
        for (i1 = 0; i1 < tmp_size_idx_2; i1++) {
          sdvals[(i1 + sdvals.size(2) * i) +
                 sdvals.size(2) * sdvals.size(1) * q] =
              tmp_data[i1 + tmp_size_idx_2 * i];
        }
      }
    }
    break;
  }
}

static void sfe3_tabulate_gl_pyra(int32_T etype,
                                  const ::coder::array<real_T, 2U> &cs,
                                  ::coder::array<real_T, 2U> &sfvals,
                                  ::coder::array<real_T, 3U> &sdvals)
{
  real_T tmp_data[1029];
  real_T dv2[165];
  real_T dv[90];
  real_T dv3[55];
  real_T dv1[30];
  int32_T i;
  int32_T i1;
  int32_T i2;
  int32_T i3;
  int32_T loop_ub;
  int32_T tmp_size_idx_1;
  int32_T tmp_size_idx_2;
  int32_T ub_loop;
  int16_T unnamed_idx_1;
  int16_T unnamed_idx_2;
  //  pyra
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  ub_loop = iv[etype - 1];
  sfvals.set_size(cs.size(0), ub_loop);
  sdvals.set_size(cs.size(0), ub_loop, cs.size(1));
  if (etype == 173) {
//  Choose a mode for parfor
// ompForSerial - Transform a parfor loop to run in serial
//
//       ompForSerial
//
//  Note
//  ----
//
//  This directive must appear immediately before the parfor loop to be
//  affected.
//
//  Example
//  -------
//     ompForSerial;
//     parfor i=1:N
//        x(i) = y(i) + z(i);
//     end
//
//  See also ompSimd, ompSimdWithFor, ompForWithPar, ompForInPar
#pragma m2c ompForSerial();
    //  Serial mode
    ub_loop = cs.size(0) - 1;
#pragma omp parallel for num_threads(omp_get_max_threads()) private(           \
    dv, dv1, loop_ub, i, unnamed_idx_1, unnamed_idx_2, i1, i2, tmp_size_idx_2, \
    tmp_size_idx_1, i3, tmp_data)

    for (int32_T q = 0; q <= ub_loop; q++) {
      pyra_gl_30(cs[cs.size(1) * q], cs[cs.size(1) * q + 1],
                 cs[cs.size(1) * q + 2], dv1, dv);
      loop_ub = sfvals.size(1);
      for (i = 0; i < loop_ub; i++) {
        sfvals[i + sfvals.size(1) * q] = dv1[i];
      }
      unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i = 0;
      i1 = 0;
      loop_ub = 0;
      i2 = 0;
      tmp_size_idx_2 = sdvals.size(2);
      tmp_size_idx_1 = sdvals.size(1);
      for (i3 = 0; i3 < unnamed_idx_1 * unnamed_idx_2; i3++) {
        tmp_data[i1 + tmp_size_idx_2 * i] = dv[i2 + 3 * loop_ub];
        loop_ub++;
        i++;
        if (i > tmp_size_idx_1 - 1) {
          i = 0;
          i1++;
        }
        if (loop_ub > 29) {
          loop_ub = 0;
          i2++;
        }
      }
      for (i = 0; i < tmp_size_idx_1; i++) {
        for (i1 = 0; i1 < tmp_size_idx_2; i1++) {
          sdvals[(i1 + sdvals.size(2) * i) +
                 sdvals.size(2) * sdvals.size(1) * q] =
              tmp_data[i1 + tmp_size_idx_2 * i];
        }
      }
    }
  } else {
    //  m2cAssert  Throw error if condition false at runtime
    //
    //    m2cAssert(cond)
    //    m2cAssert(cond,msg)
    //    m2cAssert(cond,msg,A1,...,An)
    //    m2cAssert(cond,errID,msg)
    //    m2cAssert(cond,errID,msg,A1,...,An)
    //
    //  The interface of `m2cAssert` is compatible with MATLAB's built-in
    //  `assert`,  but it generates runtime assertion instead of compile-time
    //  assertion.
    //
    //  Note
    //  ----
    //  The MATLAB built-in `assert` is mostly used for compile-time error
    //  checking, and it has no effect for runtime error checking in LIB mode.
    //  Use `m2cAssert` instead for runtime error checking. Like the built-in
    //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
    //  into a code-generation-time character string. If you want to use both
    //  code-generation-time and runtime assertions, it is recommended to put
    //  `m2cAssert` before the built-in `assert`.
    //
    //  See also assert, m2cError, m2cWarning
    m2cAssert(etype == 177, "Pyramid only support up to quartic");
//  Choose a mode for parfor
// ompForSerial - Transform a parfor loop to run in serial
//
//       ompForSerial
//
//  Note
//  ----
//
//  This directive must appear immediately before the parfor loop to be
//  affected.
//
//  Example
//  -------
//     ompForSerial;
//     parfor i=1:N
//        x(i) = y(i) + z(i);
//     end
//
//  See also ompSimd, ompSimdWithFor, ompForWithPar, ompForInPar
#pragma m2c ompForSerial();
    //  Serial mode
    ub_loop = cs.size(0) - 1;
#pragma omp parallel for num_threads(omp_get_max_threads()) private(           \
    dv2, dv3, loop_ub, i, unnamed_idx_1, unnamed_idx_2, i1, i2,                \
    tmp_size_idx_2, tmp_size_idx_1, i3, tmp_data)

    for (int32_T q = 0; q <= ub_loop; q++) {
      pyra_gl_55(cs[cs.size(1) * q], cs[cs.size(1) * q + 1],
                 cs[cs.size(1) * q + 2], dv3, dv2);
      loop_ub = sfvals.size(1);
      for (i = 0; i < loop_ub; i++) {
        sfvals[i + sfvals.size(1) * q] = dv3[i];
      }
      unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i = 0;
      i1 = 0;
      loop_ub = 0;
      i2 = 0;
      tmp_size_idx_2 = sdvals.size(2);
      tmp_size_idx_1 = sdvals.size(1);
      for (i3 = 0; i3 < unnamed_idx_1 * unnamed_idx_2; i3++) {
        tmp_data[i1 + tmp_size_idx_2 * i] = dv2[i2 + 3 * loop_ub];
        loop_ub++;
        i++;
        if (i > tmp_size_idx_1 - 1) {
          i = 0;
          i1++;
        }
        if (loop_ub > 54) {
          loop_ub = 0;
          i2++;
        }
      }
      for (i = 0; i < tmp_size_idx_1; i++) {
        for (i1 = 0; i1 < tmp_size_idx_2; i1++) {
          sdvals[(i1 + sdvals.size(2) * i) +
                 sdvals.size(2) * sdvals.size(1) * q] =
              tmp_data[i1 + tmp_size_idx_2 * i];
        }
      }
    }
  }
}

static void sfe3_tabulate_gl_tet(int32_T etype,
                                 const ::coder::array<real_T, 2U> &cs,
                                 ::coder::array<real_T, 2U> &sfvals,
                                 ::coder::array<real_T, 3U> &sdvals)
{
  real_T tmp_data[1029];
  real_T dv2[105];
  real_T dv[60];
  real_T dv3[35];
  real_T dv1[20];
  int32_T i;
  int32_T i1;
  int32_T i2;
  int32_T i3;
  int32_T loop_ub;
  int32_T tmp_size_idx_1;
  int32_T tmp_size_idx_2;
  int32_T ub_loop;
  int16_T unnamed_idx_1;
  int16_T unnamed_idx_2;
  //  tet
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  ub_loop = iv[etype - 1];
  sfvals.set_size(cs.size(0), ub_loop);
  sdvals.set_size(cs.size(0), ub_loop, cs.size(1));
  if (etype == 141) {
//  Choose a mode for parfor
// ompForSerial - Transform a parfor loop to run in serial
//
//       ompForSerial
//
//  Note
//  ----
//
//  This directive must appear immediately before the parfor loop to be
//  affected.
//
//  Example
//  -------
//     ompForSerial;
//     parfor i=1:N
//        x(i) = y(i) + z(i);
//     end
//
//  See also ompSimd, ompSimdWithFor, ompForWithPar, ompForInPar
#pragma m2c ompForSerial();
    //  Serial mode
    ub_loop = cs.size(0) - 1;
#pragma omp parallel for num_threads(omp_get_max_threads()) private(           \
    dv, dv1, loop_ub, i, unnamed_idx_1, unnamed_idx_2, i1, i2, tmp_size_idx_2, \
    tmp_size_idx_1, i3, tmp_data)

    for (int32_T q = 0; q <= ub_loop; q++) {
      tet_gl_20(cs[cs.size(1) * q], cs[cs.size(1) * q + 1],
                cs[cs.size(1) * q + 2], dv1, dv);
      loop_ub = sfvals.size(1);
      for (i = 0; i < loop_ub; i++) {
        sfvals[i + sfvals.size(1) * q] = dv1[i];
      }
      unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i = 0;
      i1 = 0;
      loop_ub = 0;
      i2 = 0;
      tmp_size_idx_2 = sdvals.size(2);
      tmp_size_idx_1 = sdvals.size(1);
      for (i3 = 0; i3 < unnamed_idx_1 * unnamed_idx_2; i3++) {
        tmp_data[i1 + tmp_size_idx_2 * i] = dv[i2 + 3 * loop_ub];
        loop_ub++;
        i++;
        if (i > tmp_size_idx_1 - 1) {
          i = 0;
          i1++;
        }
        if (loop_ub > 19) {
          loop_ub = 0;
          i2++;
        }
      }
      for (i = 0; i < tmp_size_idx_1; i++) {
        for (i1 = 0; i1 < tmp_size_idx_2; i1++) {
          sdvals[(i1 + sdvals.size(2) * i) +
                 sdvals.size(2) * sdvals.size(1) * q] =
              tmp_data[i1 + tmp_size_idx_2 * i];
        }
      }
    }
  } else {
    //  m2cAssert  Throw error if condition false at runtime
    //
    //    m2cAssert(cond)
    //    m2cAssert(cond,msg)
    //    m2cAssert(cond,msg,A1,...,An)
    //    m2cAssert(cond,errID,msg)
    //    m2cAssert(cond,errID,msg,A1,...,An)
    //
    //  The interface of `m2cAssert` is compatible with MATLAB's built-in
    //  `assert`,  but it generates runtime assertion instead of compile-time
    //  assertion.
    //
    //  Note
    //  ----
    //  The MATLAB built-in `assert` is mostly used for compile-time error
    //  checking, and it has no effect for runtime error checking in LIB mode.
    //  Use `m2cAssert` instead for runtime error checking. Like the built-in
    //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
    //  into a code-generation-time character string. If you want to use both
    //  code-generation-time and runtime assertions, it is recommended to put
    //  `m2cAssert` before the built-in `assert`.
    //
    //  See also assert, m2cError, m2cWarning
    m2cAssert(
        etype == 145,
        "Gauss-Lobatto tetrahedral elements are supported only up to quartic");
//  Choose a mode for parfor
// ompForSerial - Transform a parfor loop to run in serial
//
//       ompForSerial
//
//  Note
//  ----
//
//  This directive must appear immediately before the parfor loop to be
//  affected.
//
//  Example
//  -------
//     ompForSerial;
//     parfor i=1:N
//        x(i) = y(i) + z(i);
//     end
//
//  See also ompSimd, ompSimdWithFor, ompForWithPar, ompForInPar
#pragma m2c ompForSerial();
    //  Serial mode
    ub_loop = cs.size(0) - 1;
#pragma omp parallel for num_threads(omp_get_max_threads()) private(           \
    dv2, dv3, loop_ub, i, unnamed_idx_1, unnamed_idx_2, i1, i2,                \
    tmp_size_idx_2, tmp_size_idx_1, i3, tmp_data)

    for (int32_T q = 0; q <= ub_loop; q++) {
      tet_gl_35(cs[cs.size(1) * q], cs[cs.size(1) * q + 1],
                cs[cs.size(1) * q + 2], dv3, dv2);
      loop_ub = sfvals.size(1);
      for (i = 0; i < loop_ub; i++) {
        sfvals[i + sfvals.size(1) * q] = dv3[i];
      }
      unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i = 0;
      i1 = 0;
      loop_ub = 0;
      i2 = 0;
      tmp_size_idx_2 = sdvals.size(2);
      tmp_size_idx_1 = sdvals.size(1);
      for (i3 = 0; i3 < unnamed_idx_1 * unnamed_idx_2; i3++) {
        tmp_data[i1 + tmp_size_idx_2 * i] = dv2[i2 + 3 * loop_ub];
        loop_ub++;
        i++;
        if (i > tmp_size_idx_1 - 1) {
          i = 0;
          i1++;
        }
        if (loop_ub > 34) {
          loop_ub = 0;
          i2++;
        }
      }
      for (i = 0; i < tmp_size_idx_1; i++) {
        for (i1 = 0; i1 < tmp_size_idx_2; i1++) {
          sdvals[(i1 + sdvals.size(2) * i) +
                 sdvals.size(2) * sdvals.size(1) * q] =
              tmp_data[i1 + tmp_size_idx_2 * i];
        }
      }
    }
  }
}

static void sfe3_tabulate_shapefuncs(int32_T etype,
                                     const ::coder::array<real_T, 2U> &cs,
                                     ::coder::array<real_T, 2U> &sfvals,
                                     ::coder::array<real_T, 3U> &sdvals)
{
  int32_T postype;
  // sfe3_tabulate_shapefuncs - Tabulate shape functions and sdvals at qpoints
  //
  //    [sfvals, sdvals] = sfe3_tabulate_shapefuncs(etype, cs)
  //    [sfvals, sdvals] = sfe3_tabulate_shapefuncs(etype, cs, []) ** Advanced
  //    OpenMP ** [sfvals, sdvals] = sfe3_tabulate_shapefuncs(etype, cs, [],
  //    nthreads) ** Basic OpenMP **
  //
  //  See also sfe1_tabulate_shapefuncs, sfe2_tabulate_shapefuncs
  // obtain_elemnodepos - Decode nodal position types, e.g., equidistance, GL
  //
  //    postype = obtain_elemnodepos(etype)
  //
  //  RETURNS
  //  -------
  //    postype:    Position type tag:
  //                    0: equidistance
  //                    1: GL
  //                    2: ...
  //
  //  See also obtain_elemdegree
  //  postype = etype&0b11
  postype = etype & 3;
  if (postype == 0) {
    int32_T i;
    // obtain_elemshape - Decode an element geometric shape from etype
    //
    //    shapeid = obtain_elemshape(etype)
    //
    //  RETURN
    //  ------
    //    shapeid:    Integer type of different geometry shapes:
    //                    1 - BAR
    //                    2 - TRI
    //                    3 - QUAD
    //                    4 - TET
    //                    5 - PYRAMID
    //                    6 - PRISM
    //                    7 - HEX
    //
    //  See also obtain_elemdim
    //  shapeid = (etype>>5)&0b111
    i = etype >> 5 & 7;
    if (i == 4) {
      sfe3_tabulate_equi_tet(etype, cs, sfvals, sdvals);
    } else if (i == 5) {
      sfe3_tabulate_equi_pyra(etype, cs, sfvals, sdvals);
    } else if (i == 6) {
      sfe3_tabulate_equi_prism(etype, cs, sfvals, sdvals);
    } else {
      sfe3_tabulate_equi_hexa(etype, cs, sfvals, sdvals);
    }
  } else {
    int32_T i;
    //  m2cAssert  Throw error if condition false at runtime
    //
    //    m2cAssert(cond)
    //    m2cAssert(cond,msg)
    //    m2cAssert(cond,msg,A1,...,An)
    //    m2cAssert(cond,errID,msg)
    //    m2cAssert(cond,errID,msg,A1,...,An)
    //
    //  The interface of `m2cAssert` is compatible with MATLAB's built-in
    //  `assert`,  but it generates runtime assertion instead of compile-time
    //  assertion.
    //
    //  Note
    //  ----
    //  The MATLAB built-in `assert` is mostly used for compile-time error
    //  checking, and it has no effect for runtime error checking in LIB mode.
    //  Use `m2cAssert` instead for runtime error checking. Like the built-in
    //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
    //  into a code-generation-time character string. If you want to use both
    //  code-generation-time and runtime assertions, it is recommended to put
    //  `m2cAssert` before the built-in `assert`.
    //
    //  See also assert, m2cError, m2cWarning
    m2cAssert(postype == 1,
              "Only supports Equidistant and Gauss-Lobatto points in 3D");
    // obtain_elemshape - Decode an element geometric shape from etype
    //
    //    shapeid = obtain_elemshape(etype)
    //
    //  RETURN
    //  ------
    //    shapeid:    Integer type of different geometry shapes:
    //                    1 - BAR
    //                    2 - TRI
    //                    3 - QUAD
    //                    4 - TET
    //                    5 - PYRAMID
    //                    6 - PRISM
    //                    7 - HEX
    //
    //  See also obtain_elemdim
    //  shapeid = (etype>>5)&0b111
    i = etype >> 5 & 7;
    if (i == 4) {
      sfe3_tabulate_gl_tet(etype, cs, sfvals, sdvals);
    } else if (i == 5) {
      sfe3_tabulate_gl_pyra(etype, cs, sfvals, sdvals);
    } else if (i == 6) {
      sfe3_tabulate_gl_prism(etype, cs, sfvals, sdvals);
    } else {
      sfe3_tabulate_gl_hexa(etype, cs, sfvals, sdvals);
    }
  }
}

static void sfe_init(SfeObject *b_sfe, const uint8_T etypes[2],
                     const ::coder::array<real_T, 2U> &xs,
                     const ::coder::array<real_T, 2U> &qd_or_natcoords)
{
  int32_T i;
  int32_T loop_ub;
  int32_T topo_dim;
  uint8_T c;
  uint8_T geom_etype;
  boolean_T flag;
  // sfe_init - Initialize/reinitialize an sfe object for non-boundary element
  //
  //    sfe = sfe_init(sfe, etypes, xs)
  //    sfe = sfe_init(sfe, etypes, xs, natcoords)
  //    sfe = sfe_init(sfe, etypes, xs, qd)
  //    sfe = sfe_init(sfe, etypes, xs, qd, userquad)
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An SfeObject instance
  //    etypes:     Element type(s), which can be a 2-vector, scalar, or [].
  //                A 2-vector specifies the solution and geometric element
  //                types, and it supports iso-, sub- and super-parametric
  //                elements. If two element types are equal, then one can use a
  //                scalar. An empty array ([]) instructs the function to reuse
  //                the element type and the tabulation stored in the `sfe`
  //                object (typically from a previous call).
  //    xs:         Physical coordinates of the element, which is defined in
  //                the geometric space
  //    qd:         Quadrature degree, a zero value indicate the use of default
  //                quadrature rules based on the element types. If `-1` is
  //                passed in, then the code will assume user-provided
  //                quadrature rule information
  //    userquad:   This field is only accessed if qd=-1. If provided, then
  //    userquad
  //                must be a nqp-by-(1+dim) array, where the first column
  //                vector is is the quadrature weights while the rest are their
  //                corresponding quadrature points, defined in the reference
  //                element.
  //
  //  In particular, the user can pass in specific natural coordinates on which
  //  we will compute shape functions and derivatives. In this situation, we
  //  will skip the computation of Jacobian.
  //
  //    natcoords:  List of natural coordinates defined by the user
  //
  //  EXAMPLES
  //  --------
  //  The following initializes a linear triangular element
  //
  //    >> sfe = sfe_init(SfeObject(0), SFE_TRI_3, xs);
  //
  //  The following initializes a quadratic tetrahedral element but with linear
  //  geometry
  //
  //    >> etypes = [SFE_TET_10; SFE_TET_4];
  //    >> sfe = sfe_init(SfeObject(0), etypes, xs);
  //
  //  The following initializes a bi-linear quadrilateral element with
  //  user-provided gravity quadrature rule
  //
  //    >> gravrule = [1, 0.5, 0.5];
  //    >> sfe = sfe_init(SfeObject(0), SFE_QUAD_4, xs, int32(-1), gravrule);
  //
  //  See also SfeObject, ElementTypes, sfe_init_grad
  //  For clarity
  //  Determine solution and geometric spaces
  if (etypes[1] == 0) {
    geom_etype = etypes[0];
  } else {
    geom_etype = etypes[1];
  }
  flag = (etypes[0] == geom_etype);
  if (!flag) {
    //  then the shapes must match
    // obtain_elemshape - Decode an element geometric shape from etype
    //
    //    shapeid = obtain_elemshape(etype)
    //
    //  RETURN
    //  ------
    //    shapeid:    Integer type of different geometry shapes:
    //                    1 - BAR
    //                    2 - TRI
    //                    3 - QUAD
    //                    4 - TET
    //                    5 - PYRAMID
    //                    6 - PRISM
    //                    7 - HEX
    //
    //  See also obtain_elemdim
    //  shapeid = (etype>>5)&0b111
    // obtain_elemshape - Decode an element geometric shape from etype
    //
    //    shapeid = obtain_elemshape(etype)
    //
    //  RETURN
    //  ------
    //    shapeid:    Integer type of different geometry shapes:
    //                    1 - BAR
    //                    2 - TRI
    //                    3 - QUAD
    //                    4 - TET
    //                    5 - PYRAMID
    //                    6 - PRISM
    //                    7 - HEX
    //
    //  See also obtain_elemdim
    //  shapeid = (etype>>5)&0b111
    flag = (static_cast<int32_T>(static_cast<uint32_T>(etypes[0]) >> 5) ==
            static_cast<int32_T>(static_cast<uint32_T>(geom_etype) >> 5));
  }
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(flag, "invalid element combinations");
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  //  Geometric dimension
  //  Topological dimension
  // obtain_elemdim - Obtain the dimension of an element
  //
  //    dim = obtain_elemdim(etype)
  //
  //  See also obtain_elemshape
  // obtain_elemshape - Decode an element geometric shape from etype
  //
  //    shapeid = obtain_elemshape(etype)
  //
  //  RETURN
  //  ------
  //    shapeid:    Integer type of different geometry shapes:
  //                    1 - BAR
  //                    2 - TRI
  //                    3 - QUAD
  //                    4 - TET
  //                    5 - PYRAMID
  //                    6 - PRISM
  //                    7 - HEX
  //
  //  See also obtain_elemdim
  //  shapeid = (etype>>5)&0b111
  c = static_cast<uint8_T>(static_cast<uint32_T>(etypes[0]) >> 5);
  topo_dim = ((c > 0) + (c > 1)) + (c > 3);
  //  Geometric dimension
  if (xs.size(1) < topo_dim) {
    //  m2cError  Throw error and display message in MATLAB or C++
    //
    //     m2cError(format)
    //     m2cError(format,A1,...,An)
    //     m2cError(errID,___)
    //
    //  This function has the same interface as MATLAB's built-in `error`,
    //  except that the `format` must be a constant string during code
    //  generation.
    //
    //  Notes
    //  -----
    //  The format must be a constant string during code-generation time.
    //
    //  See also error, m2cWarning
    m2cErrMsgIdAndTxt("sfe_init:badDim",
                      "geometric dim cannot be smaller than topo dim");
  }
  b_sfe->geom_dim = xs.size(1);
  //  assign geom dimension
  b_sfe->topo_dim = topo_dim;
  //  assign topo dimension
  //  Make sure the coordinate size are the same
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(iv[geom_etype - 1] == xs.size(0), "nnodes do not match");
  b_sfe->etypes[0] = etypes[0];
  b_sfe->etypes[1] = geom_etype;
  //  Get number of nodes per element
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  b_sfe->nnodes[0] = iv[etypes[0] - 1];
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  b_sfe->nnodes[1] = iv[geom_etype - 1];
  //  User-input natural coordinates
  b_sfe->nqp = qd_or_natcoords.size(0);
  b_sfe->ws.set_size(qd_or_natcoords.size(0));
  loop_ub = qd_or_natcoords.size(0);
  for (i = 0; i < loop_ub; i++) {
    b_sfe->ws[i] = 1.0;
  }
  //  user ones for dummy quad weights
  b_sfe->cs.set_size(qd_or_natcoords.size(0), topo_dim);
  i = qd_or_natcoords.size(0);
  for (int32_T q{0}; q < i; q++) {
    for (int32_T k{0}; k < topo_dim; k++) {
      b_sfe->cs[k + b_sfe->cs.size(1) * q] =
          qd_or_natcoords[k + qd_or_natcoords.size(1) * q];
    }
  }
  //  Solution space shape functions & derivs
  tabulate_shapefuncs(static_cast<int32_T>(etypes[0]), b_sfe->cs,
                      b_sfe->shapes_geom, b_sfe->derivs_geom);
  loop_ub = b_sfe->shapes_geom.size(1) * b_sfe->shapes_geom.size(0);
  b_sfe->shapes_sol.set_size(b_sfe->shapes_geom.size(0),
                             b_sfe->shapes_geom.size(1));
  for (i = 0; i < loop_ub; i++) {
    b_sfe->shapes_sol[i] = b_sfe->shapes_geom[i];
  }
  loop_ub = b_sfe->derivs_geom.size(2) * b_sfe->derivs_geom.size(1) *
            b_sfe->derivs_geom.size(0);
  b_sfe->derivs_sol.set_size(b_sfe->derivs_geom.size(0),
                             b_sfe->derivs_geom.size(1),
                             b_sfe->derivs_geom.size(2));
  for (i = 0; i < loop_ub; i++) {
    b_sfe->derivs_sol[i] = b_sfe->derivs_geom[i];
  }
  //  Geometry space shape functions & derivs
  if (etypes[0] != geom_etype) {
    tabulate_shapefuncs(static_cast<int32_T>(geom_etype), b_sfe->cs,
                        b_sfe->shapes_geom, b_sfe->derivs_geom);
  }
  //  potentially skip re-tabulating
  //  Compute phy. coordinates of qpoints
  b_sfe->cs_phy.set_size(qd_or_natcoords.size(0), xs.size(1));
  i = qd_or_natcoords.size(0);
  for (int32_T q{0}; q < i; q++) {
    //  NOTE The following can be optimized efficiently due to the the upper
    //  bound of dimension (i.e., size(xs,2)) is known.
    loop_ub = xs.size(1);
    for (int32_T k{0}; k < loop_ub; k++) {
      real_T v;
      int32_T m;
      // interpolate_shape - Interpolate f with q-th shape function in the table
      //
      //    v = interpolate_shape(shapes, q, f)
      //    v = interpolate_shape(shapes, q, f, k)
      m = b_sfe->shapes_geom.size(1);
      v = b_sfe->shapes_geom[b_sfe->shapes_geom.size(1) * q] * xs[k];
      for (int32_T b_i{2}; b_i <= m; b_i++) {
        v += b_sfe->shapes_geom[(b_i + b_sfe->shapes_geom.size(1) * q) - 1] *
             xs[k + xs.size(1) * (b_i - 1)];
      }
      b_sfe->cs_phy[k + b_sfe->cs_phy.size(1) * q] = v;
    }
  }
  //  Compute Jacobian
}

static void sfe_init(SfeObject *b_sfe, int32_T etypes,
                     const ::coder::array<real_T, 2U> &xs,
                     const ::coder::array<real_T, 2U> &qd_or_natcoords)
{
  int32_T i;
  int32_T loop_ub;
  int32_T shape;
  int32_T topo_dim;
  // sfe_init - Initialize/reinitialize an sfe object for non-boundary element
  //
  //    sfe = sfe_init(sfe, etypes, xs)
  //    sfe = sfe_init(sfe, etypes, xs, natcoords)
  //    sfe = sfe_init(sfe, etypes, xs, qd)
  //    sfe = sfe_init(sfe, etypes, xs, qd, userquad)
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An SfeObject instance
  //    etypes:     Element type(s), which can be a 2-vector, scalar, or [].
  //                A 2-vector specifies the solution and geometric element
  //                types, and it supports iso-, sub- and super-parametric
  //                elements. If two element types are equal, then one can use a
  //                scalar. An empty array ([]) instructs the function to reuse
  //                the element type and the tabulation stored in the `sfe`
  //                object (typically from a previous call).
  //    xs:         Physical coordinates of the element, which is defined in
  //                the geometric space
  //    qd:         Quadrature degree, a zero value indicate the use of default
  //                quadrature rules based on the element types. If `-1` is
  //                passed in, then the code will assume user-provided
  //                quadrature rule information
  //    userquad:   This field is only accessed if qd=-1. If provided, then
  //    userquad
  //                must be a nqp-by-(1+dim) array, where the first column
  //                vector is is the quadrature weights while the rest are their
  //                corresponding quadrature points, defined in the reference
  //                element.
  //
  //  In particular, the user can pass in specific natural coordinates on which
  //  we will compute shape functions and derivatives. In this situation, we
  //  will skip the computation of Jacobian.
  //
  //    natcoords:  List of natural coordinates defined by the user
  //
  //  EXAMPLES
  //  --------
  //  The following initializes a linear triangular element
  //
  //    >> sfe = sfe_init(SfeObject(0), SFE_TRI_3, xs);
  //
  //  The following initializes a quadratic tetrahedral element but with linear
  //  geometry
  //
  //    >> etypes = [SFE_TET_10; SFE_TET_4];
  //    >> sfe = sfe_init(SfeObject(0), etypes, xs);
  //
  //  The following initializes a bi-linear quadrilateral element with
  //  user-provided gravity quadrature rule
  //
  //    >> gravrule = [1, 0.5, 0.5];
  //    >> sfe = sfe_init(SfeObject(0), SFE_QUAD_4, xs, int32(-1), gravrule);
  //
  //  See also SfeObject, ElementTypes, sfe_init_grad
  //  For clarity
  //  Determine solution and geometric spaces
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(true, "invalid element combinations");
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  //  Geometric dimension
  //  Topological dimension
  // obtain_elemdim - Obtain the dimension of an element
  //
  //    dim = obtain_elemdim(etype)
  //
  //  See also obtain_elemshape
  // obtain_elemshape - Decode an element geometric shape from etype
  //
  //    shapeid = obtain_elemshape(etype)
  //
  //  RETURN
  //  ------
  //    shapeid:    Integer type of different geometry shapes:
  //                    1 - BAR
  //                    2 - TRI
  //                    3 - QUAD
  //                    4 - TET
  //                    5 - PYRAMID
  //                    6 - PRISM
  //                    7 - HEX
  //
  //  See also obtain_elemdim
  //  shapeid = (etype>>5)&0b111
  shape = etypes >> 5;
  topo_dim = ((shape > 0) + (shape > 1)) + (shape > 3);
  //  Geometric dimension
  if (xs.size(1) < topo_dim) {
    //  m2cError  Throw error and display message in MATLAB or C++
    //
    //     m2cError(format)
    //     m2cError(format,A1,...,An)
    //     m2cError(errID,___)
    //
    //  This function has the same interface as MATLAB's built-in `error`,
    //  except that the `format` must be a constant string during code
    //  generation.
    //
    //  Notes
    //  -----
    //  The format must be a constant string during code-generation time.
    //
    //  See also error, m2cWarning
    m2cErrMsgIdAndTxt("sfe_init:badDim",
                      "geometric dim cannot be smaller than topo dim");
  }
  b_sfe->geom_dim = xs.size(1);
  //  assign geom dimension
  b_sfe->topo_dim = topo_dim;
  //  assign topo dimension
  //  Make sure the coordinate size are the same
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(iv[etypes - 1] == xs.size(0), "nnodes do not match");
  b_sfe->etypes[0] = etypes;
  b_sfe->etypes[1] = etypes;
  //  Get number of nodes per element
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  i = iv[etypes - 1];
  b_sfe->nnodes[0] = i;
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  b_sfe->nnodes[1] = i;
  //  User-input natural coordinates
  b_sfe->nqp = qd_or_natcoords.size(0);
  b_sfe->ws.set_size(qd_or_natcoords.size(0));
  loop_ub = qd_or_natcoords.size(0);
  for (i = 0; i < loop_ub; i++) {
    b_sfe->ws[i] = 1.0;
  }
  //  user ones for dummy quad weights
  b_sfe->cs.set_size(qd_or_natcoords.size(0), topo_dim);
  i = qd_or_natcoords.size(0);
  for (int32_T q{0}; q < i; q++) {
    for (int32_T k{0}; k < topo_dim; k++) {
      b_sfe->cs[k + b_sfe->cs.size(1) * q] =
          qd_or_natcoords[k + qd_or_natcoords.size(1) * q];
    }
  }
  //  Solution space shape functions & derivs
  tabulate_shapefuncs(etypes, b_sfe->cs, b_sfe->shapes_sol, b_sfe->derivs_sol);
  //  Geometry space shape functions & derivs
  loop_ub = b_sfe->shapes_sol.size(1) * b_sfe->shapes_sol.size(0);
  b_sfe->shapes_geom.set_size(b_sfe->shapes_sol.size(0),
                              b_sfe->shapes_sol.size(1));
  for (i = 0; i < loop_ub; i++) {
    b_sfe->shapes_geom[i] = b_sfe->shapes_sol[i];
  }
  loop_ub = b_sfe->derivs_sol.size(2) * b_sfe->derivs_sol.size(1) *
            b_sfe->derivs_sol.size(0);
  b_sfe->derivs_geom.set_size(b_sfe->derivs_sol.size(0),
                              b_sfe->derivs_sol.size(1),
                              b_sfe->derivs_sol.size(2));
  for (i = 0; i < loop_ub; i++) {
    b_sfe->derivs_geom[i] = b_sfe->derivs_sol[i];
  }
  //  potentially skip re-tabulating
  //  Compute phy. coordinates of qpoints
  b_sfe->cs_phy.set_size(qd_or_natcoords.size(0), xs.size(1));
  i = qd_or_natcoords.size(0);
  for (int32_T q{0}; q < i; q++) {
    //  NOTE The following can be optimized efficiently due to the the upper
    //  bound of dimension (i.e., size(xs,2)) is known.
    loop_ub = xs.size(1);
    for (int32_T k{0}; k < loop_ub; k++) {
      real_T v;
      int32_T m;
      // interpolate_shape - Interpolate f with q-th shape function in the table
      //
      //    v = interpolate_shape(shapes, q, f)
      //    v = interpolate_shape(shapes, q, f, k)
      m = b_sfe->shapes_sol.size(1);
      v = b_sfe->shapes_sol[b_sfe->shapes_sol.size(1) * q] * xs[k];
      for (int32_T b_i{2}; b_i <= m; b_i++) {
        v += b_sfe->shapes_sol[(b_i + b_sfe->shapes_sol.size(1) * q) - 1] *
             xs[k + xs.size(1) * (b_i - 1)];
      }
      b_sfe->cs_phy[k + b_sfe->cs_phy.size(1) * q] = v;
    }
  }
  //  Compute Jacobian
}

static void sfe_init(SfeObject *b_sfe, const ::coder::array<real_T, 2U> &xs)
{
  real_T dv[9];
  real_T v;
  int32_T i;
  int32_T sfe_idx_0_tmp_tmp;
  boolean_T cond;
  // sfe_init - Initialize/reinitialize an sfe object for non-boundary element
  //
  //    sfe = sfe_init(sfe, etypes, xs)
  //    sfe = sfe_init(sfe, etypes, xs, natcoords)
  //    sfe = sfe_init(sfe, etypes, xs, qd)
  //    sfe = sfe_init(sfe, etypes, xs, qd, userquad)
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An SfeObject instance
  //    etypes:     Element type(s), which can be a 2-vector, scalar, or [].
  //                A 2-vector specifies the solution and geometric element
  //                types, and it supports iso-, sub- and super-parametric
  //                elements. If two element types are equal, then one can use a
  //                scalar. An empty array ([]) instructs the function to reuse
  //                the element type and the tabulation stored in the `sfe`
  //                object (typically from a previous call).
  //    xs:         Physical coordinates of the element, which is defined in
  //                the geometric space
  //    qd:         Quadrature degree, a zero value indicate the use of default
  //                quadrature rules based on the element types. If `-1` is
  //                passed in, then the code will assume user-provided
  //                quadrature rule information
  //    userquad:   This field is only accessed if qd=-1. If provided, then
  //    userquad
  //                must be a nqp-by-(1+dim) array, where the first column
  //                vector is is the quadrature weights while the rest are their
  //                corresponding quadrature points, defined in the reference
  //                element.
  //
  //  In particular, the user can pass in specific natural coordinates on which
  //  we will compute shape functions and derivatives. In this situation, we
  //  will skip the computation of Jacobian.
  //
  //    natcoords:  List of natural coordinates defined by the user
  //
  //  EXAMPLES
  //  --------
  //  The following initializes a linear triangular element
  //
  //    >> sfe = sfe_init(SfeObject(0), SFE_TRI_3, xs);
  //
  //  The following initializes a quadratic tetrahedral element but with linear
  //  geometry
  //
  //    >> etypes = [SFE_TET_10; SFE_TET_4];
  //    >> sfe = sfe_init(SfeObject(0), etypes, xs);
  //
  //  The following initializes a bi-linear quadrilateral element with
  //  user-provided gravity quadrature rule
  //
  //    >> gravrule = [1, 0.5, 0.5];
  //    >> sfe = sfe_init(SfeObject(0), SFE_QUAD_4, xs, int32(-1), gravrule);
  //
  //  See also SfeObject, ElementTypes, sfe_init_grad
  //  For clarity
  if ((b_sfe->etypes[0] > 0) && (iv[b_sfe->etypes[0] - 1] != 0)) {
    // obtain_elemnnodes - Obtain number of nodes per element given etype
    //
    //     nnodes = obtain_elemnnodes(etype)
    //
    //  This file was generated from update_nnodes_table
    //         % SFE_NODE_1
    //         % SFE_BAR_GL_2
    //         % SFE_BAR_GL_3
    //         % SFE_BAR_4
    //         % SFE_BAR_GL_4
    //         % SFE_BAR_5
    //         % SFE_BAR_GL_5
    //         % SFE_BAR_6
    //         % SFE_BAR_GL_6
    //         % SFE_BAR_7
    //         % SFE_BAR_GL_7
    //         % SFE_TRI_GL_3
    //         % SFE_TRI_GL_6
    //         % SFE_TRI_10
    //         % SFE_TRI_GL_10
    //         % SFE_TRI_15
    //         % SFE_TRI_GL_15
    //         % SFE_TRI_FEK_15
    //         % SFE_TRI_21
    //         % SFE_TRI_GL_21
    //         % SFE_TRI_FEK_21
    //         % SFE_TRI_28
    //         % SFE_TRI_GL_28
    //         % SFE_TRI_FEK_28
    //         % SFE_QUAD_GL_4
    //         % SFE_QUAD_GL_9
    //         % SFE_QUAD_16
    //         % SFE_QUAD_GL_16
    //         % SFE_QUAD_25
    //         % SFE_QUAD_GL_25
    //         % SFE_QUAD_36
    //         % SFE_QUAD_GL_36
    //         % SFE_QUAD_49
    //         % SFE_QUAD_GL_49
    //         % SFE_TET_GL_4
    //         % SFE_TET_GL_10
    //         % SFE_TET_20
    //         % SFE_TET_GL_20
    //         % SFE_TET_35
    //         % SFE_TET_GL_35
    //         % SFE_TET_FEK_35
    //         % SFE_TET_56
    //         % SFE_TET_GL_56
    //         % SFE_TET_FEK_56
    //         % SFE_TET_84
    //         % SFE_TET_GL_84
    //         % SFE_TET_FEK_84
    //         % SFE_PYRA_GL_5
    //         % SFE_PYRA_GL_14
    //         % SFE_PYRA_30
    //         % SFE_PYRA_GL_30
    //         % SFE_PYRA_55
    //         % SFE_PYRA_GL_55
    //         % SFE_PYRA_FEK_55
    //         % SFE_PYRA_91
    //         % SFE_PRISM_GL_6
    //         % SFE_PRISM_GL_18
    //         % SFE_PRISM_40
    //         % SFE_PRISM_GL_40
    //         % SFE_PRISM_75
    //         % SFE_PRISM_GL_75
    //         % SFE_PRISM_FEK_75
    //         % SFE_PRISM_126
    //         % SFE_PRISM_GL_126
    //         % SFE_PRISM_196
    //         % SFE_HEXA_GL_8
    //         % SFE_HEXA_GL_27
    //         % SFE_HEXA_64
    //         % SFE_HEXA_GL_64
    //         % SFE_HEXA_125
    //         % SFE_HEXA_GL_125
    //         % SFE_HEXA_216
    //         % SFE_HEXA_GL_216
    //         % SFE_HEXA_343
    //         % SFE_HEXA_GL_343
    cond = true;
  } else {
    cond = false;
  }
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(cond, "");
  //  potentially skip re-tabulating
  //  Compute phy. coordinates of qpoints
  sfe_idx_0_tmp_tmp = b_sfe->nqp;
  b_sfe->cs_phy.set_size(sfe_idx_0_tmp_tmp, xs.size(1));
  for (int32_T q{0}; q < sfe_idx_0_tmp_tmp; q++) {
    //  NOTE The following can be optimized efficiently due to the the upper
    //  bound of dimension (i.e., size(xs,2)) is known.
    i = xs.size(1);
    for (int32_T k{0}; k < i; k++) {
      int32_T m;
      // interpolate_shape - Interpolate f with q-th shape function in the table
      //
      //    v = interpolate_shape(shapes, q, f)
      //    v = interpolate_shape(shapes, q, f, k)
      m = b_sfe->shapes_geom.size(1);
      v = b_sfe->shapes_geom[b_sfe->shapes_geom.size(1) * q] * xs[k];
      for (int32_T b_i{2}; b_i <= m; b_i++) {
        v += b_sfe->shapes_geom[(b_i + b_sfe->shapes_geom.size(1) * q) - 1] *
             xs[k + xs.size(1) * (b_i - 1)];
      }
      b_sfe->cs_phy[k + b_sfe->cs_phy.size(1) * q] = v;
    }
  }
  //  Compute Jacobian
  b_sfe->wdetJ.set_size(b_sfe->nqp);
  if ((b_sfe->etypes[1] == 68) || (b_sfe->etypes[1] == 132) ||
      (b_sfe->etypes[1] == 36)) {
    real_T d;
    int32_T geom_dim;
    int32_T n;
    int32_T topo_dim;
    //  A single Jacobian matrix (transpose) is needed for simplex elements
    // compute_jact - Compute Jacobian^T and its determinant from q-th deriv in
    // table
    //
    //    [Jt, d] = compute_jactt(xs, derivs, q)
    //
    //  NOTES
    //  -----
    //  Jt is always shape of 3x3. But only topo_dim-by-geom_dim will be
    //  accessed for computing Jacobian matrix. Note that for 3D surfaces, the
    //  normal direction corresponding to q-th qpiont will be saved to the last
    //  row of J.
    //
    //  In particular, the orientation for the transpose of Jacobian matrix is
    //
    //             [dx/dxi    dy/dxi    dz/dxi  ]
    //        Jt = [dx/deta   dy/deta   dz/deta ]
    //             [dx/dzeta  dy/dzeta  dz/dzeta]
    //
    //  Hence, for surface and curve, Jt has shapes (d-1)xd and 1x3, resp
    //
    //  See also solve_sq
    geom_dim = xs.size(1);
    topo_dim = b_sfe->derivs_geom.size(2);
    std::memset(&dv[0], 0, 9U * sizeof(real_T));
    n = xs.size(0);
    for (int32_T k{0}; k < n; k++) {
      for (int32_T b_i{0}; b_i < topo_dim; b_i++) {
        for (int32_T j{0}; j < geom_dim; j++) {
          i = j + 3 * b_i;
          dv[i] += xs[j + xs.size(1) * k] *
                   b_sfe->derivs_geom[b_i + b_sfe->derivs_geom.size(2) * k];
        }
      }
    }
    if (xs.size(1) == b_sfe->derivs_geom.size(2)) {
      if (xs.size(1) == 1) {
        d = dv[0];
      } else if (xs.size(1) == 2) {
        // det2 - Compute determinant of 2x2 matrix.
        d = dv[0] * dv[4] - dv[1] * dv[3];
      } else {
        // det3 - Compute determinant of 3x3 matrix.
        d = (dv[2] * (dv[3] * dv[7] - dv[4] * dv[6]) +
             dv[5] * (dv[1] * dv[6] - dv[0] * dv[7])) +
            dv[8] * (dv[0] * dv[4] - dv[1] * dv[3]);
      }
    } else if (b_sfe->derivs_geom.size(2) == 1) {
      d = dv[0] * dv[0] + dv[1] * dv[1];
      if (xs.size(1) == 3) {
        d += dv[2] * dv[2];
      }
      d = std::sqrt(d);
    } else {
      //  must be 2x3
      // cross_lastcol - Compute cross(J(1,:),J(2,:)) and store to J(3,:)
      dv[6] = dv[1] * dv[5] - dv[2] * dv[4];
      dv[7] = dv[2] * dv[3] - dv[0] * dv[5];
      dv[8] = dv[0] * dv[4] - dv[1] * dv[3];
      d = std::sqrt((dv[6] * dv[6] + dv[7] * dv[7]) + dv[8] * dv[8]);
    }
    b_sfe->jacTs.set_size(3, 3);
    for (i = 0; i < 9; i++) {
      b_sfe->jacTs[i] = dv[i];
    }
    for (int32_T q{0}; q < sfe_idx_0_tmp_tmp; q++) {
      b_sfe->wdetJ[q] = d * b_sfe->ws[q];
    }
  } else {
    int32_T sfe_idx_0;
    //  Super-parametric
    sfe_idx_0 = b_sfe->nqp * 3;
    b_sfe->jacTs.set_size(sfe_idx_0, 3);
    for (int32_T q{0}; q < sfe_idx_0_tmp_tmp; q++) {
      int32_T geom_dim;
      int32_T n;
      int32_T topo_dim;
      int32_T y;
      y = q * 3;
      // compute_jact - Compute Jacobian^T and its determinant from q-th deriv
      // in table
      //
      //    [Jt, d] = compute_jactt(xs, derivs, q)
      //
      //  NOTES
      //  -----
      //  Jt is always shape of 3x3. But only topo_dim-by-geom_dim will be
      //  accessed for computing Jacobian matrix. Note that for 3D surfaces, the
      //  normal direction corresponding to q-th qpiont will be saved to the
      //  last row of J.
      //
      //  In particular, the orientation for the transpose of Jacobian matrix is
      //
      //             [dx/dxi    dy/dxi    dz/dxi  ]
      //        Jt = [dx/deta   dy/deta   dz/deta ]
      //             [dx/dzeta  dy/dzeta  dz/dzeta]
      //
      //  Hence, for surface and curve, Jt has shapes (d-1)xd and 1x3, resp
      //
      //  See also solve_sq
      geom_dim = xs.size(1);
      topo_dim = b_sfe->derivs_geom.size(2);
      std::memset(&dv[0], 0, 9U * sizeof(real_T));
      n = xs.size(0);
      for (int32_T k{0}; k < n; k++) {
        for (int32_T b_i{0}; b_i < topo_dim; b_i++) {
          for (int32_T j{0}; j < geom_dim; j++) {
            i = j + 3 * b_i;
            dv[i] += xs[j + xs.size(1) * k] *
                     b_sfe->derivs_geom[(b_i + b_sfe->derivs_geom.size(2) * k) +
                                        b_sfe->derivs_geom.size(2) *
                                            b_sfe->derivs_geom.size(1) * q];
          }
        }
      }
      if (xs.size(1) == b_sfe->derivs_geom.size(2)) {
        if (xs.size(1) == 1) {
          v = dv[0];
        } else if (xs.size(1) == 2) {
          // det2 - Compute determinant of 2x2 matrix.
          v = dv[0] * dv[4] - dv[1] * dv[3];
        } else {
          // det3 - Compute determinant of 3x3 matrix.
          v = (dv[2] * (dv[3] * dv[7] - dv[4] * dv[6]) +
               dv[5] * (dv[1] * dv[6] - dv[0] * dv[7])) +
              dv[8] * (dv[0] * dv[4] - dv[1] * dv[3]);
        }
      } else if (b_sfe->derivs_geom.size(2) == 1) {
        v = dv[0] * dv[0] + dv[1] * dv[1];
        if (xs.size(1) == 3) {
          v += dv[2] * dv[2];
        }
        v = std::sqrt(v);
      } else {
        //  must be 2x3
        // cross_lastcol - Compute cross(J(1,:),J(2,:)) and store to J(3,:)
        dv[6] = dv[1] * dv[5] - dv[2] * dv[4];
        dv[7] = dv[2] * dv[3] - dv[0] * dv[5];
        dv[8] = dv[0] * dv[4] - dv[1] * dv[3];
        v = std::sqrt((dv[6] * dv[6] + dv[7] * dv[7]) + dv[8] * dv[8]);
      }
      for (i = 0; i < 3; i++) {
        sfe_idx_0 = i + y;
        b_sfe->jacTs[3 * sfe_idx_0] = dv[3 * i];
        b_sfe->jacTs[3 * sfe_idx_0 + 1] = dv[3 * i + 1];
        b_sfe->jacTs[3 * sfe_idx_0 + 2] = dv[3 * i + 2];
      }
      b_sfe->wdetJ[q] = v;
      b_sfe->wdetJ[q] = b_sfe->wdetJ[q] * b_sfe->ws[q];
    }
  }
}

static void sfe_init(SfeObject *b_sfe, const uint8_T etypes[2],
                     const ::coder::array<real_T, 2U> &xs)
{
  real_T dv[9];
  real_T v;
  int32_T i;
  int32_T loop_ub;
  int32_T sfe_idx_0_tmp_tmp;
  int32_T topo_dim;
  uint8_T c;
  uint8_T geom_etype;
  boolean_T flag;
  // sfe_init - Initialize/reinitialize an sfe object for non-boundary element
  //
  //    sfe = sfe_init(sfe, etypes, xs)
  //    sfe = sfe_init(sfe, etypes, xs, natcoords)
  //    sfe = sfe_init(sfe, etypes, xs, qd)
  //    sfe = sfe_init(sfe, etypes, xs, qd, userquad)
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An SfeObject instance
  //    etypes:     Element type(s), which can be a 2-vector, scalar, or [].
  //                A 2-vector specifies the solution and geometric element
  //                types, and it supports iso-, sub- and super-parametric
  //                elements. If two element types are equal, then one can use a
  //                scalar. An empty array ([]) instructs the function to reuse
  //                the element type and the tabulation stored in the `sfe`
  //                object (typically from a previous call).
  //    xs:         Physical coordinates of the element, which is defined in
  //                the geometric space
  //    qd:         Quadrature degree, a zero value indicate the use of default
  //                quadrature rules based on the element types. If `-1` is
  //                passed in, then the code will assume user-provided
  //                quadrature rule information
  //    userquad:   This field is only accessed if qd=-1. If provided, then
  //    userquad
  //                must be a nqp-by-(1+dim) array, where the first column
  //                vector is is the quadrature weights while the rest are their
  //                corresponding quadrature points, defined in the reference
  //                element.
  //
  //  In particular, the user can pass in specific natural coordinates on which
  //  we will compute shape functions and derivatives. In this situation, we
  //  will skip the computation of Jacobian.
  //
  //    natcoords:  List of natural coordinates defined by the user
  //
  //  EXAMPLES
  //  --------
  //  The following initializes a linear triangular element
  //
  //    >> sfe = sfe_init(SfeObject(0), SFE_TRI_3, xs);
  //
  //  The following initializes a quadratic tetrahedral element but with linear
  //  geometry
  //
  //    >> etypes = [SFE_TET_10; SFE_TET_4];
  //    >> sfe = sfe_init(SfeObject(0), etypes, xs);
  //
  //  The following initializes a bi-linear quadrilateral element with
  //  user-provided gravity quadrature rule
  //
  //    >> gravrule = [1, 0.5, 0.5];
  //    >> sfe = sfe_init(SfeObject(0), SFE_QUAD_4, xs, int32(-1), gravrule);
  //
  //  See also SfeObject, ElementTypes, sfe_init_grad
  //  For clarity
  //  Determine solution and geometric spaces
  if (etypes[1] == 0) {
    geom_etype = etypes[0];
  } else {
    geom_etype = etypes[1];
  }
  flag = (etypes[0] == geom_etype);
  if (!flag) {
    //  then the shapes must match
    // obtain_elemshape - Decode an element geometric shape from etype
    //
    //    shapeid = obtain_elemshape(etype)
    //
    //  RETURN
    //  ------
    //    shapeid:    Integer type of different geometry shapes:
    //                    1 - BAR
    //                    2 - TRI
    //                    3 - QUAD
    //                    4 - TET
    //                    5 - PYRAMID
    //                    6 - PRISM
    //                    7 - HEX
    //
    //  See also obtain_elemdim
    //  shapeid = (etype>>5)&0b111
    // obtain_elemshape - Decode an element geometric shape from etype
    //
    //    shapeid = obtain_elemshape(etype)
    //
    //  RETURN
    //  ------
    //    shapeid:    Integer type of different geometry shapes:
    //                    1 - BAR
    //                    2 - TRI
    //                    3 - QUAD
    //                    4 - TET
    //                    5 - PYRAMID
    //                    6 - PRISM
    //                    7 - HEX
    //
    //  See also obtain_elemdim
    //  shapeid = (etype>>5)&0b111
    flag = (static_cast<int32_T>(static_cast<uint32_T>(etypes[0]) >> 5) ==
            static_cast<int32_T>(static_cast<uint32_T>(geom_etype) >> 5));
  }
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(flag, "invalid element combinations");
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  //  Geometric dimension
  //  Topological dimension
  // obtain_elemdim - Obtain the dimension of an element
  //
  //    dim = obtain_elemdim(etype)
  //
  //  See also obtain_elemshape
  // obtain_elemshape - Decode an element geometric shape from etype
  //
  //    shapeid = obtain_elemshape(etype)
  //
  //  RETURN
  //  ------
  //    shapeid:    Integer type of different geometry shapes:
  //                    1 - BAR
  //                    2 - TRI
  //                    3 - QUAD
  //                    4 - TET
  //                    5 - PYRAMID
  //                    6 - PRISM
  //                    7 - HEX
  //
  //  See also obtain_elemdim
  //  shapeid = (etype>>5)&0b111
  c = static_cast<uint8_T>(static_cast<uint32_T>(etypes[0]) >> 5);
  topo_dim = ((c > 0) + (c > 1)) + (c > 3);
  //  Geometric dimension
  if (xs.size(1) < topo_dim) {
    //  m2cError  Throw error and display message in MATLAB or C++
    //
    //     m2cError(format)
    //     m2cError(format,A1,...,An)
    //     m2cError(errID,___)
    //
    //  This function has the same interface as MATLAB's built-in `error`,
    //  except that the `format` must be a constant string during code
    //  generation.
    //
    //  Notes
    //  -----
    //  The format must be a constant string during code-generation time.
    //
    //  See also error, m2cWarning
    m2cErrMsgIdAndTxt("sfe_init:badDim",
                      "geometric dim cannot be smaller than topo dim");
  }
  b_sfe->geom_dim = xs.size(1);
  //  assign geom dimension
  b_sfe->topo_dim = topo_dim;
  //  assign topo dimension
  //  Make sure the coordinate size are the same
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(iv[geom_etype - 1] == xs.size(0), "nnodes do not match");
  b_sfe->etypes[0] = etypes[0];
  b_sfe->etypes[1] = geom_etype;
  //  Get number of nodes per element
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  b_sfe->nnodes[0] = iv[etypes[0] - 1];
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  b_sfe->nnodes[1] = iv[geom_etype - 1];
  //  Set up quadrature
  //  trial+test+nonlinear_geom?1:0
  //  NOTE, this might be overkill for gradient
  // obtain_elemdegree - Decode the element degree from etype
  //
  //    deg = obtain_elemdegree(etype)
  //
  //  See also obtain_elemnnodes
  //  deg = (etype>>2)&0b111;
  // obtain_elemdegree - Decode the element degree from etype
  //
  //    deg = obtain_elemdegree(etype)
  //
  //  See also obtain_elemnnodes
  //  deg = (etype>>2)&0b111;
  tabulate_quadratures(
      static_cast<int32_T>(etypes[0]),
      (((etypes[0] >> 2 & 7) << 1) + ((geom_etype >> 2 & 7) > 1)) +
          (xs.size(1) > topo_dim),
      b_sfe->cs, b_sfe->ws);
  b_sfe->nqp = b_sfe->ws.size(0);
  //  Solution space shape functions & derivs
  tabulate_shapefuncs(static_cast<int32_T>(etypes[0]), b_sfe->cs,
                      b_sfe->shapes_geom, b_sfe->derivs_geom);
  loop_ub = b_sfe->shapes_geom.size(1) * b_sfe->shapes_geom.size(0);
  b_sfe->shapes_sol.set_size(b_sfe->shapes_geom.size(0),
                             b_sfe->shapes_geom.size(1));
  for (i = 0; i < loop_ub; i++) {
    b_sfe->shapes_sol[i] = b_sfe->shapes_geom[i];
  }
  loop_ub = b_sfe->derivs_geom.size(2) * b_sfe->derivs_geom.size(1) *
            b_sfe->derivs_geom.size(0);
  b_sfe->derivs_sol.set_size(b_sfe->derivs_geom.size(0),
                             b_sfe->derivs_geom.size(1),
                             b_sfe->derivs_geom.size(2));
  for (i = 0; i < loop_ub; i++) {
    b_sfe->derivs_sol[i] = b_sfe->derivs_geom[i];
  }
  //  Geometry space shape functions & derivs
  if (etypes[0] != geom_etype) {
    tabulate_shapefuncs(static_cast<int32_T>(geom_etype), b_sfe->cs,
                        b_sfe->shapes_geom, b_sfe->derivs_geom);
  }
  //  potentially skip re-tabulating
  //  Compute phy. coordinates of qpoints
  sfe_idx_0_tmp_tmp = b_sfe->nqp;
  b_sfe->cs_phy.set_size(sfe_idx_0_tmp_tmp, xs.size(1));
  for (int32_T q{0}; q < sfe_idx_0_tmp_tmp; q++) {
    //  NOTE The following can be optimized efficiently due to the the upper
    //  bound of dimension (i.e., size(xs,2)) is known.
    i = xs.size(1);
    for (int32_T k{0}; k < i; k++) {
      int32_T m;
      // interpolate_shape - Interpolate f with q-th shape function in the table
      //
      //    v = interpolate_shape(shapes, q, f)
      //    v = interpolate_shape(shapes, q, f, k)
      m = b_sfe->shapes_geom.size(1);
      v = b_sfe->shapes_geom[b_sfe->shapes_geom.size(1) * q] * xs[k];
      for (int32_T b_i{2}; b_i <= m; b_i++) {
        v += b_sfe->shapes_geom[(b_i + b_sfe->shapes_geom.size(1) * q) - 1] *
             xs[k + xs.size(1) * (b_i - 1)];
      }
      b_sfe->cs_phy[k + b_sfe->cs_phy.size(1) * q] = v;
    }
  }
  //  Compute Jacobian
  b_sfe->wdetJ.set_size(b_sfe->nqp);
  if ((geom_etype == 68) || (geom_etype == 132) || (geom_etype == 36)) {
    real_T d;
    int32_T geom_dim;
    int32_T n;
    //  A single Jacobian matrix (transpose) is needed for simplex elements
    // compute_jact - Compute Jacobian^T and its determinant from q-th deriv in
    // table
    //
    //    [Jt, d] = compute_jactt(xs, derivs, q)
    //
    //  NOTES
    //  -----
    //  Jt is always shape of 3x3. But only topo_dim-by-geom_dim will be
    //  accessed for computing Jacobian matrix. Note that for 3D surfaces, the
    //  normal direction corresponding to q-th qpiont will be saved to the last
    //  row of J.
    //
    //  In particular, the orientation for the transpose of Jacobian matrix is
    //
    //             [dx/dxi    dy/dxi    dz/dxi  ]
    //        Jt = [dx/deta   dy/deta   dz/deta ]
    //             [dx/dzeta  dy/dzeta  dz/dzeta]
    //
    //  Hence, for surface and curve, Jt has shapes (d-1)xd and 1x3, resp
    //
    //  See also solve_sq
    geom_dim = xs.size(1);
    topo_dim = b_sfe->derivs_geom.size(2);
    std::memset(&dv[0], 0, 9U * sizeof(real_T));
    n = xs.size(0);
    for (int32_T k{0}; k < n; k++) {
      for (int32_T b_i{0}; b_i < topo_dim; b_i++) {
        for (int32_T j{0}; j < geom_dim; j++) {
          i = j + 3 * b_i;
          dv[i] += xs[j + xs.size(1) * k] *
                   b_sfe->derivs_geom[b_i + b_sfe->derivs_geom.size(2) * k];
        }
      }
    }
    if (xs.size(1) == b_sfe->derivs_geom.size(2)) {
      if (xs.size(1) == 1) {
        d = dv[0];
      } else if (xs.size(1) == 2) {
        // det2 - Compute determinant of 2x2 matrix.
        d = dv[0] * dv[4] - dv[1] * dv[3];
      } else {
        // det3 - Compute determinant of 3x3 matrix.
        d = (dv[2] * (dv[3] * dv[7] - dv[4] * dv[6]) +
             dv[5] * (dv[1] * dv[6] - dv[0] * dv[7])) +
            dv[8] * (dv[0] * dv[4] - dv[1] * dv[3]);
      }
    } else if (b_sfe->derivs_geom.size(2) == 1) {
      d = dv[0] * dv[0] + dv[1] * dv[1];
      if (xs.size(1) == 3) {
        d += dv[2] * dv[2];
      }
      d = std::sqrt(d);
    } else {
      //  must be 2x3
      // cross_lastcol - Compute cross(J(1,:),J(2,:)) and store to J(3,:)
      dv[6] = dv[1] * dv[5] - dv[2] * dv[4];
      dv[7] = dv[2] * dv[3] - dv[0] * dv[5];
      dv[8] = dv[0] * dv[4] - dv[1] * dv[3];
      d = std::sqrt((dv[6] * dv[6] + dv[7] * dv[7]) + dv[8] * dv[8]);
    }
    b_sfe->jacTs.set_size(3, 3);
    for (i = 0; i < 9; i++) {
      b_sfe->jacTs[i] = dv[i];
    }
    for (int32_T q{0}; q < sfe_idx_0_tmp_tmp; q++) {
      b_sfe->wdetJ[q] = d * b_sfe->ws[q];
    }
  } else {
    //  Super-parametric
    loop_ub = b_sfe->nqp * 3;
    b_sfe->jacTs.set_size(loop_ub, 3);
    for (int32_T q{0}; q < sfe_idx_0_tmp_tmp; q++) {
      int32_T geom_dim;
      int32_T n;
      int32_T y;
      y = q * 3;
      // compute_jact - Compute Jacobian^T and its determinant from q-th deriv
      // in table
      //
      //    [Jt, d] = compute_jactt(xs, derivs, q)
      //
      //  NOTES
      //  -----
      //  Jt is always shape of 3x3. But only topo_dim-by-geom_dim will be
      //  accessed for computing Jacobian matrix. Note that for 3D surfaces, the
      //  normal direction corresponding to q-th qpiont will be saved to the
      //  last row of J.
      //
      //  In particular, the orientation for the transpose of Jacobian matrix is
      //
      //             [dx/dxi    dy/dxi    dz/dxi  ]
      //        Jt = [dx/deta   dy/deta   dz/deta ]
      //             [dx/dzeta  dy/dzeta  dz/dzeta]
      //
      //  Hence, for surface and curve, Jt has shapes (d-1)xd and 1x3, resp
      //
      //  See also solve_sq
      geom_dim = xs.size(1);
      topo_dim = b_sfe->derivs_geom.size(2);
      std::memset(&dv[0], 0, 9U * sizeof(real_T));
      n = xs.size(0);
      for (int32_T k{0}; k < n; k++) {
        for (int32_T b_i{0}; b_i < topo_dim; b_i++) {
          for (int32_T j{0}; j < geom_dim; j++) {
            i = j + 3 * b_i;
            dv[i] += xs[j + xs.size(1) * k] *
                     b_sfe->derivs_geom[(b_i + b_sfe->derivs_geom.size(2) * k) +
                                        b_sfe->derivs_geom.size(2) *
                                            b_sfe->derivs_geom.size(1) * q];
          }
        }
      }
      if (xs.size(1) == b_sfe->derivs_geom.size(2)) {
        if (xs.size(1) == 1) {
          v = dv[0];
        } else if (xs.size(1) == 2) {
          // det2 - Compute determinant of 2x2 matrix.
          v = dv[0] * dv[4] - dv[1] * dv[3];
        } else {
          // det3 - Compute determinant of 3x3 matrix.
          v = (dv[2] * (dv[3] * dv[7] - dv[4] * dv[6]) +
               dv[5] * (dv[1] * dv[6] - dv[0] * dv[7])) +
              dv[8] * (dv[0] * dv[4] - dv[1] * dv[3]);
        }
      } else if (b_sfe->derivs_geom.size(2) == 1) {
        v = dv[0] * dv[0] + dv[1] * dv[1];
        if (xs.size(1) == 3) {
          v += dv[2] * dv[2];
        }
        v = std::sqrt(v);
      } else {
        //  must be 2x3
        // cross_lastcol - Compute cross(J(1,:),J(2,:)) and store to J(3,:)
        dv[6] = dv[1] * dv[5] - dv[2] * dv[4];
        dv[7] = dv[2] * dv[3] - dv[0] * dv[5];
        dv[8] = dv[0] * dv[4] - dv[1] * dv[3];
        v = std::sqrt((dv[6] * dv[6] + dv[7] * dv[7]) + dv[8] * dv[8]);
      }
      for (i = 0; i < 3; i++) {
        loop_ub = i + y;
        b_sfe->jacTs[3 * loop_ub] = dv[3 * i];
        b_sfe->jacTs[3 * loop_ub + 1] = dv[3 * i + 1];
        b_sfe->jacTs[3 * loop_ub + 2] = dv[3 * i + 2];
      }
      b_sfe->wdetJ[q] = v;
      b_sfe->wdetJ[q] = b_sfe->wdetJ[q] * b_sfe->ws[q];
    }
  }
}

static void sfe_init(SfeObject *b_sfe,
                     const ::coder::array<int32_T, 1U> &etypes,
                     const real_T xs_data[], const int32_T xs_size[2],
                     const ::coder::array<real_T, 2U> &qd_or_natcoords)
{
  int32_T i;
  int32_T loop_ub;
  // sfe_init - Initialize/reinitialize an sfe object for non-boundary element
  //
  //    sfe = sfe_init(sfe, etypes, xs)
  //    sfe = sfe_init(sfe, etypes, xs, natcoords)
  //    sfe = sfe_init(sfe, etypes, xs, qd)
  //    sfe = sfe_init(sfe, etypes, xs, qd, userquad)
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An SfeObject instance
  //    etypes:     Element type(s), which can be a 2-vector, scalar, or [].
  //                A 2-vector specifies the solution and geometric element
  //                types, and it supports iso-, sub- and super-parametric
  //                elements. If two element types are equal, then one can use a
  //                scalar. An empty array ([]) instructs the function to reuse
  //                the element type and the tabulation stored in the `sfe`
  //                object (typically from a previous call).
  //    xs:         Physical coordinates of the element, which is defined in
  //                the geometric space
  //    qd:         Quadrature degree, a zero value indicate the use of default
  //                quadrature rules based on the element types. If `-1` is
  //                passed in, then the code will assume user-provided
  //                quadrature rule information
  //    userquad:   This field is only accessed if qd=-1. If provided, then
  //    userquad
  //                must be a nqp-by-(1+dim) array, where the first column
  //                vector is is the quadrature weights while the rest are their
  //                corresponding quadrature points, defined in the reference
  //                element.
  //
  //  In particular, the user can pass in specific natural coordinates on which
  //  we will compute shape functions and derivatives. In this situation, we
  //  will skip the computation of Jacobian.
  //
  //    natcoords:  List of natural coordinates defined by the user
  //
  //  EXAMPLES
  //  --------
  //  The following initializes a linear triangular element
  //
  //    >> sfe = sfe_init(SfeObject(0), SFE_TRI_3, xs);
  //
  //  The following initializes a quadratic tetrahedral element but with linear
  //  geometry
  //
  //    >> etypes = [SFE_TET_10; SFE_TET_4];
  //    >> sfe = sfe_init(SfeObject(0), etypes, xs);
  //
  //  The following initializes a bi-linear quadrilateral element with
  //  user-provided gravity quadrature rule
  //
  //    >> gravrule = [1, 0.5, 0.5];
  //    >> sfe = sfe_init(SfeObject(0), SFE_QUAD_4, xs, int32(-1), gravrule);
  //
  //  See also SfeObject, ElementTypes, sfe_init_grad
  //  For clarity
  if (etypes.size(0) != 0) {
    int32_T geom_etype;
    int32_T shape;
    int32_T topo_dim;
    boolean_T cond;
    //  Determine solution and geometric spaces
    if ((etypes.size(0) < 2) || (etypes[1] == 0)) {
      geom_etype = etypes[0];
    } else {
      geom_etype = etypes[1];
    }
    cond = (etypes[0] == geom_etype);
    if (!cond) {
      //  then the shapes must match
      // obtain_elemshape - Decode an element geometric shape from etype
      //
      //    shapeid = obtain_elemshape(etype)
      //
      //  RETURN
      //  ------
      //    shapeid:    Integer type of different geometry shapes:
      //                    1 - BAR
      //                    2 - TRI
      //                    3 - QUAD
      //                    4 - TET
      //                    5 - PYRAMID
      //                    6 - PRISM
      //                    7 - HEX
      //
      //  See also obtain_elemdim
      //  shapeid = (etype>>5)&0b111
      // obtain_elemshape - Decode an element geometric shape from etype
      //
      //    shapeid = obtain_elemshape(etype)
      //
      //  RETURN
      //  ------
      //    shapeid:    Integer type of different geometry shapes:
      //                    1 - BAR
      //                    2 - TRI
      //                    3 - QUAD
      //                    4 - TET
      //                    5 - PYRAMID
      //                    6 - PRISM
      //                    7 - HEX
      //
      //  See also obtain_elemdim
      //  shapeid = (etype>>5)&0b111
      cond = ((etypes[0] >> 5 & 7) == (geom_etype >> 5 & 7));
    }
    //  m2cAssert  Throw error if condition false at runtime
    //
    //    m2cAssert(cond)
    //    m2cAssert(cond,msg)
    //    m2cAssert(cond,msg,A1,...,An)
    //    m2cAssert(cond,errID,msg)
    //    m2cAssert(cond,errID,msg,A1,...,An)
    //
    //  The interface of `m2cAssert` is compatible with MATLAB's built-in
    //  `assert`,  but it generates runtime assertion instead of compile-time
    //  assertion.
    //
    //  Note
    //  ----
    //  The MATLAB built-in `assert` is mostly used for compile-time error
    //  checking, and it has no effect for runtime error checking in LIB mode.
    //  Use `m2cAssert` instead for runtime error checking. Like the built-in
    //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
    //  into a code-generation-time character string. If you want to use both
    //  code-generation-time and runtime assertions, it is recommended to put
    //  `m2cAssert` before the built-in `assert`.
    //
    //  See also assert, m2cError, m2cWarning
    m2cAssert(cond, "invalid element combinations");
    // obtain_elemnnodes - Obtain number of nodes per element given etype
    //
    //     nnodes = obtain_elemnnodes(etype)
    //
    //  This file was generated from update_nnodes_table
    //         % SFE_NODE_1
    //         % SFE_BAR_GL_2
    //         % SFE_BAR_GL_3
    //         % SFE_BAR_4
    //         % SFE_BAR_GL_4
    //         % SFE_BAR_5
    //         % SFE_BAR_GL_5
    //         % SFE_BAR_6
    //         % SFE_BAR_GL_6
    //         % SFE_BAR_7
    //         % SFE_BAR_GL_7
    //         % SFE_TRI_GL_3
    //         % SFE_TRI_GL_6
    //         % SFE_TRI_10
    //         % SFE_TRI_GL_10
    //         % SFE_TRI_15
    //         % SFE_TRI_GL_15
    //         % SFE_TRI_FEK_15
    //         % SFE_TRI_21
    //         % SFE_TRI_GL_21
    //         % SFE_TRI_FEK_21
    //         % SFE_TRI_28
    //         % SFE_TRI_GL_28
    //         % SFE_TRI_FEK_28
    //         % SFE_QUAD_GL_4
    //         % SFE_QUAD_GL_9
    //         % SFE_QUAD_16
    //         % SFE_QUAD_GL_16
    //         % SFE_QUAD_25
    //         % SFE_QUAD_GL_25
    //         % SFE_QUAD_36
    //         % SFE_QUAD_GL_36
    //         % SFE_QUAD_49
    //         % SFE_QUAD_GL_49
    //         % SFE_TET_GL_4
    //         % SFE_TET_GL_10
    //         % SFE_TET_20
    //         % SFE_TET_GL_20
    //         % SFE_TET_35
    //         % SFE_TET_GL_35
    //         % SFE_TET_FEK_35
    //         % SFE_TET_56
    //         % SFE_TET_GL_56
    //         % SFE_TET_FEK_56
    //         % SFE_TET_84
    //         % SFE_TET_GL_84
    //         % SFE_TET_FEK_84
    //         % SFE_PYRA_GL_5
    //         % SFE_PYRA_GL_14
    //         % SFE_PYRA_30
    //         % SFE_PYRA_GL_30
    //         % SFE_PYRA_55
    //         % SFE_PYRA_GL_55
    //         % SFE_PYRA_FEK_55
    //         % SFE_PYRA_91
    //         % SFE_PRISM_GL_6
    //         % SFE_PRISM_GL_18
    //         % SFE_PRISM_40
    //         % SFE_PRISM_GL_40
    //         % SFE_PRISM_75
    //         % SFE_PRISM_GL_75
    //         % SFE_PRISM_FEK_75
    //         % SFE_PRISM_126
    //         % SFE_PRISM_GL_126
    //         % SFE_PRISM_196
    //         % SFE_HEXA_GL_8
    //         % SFE_HEXA_GL_27
    //         % SFE_HEXA_64
    //         % SFE_HEXA_GL_64
    //         % SFE_HEXA_125
    //         % SFE_HEXA_GL_125
    //         % SFE_HEXA_216
    //         % SFE_HEXA_GL_216
    //         % SFE_HEXA_343
    //         % SFE_HEXA_GL_343
    //  Geometric dimension
    //  Topological dimension
    // obtain_elemdim - Obtain the dimension of an element
    //
    //    dim = obtain_elemdim(etype)
    //
    //  See also obtain_elemshape
    // obtain_elemshape - Decode an element geometric shape from etype
    //
    //    shapeid = obtain_elemshape(etype)
    //
    //  RETURN
    //  ------
    //    shapeid:    Integer type of different geometry shapes:
    //                    1 - BAR
    //                    2 - TRI
    //                    3 - QUAD
    //                    4 - TET
    //                    5 - PYRAMID
    //                    6 - PRISM
    //                    7 - HEX
    //
    //  See also obtain_elemdim
    //  shapeid = (etype>>5)&0b111
    shape = etypes[0] >> 5 & 7;
    topo_dim = ((shape > 0) + (shape > 1)) + (shape > 3);
    //  Geometric dimension
    if (xs_size[1] < topo_dim) {
      //  m2cError  Throw error and display message in MATLAB or C++
      //
      //     m2cError(format)
      //     m2cError(format,A1,...,An)
      //     m2cError(errID,___)
      //
      //  This function has the same interface as MATLAB's built-in `error`,
      //  except that the `format` must be a constant string during code
      //  generation.
      //
      //  Notes
      //  -----
      //  The format must be a constant string during code-generation time.
      //
      //  See also error, m2cWarning
      m2cErrMsgIdAndTxt("sfe_init:badDim",
                        "geometric dim cannot be smaller than topo dim");
    }
    b_sfe->geom_dim = xs_size[1];
    //  assign geom dimension
    b_sfe->topo_dim = topo_dim;
    //  assign topo dimension
    //  Make sure the coordinate size are the same
    // obtain_elemnnodes - Obtain number of nodes per element given etype
    //
    //     nnodes = obtain_elemnnodes(etype)
    //
    //  This file was generated from update_nnodes_table
    //         % SFE_NODE_1
    //         % SFE_BAR_GL_2
    //         % SFE_BAR_GL_3
    //         % SFE_BAR_4
    //         % SFE_BAR_GL_4
    //         % SFE_BAR_5
    //         % SFE_BAR_GL_5
    //         % SFE_BAR_6
    //         % SFE_BAR_GL_6
    //         % SFE_BAR_7
    //         % SFE_BAR_GL_7
    //         % SFE_TRI_GL_3
    //         % SFE_TRI_GL_6
    //         % SFE_TRI_10
    //         % SFE_TRI_GL_10
    //         % SFE_TRI_15
    //         % SFE_TRI_GL_15
    //         % SFE_TRI_FEK_15
    //         % SFE_TRI_21
    //         % SFE_TRI_GL_21
    //         % SFE_TRI_FEK_21
    //         % SFE_TRI_28
    //         % SFE_TRI_GL_28
    //         % SFE_TRI_FEK_28
    //         % SFE_QUAD_GL_4
    //         % SFE_QUAD_GL_9
    //         % SFE_QUAD_16
    //         % SFE_QUAD_GL_16
    //         % SFE_QUAD_25
    //         % SFE_QUAD_GL_25
    //         % SFE_QUAD_36
    //         % SFE_QUAD_GL_36
    //         % SFE_QUAD_49
    //         % SFE_QUAD_GL_49
    //         % SFE_TET_GL_4
    //         % SFE_TET_GL_10
    //         % SFE_TET_20
    //         % SFE_TET_GL_20
    //         % SFE_TET_35
    //         % SFE_TET_GL_35
    //         % SFE_TET_FEK_35
    //         % SFE_TET_56
    //         % SFE_TET_GL_56
    //         % SFE_TET_FEK_56
    //         % SFE_TET_84
    //         % SFE_TET_GL_84
    //         % SFE_TET_FEK_84
    //         % SFE_PYRA_GL_5
    //         % SFE_PYRA_GL_14
    //         % SFE_PYRA_30
    //         % SFE_PYRA_GL_30
    //         % SFE_PYRA_55
    //         % SFE_PYRA_GL_55
    //         % SFE_PYRA_FEK_55
    //         % SFE_PYRA_91
    //         % SFE_PRISM_GL_6
    //         % SFE_PRISM_GL_18
    //         % SFE_PRISM_40
    //         % SFE_PRISM_GL_40
    //         % SFE_PRISM_75
    //         % SFE_PRISM_GL_75
    //         % SFE_PRISM_FEK_75
    //         % SFE_PRISM_126
    //         % SFE_PRISM_GL_126
    //         % SFE_PRISM_196
    //         % SFE_HEXA_GL_8
    //         % SFE_HEXA_GL_27
    //         % SFE_HEXA_64
    //         % SFE_HEXA_GL_64
    //         % SFE_HEXA_125
    //         % SFE_HEXA_GL_125
    //         % SFE_HEXA_216
    //         % SFE_HEXA_GL_216
    //         % SFE_HEXA_343
    //         % SFE_HEXA_GL_343
    //  m2cAssert  Throw error if condition false at runtime
    //
    //    m2cAssert(cond)
    //    m2cAssert(cond,msg)
    //    m2cAssert(cond,msg,A1,...,An)
    //    m2cAssert(cond,errID,msg)
    //    m2cAssert(cond,errID,msg,A1,...,An)
    //
    //  The interface of `m2cAssert` is compatible with MATLAB's built-in
    //  `assert`,  but it generates runtime assertion instead of compile-time
    //  assertion.
    //
    //  Note
    //  ----
    //  The MATLAB built-in `assert` is mostly used for compile-time error
    //  checking, and it has no effect for runtime error checking in LIB mode.
    //  Use `m2cAssert` instead for runtime error checking. Like the built-in
    //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
    //  into a code-generation-time character string. If you want to use both
    //  code-generation-time and runtime assertions, it is recommended to put
    //  `m2cAssert` before the built-in `assert`.
    //
    //  See also assert, m2cError, m2cWarning
    m2cAssert(iv[geom_etype - 1] == xs_size[0], "nnodes do not match");
    b_sfe->etypes[0] = etypes[0];
    b_sfe->etypes[1] = geom_etype;
    //  Get number of nodes per element
    // obtain_elemnnodes - Obtain number of nodes per element given etype
    //
    //     nnodes = obtain_elemnnodes(etype)
    //
    //  This file was generated from update_nnodes_table
    //         % SFE_NODE_1
    //         % SFE_BAR_GL_2
    //         % SFE_BAR_GL_3
    //         % SFE_BAR_4
    //         % SFE_BAR_GL_4
    //         % SFE_BAR_5
    //         % SFE_BAR_GL_5
    //         % SFE_BAR_6
    //         % SFE_BAR_GL_6
    //         % SFE_BAR_7
    //         % SFE_BAR_GL_7
    //         % SFE_TRI_GL_3
    //         % SFE_TRI_GL_6
    //         % SFE_TRI_10
    //         % SFE_TRI_GL_10
    //         % SFE_TRI_15
    //         % SFE_TRI_GL_15
    //         % SFE_TRI_FEK_15
    //         % SFE_TRI_21
    //         % SFE_TRI_GL_21
    //         % SFE_TRI_FEK_21
    //         % SFE_TRI_28
    //         % SFE_TRI_GL_28
    //         % SFE_TRI_FEK_28
    //         % SFE_QUAD_GL_4
    //         % SFE_QUAD_GL_9
    //         % SFE_QUAD_16
    //         % SFE_QUAD_GL_16
    //         % SFE_QUAD_25
    //         % SFE_QUAD_GL_25
    //         % SFE_QUAD_36
    //         % SFE_QUAD_GL_36
    //         % SFE_QUAD_49
    //         % SFE_QUAD_GL_49
    //         % SFE_TET_GL_4
    //         % SFE_TET_GL_10
    //         % SFE_TET_20
    //         % SFE_TET_GL_20
    //         % SFE_TET_35
    //         % SFE_TET_GL_35
    //         % SFE_TET_FEK_35
    //         % SFE_TET_56
    //         % SFE_TET_GL_56
    //         % SFE_TET_FEK_56
    //         % SFE_TET_84
    //         % SFE_TET_GL_84
    //         % SFE_TET_FEK_84
    //         % SFE_PYRA_GL_5
    //         % SFE_PYRA_GL_14
    //         % SFE_PYRA_30
    //         % SFE_PYRA_GL_30
    //         % SFE_PYRA_55
    //         % SFE_PYRA_GL_55
    //         % SFE_PYRA_FEK_55
    //         % SFE_PYRA_91
    //         % SFE_PRISM_GL_6
    //         % SFE_PRISM_GL_18
    //         % SFE_PRISM_40
    //         % SFE_PRISM_GL_40
    //         % SFE_PRISM_75
    //         % SFE_PRISM_GL_75
    //         % SFE_PRISM_FEK_75
    //         % SFE_PRISM_126
    //         % SFE_PRISM_GL_126
    //         % SFE_PRISM_196
    //         % SFE_HEXA_GL_8
    //         % SFE_HEXA_GL_27
    //         % SFE_HEXA_64
    //         % SFE_HEXA_GL_64
    //         % SFE_HEXA_125
    //         % SFE_HEXA_GL_125
    //         % SFE_HEXA_216
    //         % SFE_HEXA_GL_216
    //         % SFE_HEXA_343
    //         % SFE_HEXA_GL_343
    b_sfe->nnodes[0] = iv[etypes[0] - 1];
    // obtain_elemnnodes - Obtain number of nodes per element given etype
    //
    //     nnodes = obtain_elemnnodes(etype)
    //
    //  This file was generated from update_nnodes_table
    //         % SFE_NODE_1
    //         % SFE_BAR_GL_2
    //         % SFE_BAR_GL_3
    //         % SFE_BAR_4
    //         % SFE_BAR_GL_4
    //         % SFE_BAR_5
    //         % SFE_BAR_GL_5
    //         % SFE_BAR_6
    //         % SFE_BAR_GL_6
    //         % SFE_BAR_7
    //         % SFE_BAR_GL_7
    //         % SFE_TRI_GL_3
    //         % SFE_TRI_GL_6
    //         % SFE_TRI_10
    //         % SFE_TRI_GL_10
    //         % SFE_TRI_15
    //         % SFE_TRI_GL_15
    //         % SFE_TRI_FEK_15
    //         % SFE_TRI_21
    //         % SFE_TRI_GL_21
    //         % SFE_TRI_FEK_21
    //         % SFE_TRI_28
    //         % SFE_TRI_GL_28
    //         % SFE_TRI_FEK_28
    //         % SFE_QUAD_GL_4
    //         % SFE_QUAD_GL_9
    //         % SFE_QUAD_16
    //         % SFE_QUAD_GL_16
    //         % SFE_QUAD_25
    //         % SFE_QUAD_GL_25
    //         % SFE_QUAD_36
    //         % SFE_QUAD_GL_36
    //         % SFE_QUAD_49
    //         % SFE_QUAD_GL_49
    //         % SFE_TET_GL_4
    //         % SFE_TET_GL_10
    //         % SFE_TET_20
    //         % SFE_TET_GL_20
    //         % SFE_TET_35
    //         % SFE_TET_GL_35
    //         % SFE_TET_FEK_35
    //         % SFE_TET_56
    //         % SFE_TET_GL_56
    //         % SFE_TET_FEK_56
    //         % SFE_TET_84
    //         % SFE_TET_GL_84
    //         % SFE_TET_FEK_84
    //         % SFE_PYRA_GL_5
    //         % SFE_PYRA_GL_14
    //         % SFE_PYRA_30
    //         % SFE_PYRA_GL_30
    //         % SFE_PYRA_55
    //         % SFE_PYRA_GL_55
    //         % SFE_PYRA_FEK_55
    //         % SFE_PYRA_91
    //         % SFE_PRISM_GL_6
    //         % SFE_PRISM_GL_18
    //         % SFE_PRISM_40
    //         % SFE_PRISM_GL_40
    //         % SFE_PRISM_75
    //         % SFE_PRISM_GL_75
    //         % SFE_PRISM_FEK_75
    //         % SFE_PRISM_126
    //         % SFE_PRISM_GL_126
    //         % SFE_PRISM_196
    //         % SFE_HEXA_GL_8
    //         % SFE_HEXA_GL_27
    //         % SFE_HEXA_64
    //         % SFE_HEXA_GL_64
    //         % SFE_HEXA_125
    //         % SFE_HEXA_GL_125
    //         % SFE_HEXA_216
    //         % SFE_HEXA_GL_216
    //         % SFE_HEXA_343
    //         % SFE_HEXA_GL_343
    b_sfe->nnodes[1] = iv[geom_etype - 1];
    //  User-input natural coordinates
    b_sfe->nqp = qd_or_natcoords.size(0);
    b_sfe->ws.set_size(qd_or_natcoords.size(0));
    loop_ub = qd_or_natcoords.size(0);
    for (i = 0; i < loop_ub; i++) {
      b_sfe->ws[i] = 1.0;
    }
    //  user ones for dummy quad weights
    b_sfe->cs.set_size(qd_or_natcoords.size(0), topo_dim);
    i = qd_or_natcoords.size(0);
    for (int32_T q{0}; q < i; q++) {
      for (int32_T k{0}; k < topo_dim; k++) {
        b_sfe->cs[k + b_sfe->cs.size(1) * q] =
            qd_or_natcoords[k + qd_or_natcoords.size(1) * q];
      }
    }
    //  Solution space shape functions & derivs
    tabulate_shapefuncs(etypes[0], b_sfe->cs, b_sfe->shapes_geom,
                        b_sfe->derivs_geom);
    loop_ub = b_sfe->shapes_geom.size(1) * b_sfe->shapes_geom.size(0);
    b_sfe->shapes_sol.set_size(b_sfe->shapes_geom.size(0),
                               b_sfe->shapes_geom.size(1));
    for (i = 0; i < loop_ub; i++) {
      b_sfe->shapes_sol[i] = b_sfe->shapes_geom[i];
    }
    loop_ub = b_sfe->derivs_geom.size(2) * b_sfe->derivs_geom.size(1) *
              b_sfe->derivs_geom.size(0);
    b_sfe->derivs_sol.set_size(b_sfe->derivs_geom.size(0),
                               b_sfe->derivs_geom.size(1),
                               b_sfe->derivs_geom.size(2));
    for (i = 0; i < loop_ub; i++) {
      b_sfe->derivs_sol[i] = b_sfe->derivs_geom[i];
    }
    //  Geometry space shape functions & derivs
    if (etypes[0] != geom_etype) {
      tabulate_shapefuncs(geom_etype, b_sfe->cs, b_sfe->shapes_geom,
                          b_sfe->derivs_geom);
    }
  } else {
    boolean_T cond;
    if ((b_sfe->etypes[0] > 0) && (iv[b_sfe->etypes[0] - 1] != 0)) {
      // obtain_elemnnodes - Obtain number of nodes per element given etype
      //
      //     nnodes = obtain_elemnnodes(etype)
      //
      //  This file was generated from update_nnodes_table
      //         % SFE_NODE_1
      //         % SFE_BAR_GL_2
      //         % SFE_BAR_GL_3
      //         % SFE_BAR_4
      //         % SFE_BAR_GL_4
      //         % SFE_BAR_5
      //         % SFE_BAR_GL_5
      //         % SFE_BAR_6
      //         % SFE_BAR_GL_6
      //         % SFE_BAR_7
      //         % SFE_BAR_GL_7
      //         % SFE_TRI_GL_3
      //         % SFE_TRI_GL_6
      //         % SFE_TRI_10
      //         % SFE_TRI_GL_10
      //         % SFE_TRI_15
      //         % SFE_TRI_GL_15
      //         % SFE_TRI_FEK_15
      //         % SFE_TRI_21
      //         % SFE_TRI_GL_21
      //         % SFE_TRI_FEK_21
      //         % SFE_TRI_28
      //         % SFE_TRI_GL_28
      //         % SFE_TRI_FEK_28
      //         % SFE_QUAD_GL_4
      //         % SFE_QUAD_GL_9
      //         % SFE_QUAD_16
      //         % SFE_QUAD_GL_16
      //         % SFE_QUAD_25
      //         % SFE_QUAD_GL_25
      //         % SFE_QUAD_36
      //         % SFE_QUAD_GL_36
      //         % SFE_QUAD_49
      //         % SFE_QUAD_GL_49
      //         % SFE_TET_GL_4
      //         % SFE_TET_GL_10
      //         % SFE_TET_20
      //         % SFE_TET_GL_20
      //         % SFE_TET_35
      //         % SFE_TET_GL_35
      //         % SFE_TET_FEK_35
      //         % SFE_TET_56
      //         % SFE_TET_GL_56
      //         % SFE_TET_FEK_56
      //         % SFE_TET_84
      //         % SFE_TET_GL_84
      //         % SFE_TET_FEK_84
      //         % SFE_PYRA_GL_5
      //         % SFE_PYRA_GL_14
      //         % SFE_PYRA_30
      //         % SFE_PYRA_GL_30
      //         % SFE_PYRA_55
      //         % SFE_PYRA_GL_55
      //         % SFE_PYRA_FEK_55
      //         % SFE_PYRA_91
      //         % SFE_PRISM_GL_6
      //         % SFE_PRISM_GL_18
      //         % SFE_PRISM_40
      //         % SFE_PRISM_GL_40
      //         % SFE_PRISM_75
      //         % SFE_PRISM_GL_75
      //         % SFE_PRISM_FEK_75
      //         % SFE_PRISM_126
      //         % SFE_PRISM_GL_126
      //         % SFE_PRISM_196
      //         % SFE_HEXA_GL_8
      //         % SFE_HEXA_GL_27
      //         % SFE_HEXA_64
      //         % SFE_HEXA_GL_64
      //         % SFE_HEXA_125
      //         % SFE_HEXA_GL_125
      //         % SFE_HEXA_216
      //         % SFE_HEXA_GL_216
      //         % SFE_HEXA_343
      //         % SFE_HEXA_GL_343
      cond = true;
    } else {
      cond = false;
    }
    //  m2cAssert  Throw error if condition false at runtime
    //
    //    m2cAssert(cond)
    //    m2cAssert(cond,msg)
    //    m2cAssert(cond,msg,A1,...,An)
    //    m2cAssert(cond,errID,msg)
    //    m2cAssert(cond,errID,msg,A1,...,An)
    //
    //  The interface of `m2cAssert` is compatible with MATLAB's built-in
    //  `assert`,  but it generates runtime assertion instead of compile-time
    //  assertion.
    //
    //  Note
    //  ----
    //  The MATLAB built-in `assert` is mostly used for compile-time error
    //  checking, and it has no effect for runtime error checking in LIB mode.
    //  Use `m2cAssert` instead for runtime error checking. Like the built-in
    //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
    //  into a code-generation-time character string. If you want to use both
    //  code-generation-time and runtime assertions, it is recommended to put
    //  `m2cAssert` before the built-in `assert`.
    //
    //  See also assert, m2cError, m2cWarning
    m2cAssert(cond, "");
  }
  //  potentially skip re-tabulating
  //  Compute phy. coordinates of qpoints
  loop_ub = b_sfe->nqp;
  b_sfe->cs_phy.set_size(loop_ub, xs_size[1]);
  for (int32_T q{0}; q < loop_ub; q++) {
    //  NOTE The following can be optimized efficiently due to the the upper
    //  bound of dimension (i.e., size(xs,2)) is known.
    i = xs_size[1];
    for (int32_T k{0}; k < i; k++) {
      real_T v;
      int32_T m;
      // interpolate_shape - Interpolate f with q-th shape function in the table
      //
      //    v = interpolate_shape(shapes, q, f)
      //    v = interpolate_shape(shapes, q, f, k)
      m = b_sfe->shapes_geom.size(1);
      v = b_sfe->shapes_geom[b_sfe->shapes_geom.size(1) * q] * xs_data[k];
      for (int32_T b_i{2}; b_i <= m; b_i++) {
        v += b_sfe->shapes_geom[(b_i + b_sfe->shapes_geom.size(1) * q) - 1] *
             xs_data[k + xs_size[1] * (b_i - 1)];
      }
      b_sfe->cs_phy[k + b_sfe->cs_phy.size(1) * q] = v;
    }
  }
  //  Compute Jacobian
}

static void sfe_init(SfeObject *b_sfe, const uint8_T etypes[2],
                     const ::coder::array<real_T, 2U> &xs,
                     int32_T qd_or_natcoords)
{
  real_T dv[9];
  real_T v;
  int32_T i;
  int32_T loop_ub;
  int32_T sfe_idx_0_tmp_tmp;
  int32_T topo_dim;
  uint8_T c;
  uint8_T geom_etype;
  boolean_T flag;
  // sfe_init - Initialize/reinitialize an sfe object for non-boundary element
  //
  //    sfe = sfe_init(sfe, etypes, xs)
  //    sfe = sfe_init(sfe, etypes, xs, natcoords)
  //    sfe = sfe_init(sfe, etypes, xs, qd)
  //    sfe = sfe_init(sfe, etypes, xs, qd, userquad)
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An SfeObject instance
  //    etypes:     Element type(s), which can be a 2-vector, scalar, or [].
  //                A 2-vector specifies the solution and geometric element
  //                types, and it supports iso-, sub- and super-parametric
  //                elements. If two element types are equal, then one can use a
  //                scalar. An empty array ([]) instructs the function to reuse
  //                the element type and the tabulation stored in the `sfe`
  //                object (typically from a previous call).
  //    xs:         Physical coordinates of the element, which is defined in
  //                the geometric space
  //    qd:         Quadrature degree, a zero value indicate the use of default
  //                quadrature rules based on the element types. If `-1` is
  //                passed in, then the code will assume user-provided
  //                quadrature rule information
  //    userquad:   This field is only accessed if qd=-1. If provided, then
  //    userquad
  //                must be a nqp-by-(1+dim) array, where the first column
  //                vector is is the quadrature weights while the rest are their
  //                corresponding quadrature points, defined in the reference
  //                element.
  //
  //  In particular, the user can pass in specific natural coordinates on which
  //  we will compute shape functions and derivatives. In this situation, we
  //  will skip the computation of Jacobian.
  //
  //    natcoords:  List of natural coordinates defined by the user
  //
  //  EXAMPLES
  //  --------
  //  The following initializes a linear triangular element
  //
  //    >> sfe = sfe_init(SfeObject(0), SFE_TRI_3, xs);
  //
  //  The following initializes a quadratic tetrahedral element but with linear
  //  geometry
  //
  //    >> etypes = [SFE_TET_10; SFE_TET_4];
  //    >> sfe = sfe_init(SfeObject(0), etypes, xs);
  //
  //  The following initializes a bi-linear quadrilateral element with
  //  user-provided gravity quadrature rule
  //
  //    >> gravrule = [1, 0.5, 0.5];
  //    >> sfe = sfe_init(SfeObject(0), SFE_QUAD_4, xs, int32(-1), gravrule);
  //
  //  See also SfeObject, ElementTypes, sfe_init_grad
  //  For clarity
  //  Determine solution and geometric spaces
  if (etypes[1] == 0) {
    geom_etype = etypes[0];
  } else {
    geom_etype = etypes[1];
  }
  flag = (etypes[0] == geom_etype);
  if (!flag) {
    //  then the shapes must match
    // obtain_elemshape - Decode an element geometric shape from etype
    //
    //    shapeid = obtain_elemshape(etype)
    //
    //  RETURN
    //  ------
    //    shapeid:    Integer type of different geometry shapes:
    //                    1 - BAR
    //                    2 - TRI
    //                    3 - QUAD
    //                    4 - TET
    //                    5 - PYRAMID
    //                    6 - PRISM
    //                    7 - HEX
    //
    //  See also obtain_elemdim
    //  shapeid = (etype>>5)&0b111
    // obtain_elemshape - Decode an element geometric shape from etype
    //
    //    shapeid = obtain_elemshape(etype)
    //
    //  RETURN
    //  ------
    //    shapeid:    Integer type of different geometry shapes:
    //                    1 - BAR
    //                    2 - TRI
    //                    3 - QUAD
    //                    4 - TET
    //                    5 - PYRAMID
    //                    6 - PRISM
    //                    7 - HEX
    //
    //  See also obtain_elemdim
    //  shapeid = (etype>>5)&0b111
    flag = (static_cast<int32_T>(static_cast<uint32_T>(etypes[0]) >> 5) ==
            static_cast<int32_T>(static_cast<uint32_T>(geom_etype) >> 5));
  }
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(flag, "invalid element combinations");
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  //  Geometric dimension
  //  Topological dimension
  // obtain_elemdim - Obtain the dimension of an element
  //
  //    dim = obtain_elemdim(etype)
  //
  //  See also obtain_elemshape
  // obtain_elemshape - Decode an element geometric shape from etype
  //
  //    shapeid = obtain_elemshape(etype)
  //
  //  RETURN
  //  ------
  //    shapeid:    Integer type of different geometry shapes:
  //                    1 - BAR
  //                    2 - TRI
  //                    3 - QUAD
  //                    4 - TET
  //                    5 - PYRAMID
  //                    6 - PRISM
  //                    7 - HEX
  //
  //  See also obtain_elemdim
  //  shapeid = (etype>>5)&0b111
  c = static_cast<uint8_T>(static_cast<uint32_T>(etypes[0]) >> 5);
  topo_dim = ((c > 0) + (c > 1)) + (c > 3);
  //  Geometric dimension
  if (xs.size(1) < topo_dim) {
    //  m2cError  Throw error and display message in MATLAB or C++
    //
    //     m2cError(format)
    //     m2cError(format,A1,...,An)
    //     m2cError(errID,___)
    //
    //  This function has the same interface as MATLAB's built-in `error`,
    //  except that the `format` must be a constant string during code
    //  generation.
    //
    //  Notes
    //  -----
    //  The format must be a constant string during code-generation time.
    //
    //  See also error, m2cWarning
    m2cErrMsgIdAndTxt("sfe_init:badDim",
                      "geometric dim cannot be smaller than topo dim");
  }
  b_sfe->geom_dim = xs.size(1);
  //  assign geom dimension
  b_sfe->topo_dim = topo_dim;
  //  assign topo dimension
  //  Make sure the coordinate size are the same
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(iv[geom_etype - 1] == xs.size(0), "nnodes do not match");
  b_sfe->etypes[0] = etypes[0];
  b_sfe->etypes[1] = geom_etype;
  //  Get number of nodes per element
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  b_sfe->nnodes[0] = iv[etypes[0] - 1];
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  b_sfe->nnodes[1] = iv[geom_etype - 1];
  //  Set up quadrature
  if (qd_or_natcoords != -1) {
    if (qd_or_natcoords == 0) {
      //  trial+test+nonlinear_geom?1:0
      //  NOTE, this might be overkill for gradient
      // obtain_elemdegree - Decode the element degree from etype
      //
      //    deg = obtain_elemdegree(etype)
      //
      //  See also obtain_elemnnodes
      //  deg = (etype>>2)&0b111;
      // obtain_elemdegree - Decode the element degree from etype
      //
      //    deg = obtain_elemdegree(etype)
      //
      //  See also obtain_elemnnodes
      //  deg = (etype>>2)&0b111;
      qd_or_natcoords =
          (((etypes[0] >> 2 & 7) << 1) + ((geom_etype >> 2 & 7) > 1)) +
          (xs.size(1) > topo_dim);
    }
    tabulate_quadratures(static_cast<int32_T>(etypes[0]), qd_or_natcoords,
                         b_sfe->cs, b_sfe->ws);
    b_sfe->nqp = b_sfe->ws.size(0);
  } else {
    //  m2cError  Throw error and display message in MATLAB or C++
    //
    //     m2cError(format)
    //     m2cError(format,A1,...,An)
    //     m2cError(errID,___)
    //
    //  This function has the same interface as MATLAB's built-in `error`,
    //  except that the `format` must be a constant string during code
    //  generation.
    //
    //  Notes
    //  -----
    //  The format must be a constant string during code-generation time.
    //
    //  See also error, m2cWarning
    m2cErrMsgIdAndTxt("sfe_init:missUserQuad", "missing user quadrature data");
    //  m2cError  Throw error and display message in MATLAB or C++
    //
    //     m2cError(format)
    //     m2cError(format,A1,...,An)
    //     m2cError(errID,___)
    //
    //  This function has the same interface as MATLAB's built-in `error`,
    //  except that the `format` must be a constant string during code
    //  generation.
    //
    //  Notes
    //  -----
    //  The format must be a constant string during code-generation time.
    //
    //  See also error, m2cWarning
    m2cErrMsgIdAndTxt("sfe_init:badUserQuadDim",
                      "bad user quadrature data size");
    b_sfe->nqp = 0;
    b_sfe->ws.set_size(0);
    b_sfe->cs.set_size(0, topo_dim);
  }
  //  Solution space shape functions & derivs
  tabulate_shapefuncs(static_cast<int32_T>(etypes[0]), b_sfe->cs,
                      b_sfe->shapes_geom, b_sfe->derivs_geom);
  loop_ub = b_sfe->shapes_geom.size(1) * b_sfe->shapes_geom.size(0);
  b_sfe->shapes_sol.set_size(b_sfe->shapes_geom.size(0),
                             b_sfe->shapes_geom.size(1));
  for (i = 0; i < loop_ub; i++) {
    b_sfe->shapes_sol[i] = b_sfe->shapes_geom[i];
  }
  loop_ub = b_sfe->derivs_geom.size(2) * b_sfe->derivs_geom.size(1) *
            b_sfe->derivs_geom.size(0);
  b_sfe->derivs_sol.set_size(b_sfe->derivs_geom.size(0),
                             b_sfe->derivs_geom.size(1),
                             b_sfe->derivs_geom.size(2));
  for (i = 0; i < loop_ub; i++) {
    b_sfe->derivs_sol[i] = b_sfe->derivs_geom[i];
  }
  //  Geometry space shape functions & derivs
  if (etypes[0] != geom_etype) {
    tabulate_shapefuncs(static_cast<int32_T>(geom_etype), b_sfe->cs,
                        b_sfe->shapes_geom, b_sfe->derivs_geom);
  }
  //  potentially skip re-tabulating
  //  Compute phy. coordinates of qpoints
  sfe_idx_0_tmp_tmp = b_sfe->nqp;
  b_sfe->cs_phy.set_size(sfe_idx_0_tmp_tmp, xs.size(1));
  for (int32_T q{0}; q < sfe_idx_0_tmp_tmp; q++) {
    //  NOTE The following can be optimized efficiently due to the the upper
    //  bound of dimension (i.e., size(xs,2)) is known.
    i = xs.size(1);
    for (int32_T k{0}; k < i; k++) {
      int32_T m;
      // interpolate_shape - Interpolate f with q-th shape function in the table
      //
      //    v = interpolate_shape(shapes, q, f)
      //    v = interpolate_shape(shapes, q, f, k)
      m = b_sfe->shapes_geom.size(1);
      v = b_sfe->shapes_geom[b_sfe->shapes_geom.size(1) * q] * xs[k];
      for (int32_T b_i{2}; b_i <= m; b_i++) {
        v += b_sfe->shapes_geom[(b_i + b_sfe->shapes_geom.size(1) * q) - 1] *
             xs[k + xs.size(1) * (b_i - 1)];
      }
      b_sfe->cs_phy[k + b_sfe->cs_phy.size(1) * q] = v;
    }
  }
  //  Compute Jacobian
  b_sfe->wdetJ.set_size(b_sfe->nqp);
  if ((geom_etype == 68) || (geom_etype == 132) || (geom_etype == 36)) {
    real_T d;
    int32_T geom_dim;
    int32_T n;
    //  A single Jacobian matrix (transpose) is needed for simplex elements
    // compute_jact - Compute Jacobian^T and its determinant from q-th deriv in
    // table
    //
    //    [Jt, d] = compute_jactt(xs, derivs, q)
    //
    //  NOTES
    //  -----
    //  Jt is always shape of 3x3. But only topo_dim-by-geom_dim will be
    //  accessed for computing Jacobian matrix. Note that for 3D surfaces, the
    //  normal direction corresponding to q-th qpiont will be saved to the last
    //  row of J.
    //
    //  In particular, the orientation for the transpose of Jacobian matrix is
    //
    //             [dx/dxi    dy/dxi    dz/dxi  ]
    //        Jt = [dx/deta   dy/deta   dz/deta ]
    //             [dx/dzeta  dy/dzeta  dz/dzeta]
    //
    //  Hence, for surface and curve, Jt has shapes (d-1)xd and 1x3, resp
    //
    //  See also solve_sq
    geom_dim = xs.size(1);
    topo_dim = b_sfe->derivs_geom.size(2);
    std::memset(&dv[0], 0, 9U * sizeof(real_T));
    n = xs.size(0);
    for (int32_T k{0}; k < n; k++) {
      for (int32_T b_i{0}; b_i < topo_dim; b_i++) {
        for (int32_T j{0}; j < geom_dim; j++) {
          i = j + 3 * b_i;
          dv[i] += xs[j + xs.size(1) * k] *
                   b_sfe->derivs_geom[b_i + b_sfe->derivs_geom.size(2) * k];
        }
      }
    }
    if (xs.size(1) == b_sfe->derivs_geom.size(2)) {
      if (xs.size(1) == 1) {
        d = dv[0];
      } else if (xs.size(1) == 2) {
        // det2 - Compute determinant of 2x2 matrix.
        d = dv[0] * dv[4] - dv[1] * dv[3];
      } else {
        // det3 - Compute determinant of 3x3 matrix.
        d = (dv[2] * (dv[3] * dv[7] - dv[4] * dv[6]) +
             dv[5] * (dv[1] * dv[6] - dv[0] * dv[7])) +
            dv[8] * (dv[0] * dv[4] - dv[1] * dv[3]);
      }
    } else if (b_sfe->derivs_geom.size(2) == 1) {
      d = dv[0] * dv[0] + dv[1] * dv[1];
      if (xs.size(1) == 3) {
        d += dv[2] * dv[2];
      }
      d = std::sqrt(d);
    } else {
      //  must be 2x3
      // cross_lastcol - Compute cross(J(1,:),J(2,:)) and store to J(3,:)
      dv[6] = dv[1] * dv[5] - dv[2] * dv[4];
      dv[7] = dv[2] * dv[3] - dv[0] * dv[5];
      dv[8] = dv[0] * dv[4] - dv[1] * dv[3];
      d = std::sqrt((dv[6] * dv[6] + dv[7] * dv[7]) + dv[8] * dv[8]);
    }
    b_sfe->jacTs.set_size(3, 3);
    for (i = 0; i < 9; i++) {
      b_sfe->jacTs[i] = dv[i];
    }
    for (int32_T q{0}; q < sfe_idx_0_tmp_tmp; q++) {
      b_sfe->wdetJ[q] = d * b_sfe->ws[q];
    }
  } else {
    //  Super-parametric
    loop_ub = b_sfe->nqp * 3;
    b_sfe->jacTs.set_size(loop_ub, 3);
    for (int32_T q{0}; q < sfe_idx_0_tmp_tmp; q++) {
      int32_T geom_dim;
      int32_T n;
      int32_T y;
      y = q * 3;
      // compute_jact - Compute Jacobian^T and its determinant from q-th deriv
      // in table
      //
      //    [Jt, d] = compute_jactt(xs, derivs, q)
      //
      //  NOTES
      //  -----
      //  Jt is always shape of 3x3. But only topo_dim-by-geom_dim will be
      //  accessed for computing Jacobian matrix. Note that for 3D surfaces, the
      //  normal direction corresponding to q-th qpiont will be saved to the
      //  last row of J.
      //
      //  In particular, the orientation for the transpose of Jacobian matrix is
      //
      //             [dx/dxi    dy/dxi    dz/dxi  ]
      //        Jt = [dx/deta   dy/deta   dz/deta ]
      //             [dx/dzeta  dy/dzeta  dz/dzeta]
      //
      //  Hence, for surface and curve, Jt has shapes (d-1)xd and 1x3, resp
      //
      //  See also solve_sq
      geom_dim = xs.size(1);
      topo_dim = b_sfe->derivs_geom.size(2);
      std::memset(&dv[0], 0, 9U * sizeof(real_T));
      n = xs.size(0);
      for (int32_T k{0}; k < n; k++) {
        for (int32_T b_i{0}; b_i < topo_dim; b_i++) {
          for (int32_T j{0}; j < geom_dim; j++) {
            i = j + 3 * b_i;
            dv[i] += xs[j + xs.size(1) * k] *
                     b_sfe->derivs_geom[(b_i + b_sfe->derivs_geom.size(2) * k) +
                                        b_sfe->derivs_geom.size(2) *
                                            b_sfe->derivs_geom.size(1) * q];
          }
        }
      }
      if (xs.size(1) == b_sfe->derivs_geom.size(2)) {
        if (xs.size(1) == 1) {
          v = dv[0];
        } else if (xs.size(1) == 2) {
          // det2 - Compute determinant of 2x2 matrix.
          v = dv[0] * dv[4] - dv[1] * dv[3];
        } else {
          // det3 - Compute determinant of 3x3 matrix.
          v = (dv[2] * (dv[3] * dv[7] - dv[4] * dv[6]) +
               dv[5] * (dv[1] * dv[6] - dv[0] * dv[7])) +
              dv[8] * (dv[0] * dv[4] - dv[1] * dv[3]);
        }
      } else if (b_sfe->derivs_geom.size(2) == 1) {
        v = dv[0] * dv[0] + dv[1] * dv[1];
        if (xs.size(1) == 3) {
          v += dv[2] * dv[2];
        }
        v = std::sqrt(v);
      } else {
        //  must be 2x3
        // cross_lastcol - Compute cross(J(1,:),J(2,:)) and store to J(3,:)
        dv[6] = dv[1] * dv[5] - dv[2] * dv[4];
        dv[7] = dv[2] * dv[3] - dv[0] * dv[5];
        dv[8] = dv[0] * dv[4] - dv[1] * dv[3];
        v = std::sqrt((dv[6] * dv[6] + dv[7] * dv[7]) + dv[8] * dv[8]);
      }
      for (i = 0; i < 3; i++) {
        loop_ub = i + y;
        b_sfe->jacTs[3 * loop_ub] = dv[3 * i];
        b_sfe->jacTs[3 * loop_ub + 1] = dv[3 * i + 1];
        b_sfe->jacTs[3 * loop_ub + 2] = dv[3 * i + 2];
      }
      b_sfe->wdetJ[q] = v;
      b_sfe->wdetJ[q] = b_sfe->wdetJ[q] * b_sfe->ws[q];
    }
  }
}

static void sfe_init(SfeObject *b_sfe, const uint8_T etypes[2],
                     const ::coder::array<real_T, 2U> &xs,
                     int32_T qd_or_natcoords,
                     const ::coder::array<real_T, 2U> &userquad)
{
  real_T dv[9];
  real_T v;
  int32_T i;
  int32_T loop_ub;
  int32_T sfe_idx_0_tmp_tmp;
  int32_T topo_dim;
  uint8_T c;
  uint8_T geom_etype;
  boolean_T flag;
  // sfe_init - Initialize/reinitialize an sfe object for non-boundary element
  //
  //    sfe = sfe_init(sfe, etypes, xs)
  //    sfe = sfe_init(sfe, etypes, xs, natcoords)
  //    sfe = sfe_init(sfe, etypes, xs, qd)
  //    sfe = sfe_init(sfe, etypes, xs, qd, userquad)
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An SfeObject instance
  //    etypes:     Element type(s), which can be a 2-vector, scalar, or [].
  //                A 2-vector specifies the solution and geometric element
  //                types, and it supports iso-, sub- and super-parametric
  //                elements. If two element types are equal, then one can use a
  //                scalar. An empty array ([]) instructs the function to reuse
  //                the element type and the tabulation stored in the `sfe`
  //                object (typically from a previous call).
  //    xs:         Physical coordinates of the element, which is defined in
  //                the geometric space
  //    qd:         Quadrature degree, a zero value indicate the use of default
  //                quadrature rules based on the element types. If `-1` is
  //                passed in, then the code will assume user-provided
  //                quadrature rule information
  //    userquad:   This field is only accessed if qd=-1. If provided, then
  //    userquad
  //                must be a nqp-by-(1+dim) array, where the first column
  //                vector is is the quadrature weights while the rest are their
  //                corresponding quadrature points, defined in the reference
  //                element.
  //
  //  In particular, the user can pass in specific natural coordinates on which
  //  we will compute shape functions and derivatives. In this situation, we
  //  will skip the computation of Jacobian.
  //
  //    natcoords:  List of natural coordinates defined by the user
  //
  //  EXAMPLES
  //  --------
  //  The following initializes a linear triangular element
  //
  //    >> sfe = sfe_init(SfeObject(0), SFE_TRI_3, xs);
  //
  //  The following initializes a quadratic tetrahedral element but with linear
  //  geometry
  //
  //    >> etypes = [SFE_TET_10; SFE_TET_4];
  //    >> sfe = sfe_init(SfeObject(0), etypes, xs);
  //
  //  The following initializes a bi-linear quadrilateral element with
  //  user-provided gravity quadrature rule
  //
  //    >> gravrule = [1, 0.5, 0.5];
  //    >> sfe = sfe_init(SfeObject(0), SFE_QUAD_4, xs, int32(-1), gravrule);
  //
  //  See also SfeObject, ElementTypes, sfe_init_grad
  //  For clarity
  //  Determine solution and geometric spaces
  if (etypes[1] == 0) {
    geom_etype = etypes[0];
  } else {
    geom_etype = etypes[1];
  }
  flag = (etypes[0] == geom_etype);
  if (!flag) {
    //  then the shapes must match
    // obtain_elemshape - Decode an element geometric shape from etype
    //
    //    shapeid = obtain_elemshape(etype)
    //
    //  RETURN
    //  ------
    //    shapeid:    Integer type of different geometry shapes:
    //                    1 - BAR
    //                    2 - TRI
    //                    3 - QUAD
    //                    4 - TET
    //                    5 - PYRAMID
    //                    6 - PRISM
    //                    7 - HEX
    //
    //  See also obtain_elemdim
    //  shapeid = (etype>>5)&0b111
    // obtain_elemshape - Decode an element geometric shape from etype
    //
    //    shapeid = obtain_elemshape(etype)
    //
    //  RETURN
    //  ------
    //    shapeid:    Integer type of different geometry shapes:
    //                    1 - BAR
    //                    2 - TRI
    //                    3 - QUAD
    //                    4 - TET
    //                    5 - PYRAMID
    //                    6 - PRISM
    //                    7 - HEX
    //
    //  See also obtain_elemdim
    //  shapeid = (etype>>5)&0b111
    flag = (static_cast<int32_T>(static_cast<uint32_T>(etypes[0]) >> 5) ==
            static_cast<int32_T>(static_cast<uint32_T>(geom_etype) >> 5));
  }
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(flag, "invalid element combinations");
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  //  Geometric dimension
  //  Topological dimension
  // obtain_elemdim - Obtain the dimension of an element
  //
  //    dim = obtain_elemdim(etype)
  //
  //  See also obtain_elemshape
  // obtain_elemshape - Decode an element geometric shape from etype
  //
  //    shapeid = obtain_elemshape(etype)
  //
  //  RETURN
  //  ------
  //    shapeid:    Integer type of different geometry shapes:
  //                    1 - BAR
  //                    2 - TRI
  //                    3 - QUAD
  //                    4 - TET
  //                    5 - PYRAMID
  //                    6 - PRISM
  //                    7 - HEX
  //
  //  See also obtain_elemdim
  //  shapeid = (etype>>5)&0b111
  c = static_cast<uint8_T>(static_cast<uint32_T>(etypes[0]) >> 5);
  topo_dim = ((c > 0) + (c > 1)) + (c > 3);
  //  Geometric dimension
  if (xs.size(1) < topo_dim) {
    //  m2cError  Throw error and display message in MATLAB or C++
    //
    //     m2cError(format)
    //     m2cError(format,A1,...,An)
    //     m2cError(errID,___)
    //
    //  This function has the same interface as MATLAB's built-in `error`,
    //  except that the `format` must be a constant string during code
    //  generation.
    //
    //  Notes
    //  -----
    //  The format must be a constant string during code-generation time.
    //
    //  See also error, m2cWarning
    m2cErrMsgIdAndTxt("sfe_init:badDim",
                      "geometric dim cannot be smaller than topo dim");
  }
  b_sfe->geom_dim = xs.size(1);
  //  assign geom dimension
  b_sfe->topo_dim = topo_dim;
  //  assign topo dimension
  //  Make sure the coordinate size are the same
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(iv[geom_etype - 1] == xs.size(0), "nnodes do not match");
  b_sfe->etypes[0] = etypes[0];
  b_sfe->etypes[1] = geom_etype;
  //  Get number of nodes per element
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  b_sfe->nnodes[0] = iv[etypes[0] - 1];
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  b_sfe->nnodes[1] = iv[geom_etype - 1];
  //  Set up quadrature
  if (qd_or_natcoords != -1) {
    if (qd_or_natcoords == 0) {
      //  trial+test+nonlinear_geom?1:0
      //  NOTE, this might be overkill for gradient
      // obtain_elemdegree - Decode the element degree from etype
      //
      //    deg = obtain_elemdegree(etype)
      //
      //  See also obtain_elemnnodes
      //  deg = (etype>>2)&0b111;
      // obtain_elemdegree - Decode the element degree from etype
      //
      //    deg = obtain_elemdegree(etype)
      //
      //  See also obtain_elemnnodes
      //  deg = (etype>>2)&0b111;
      qd_or_natcoords =
          (((etypes[0] >> 2 & 7) << 1) + ((geom_etype >> 2 & 7) > 1)) +
          (xs.size(1) > topo_dim);
    }
    tabulate_quadratures(static_cast<int32_T>(etypes[0]), qd_or_natcoords,
                         b_sfe->cs, b_sfe->ws);
    b_sfe->nqp = b_sfe->ws.size(0);
  } else {
    if ((userquad.size(0) == 0) || (userquad.size(1) == 0)) {
      //  m2cError  Throw error and display message in MATLAB or C++
      //
      //     m2cError(format)
      //     m2cError(format,A1,...,An)
      //     m2cError(errID,___)
      //
      //  This function has the same interface as MATLAB's built-in `error`,
      //  except that the `format` must be a constant string during code
      //  generation.
      //
      //  Notes
      //  -----
      //  The format must be a constant string during code-generation time.
      //
      //  See also error, m2cWarning
      m2cErrMsgIdAndTxt("sfe_init:missUserQuad",
                        "missing user quadrature data");
    }
    if (userquad.size(1) != topo_dim + 1) {
      //  m2cError  Throw error and display message in MATLAB or C++
      //
      //     m2cError(format)
      //     m2cError(format,A1,...,An)
      //     m2cError(errID,___)
      //
      //  This function has the same interface as MATLAB's built-in `error`,
      //  except that the `format` must be a constant string during code
      //  generation.
      //
      //  Notes
      //  -----
      //  The format must be a constant string during code-generation time.
      //
      //  See also error, m2cWarning
      m2cErrMsgIdAndTxt("sfe_init:badUserQuadDim",
                        "bad user quadrature data size");
    }
    b_sfe->nqp = userquad.size(0);
    b_sfe->ws.set_size(userquad.size(0));
    b_sfe->cs.set_size(userquad.size(0), topo_dim);
    i = userquad.size(0);
    for (int32_T q{0}; q < i; q++) {
      b_sfe->ws[q] = userquad[userquad.size(1) * q];
      for (int32_T k{0}; k < topo_dim; k++) {
        b_sfe->cs[k + b_sfe->cs.size(1) * q] =
            userquad[(k + userquad.size(1) * q) + 1];
      }
    }
  }
  //  Solution space shape functions & derivs
  tabulate_shapefuncs(static_cast<int32_T>(etypes[0]), b_sfe->cs,
                      b_sfe->shapes_geom, b_sfe->derivs_geom);
  loop_ub = b_sfe->shapes_geom.size(1) * b_sfe->shapes_geom.size(0);
  b_sfe->shapes_sol.set_size(b_sfe->shapes_geom.size(0),
                             b_sfe->shapes_geom.size(1));
  for (i = 0; i < loop_ub; i++) {
    b_sfe->shapes_sol[i] = b_sfe->shapes_geom[i];
  }
  loop_ub = b_sfe->derivs_geom.size(2) * b_sfe->derivs_geom.size(1) *
            b_sfe->derivs_geom.size(0);
  b_sfe->derivs_sol.set_size(b_sfe->derivs_geom.size(0),
                             b_sfe->derivs_geom.size(1),
                             b_sfe->derivs_geom.size(2));
  for (i = 0; i < loop_ub; i++) {
    b_sfe->derivs_sol[i] = b_sfe->derivs_geom[i];
  }
  //  Geometry space shape functions & derivs
  if (etypes[0] != geom_etype) {
    tabulate_shapefuncs(static_cast<int32_T>(geom_etype), b_sfe->cs,
                        b_sfe->shapes_geom, b_sfe->derivs_geom);
  }
  //  potentially skip re-tabulating
  //  Compute phy. coordinates of qpoints
  sfe_idx_0_tmp_tmp = b_sfe->nqp;
  b_sfe->cs_phy.set_size(sfe_idx_0_tmp_tmp, xs.size(1));
  for (int32_T q{0}; q < sfe_idx_0_tmp_tmp; q++) {
    //  NOTE The following can be optimized efficiently due to the the upper
    //  bound of dimension (i.e., size(xs,2)) is known.
    i = xs.size(1);
    for (int32_T k{0}; k < i; k++) {
      int32_T m;
      // interpolate_shape - Interpolate f with q-th shape function in the table
      //
      //    v = interpolate_shape(shapes, q, f)
      //    v = interpolate_shape(shapes, q, f, k)
      m = b_sfe->shapes_geom.size(1);
      v = b_sfe->shapes_geom[b_sfe->shapes_geom.size(1) * q] * xs[k];
      for (int32_T b_i{2}; b_i <= m; b_i++) {
        v += b_sfe->shapes_geom[(b_i + b_sfe->shapes_geom.size(1) * q) - 1] *
             xs[k + xs.size(1) * (b_i - 1)];
      }
      b_sfe->cs_phy[k + b_sfe->cs_phy.size(1) * q] = v;
    }
  }
  //  Compute Jacobian
  b_sfe->wdetJ.set_size(b_sfe->nqp);
  if ((geom_etype == 68) || (geom_etype == 132) || (geom_etype == 36)) {
    real_T d;
    int32_T geom_dim;
    int32_T n;
    //  A single Jacobian matrix (transpose) is needed for simplex elements
    // compute_jact - Compute Jacobian^T and its determinant from q-th deriv in
    // table
    //
    //    [Jt, d] = compute_jactt(xs, derivs, q)
    //
    //  NOTES
    //  -----
    //  Jt is always shape of 3x3. But only topo_dim-by-geom_dim will be
    //  accessed for computing Jacobian matrix. Note that for 3D surfaces, the
    //  normal direction corresponding to q-th qpiont will be saved to the last
    //  row of J.
    //
    //  In particular, the orientation for the transpose of Jacobian matrix is
    //
    //             [dx/dxi    dy/dxi    dz/dxi  ]
    //        Jt = [dx/deta   dy/deta   dz/deta ]
    //             [dx/dzeta  dy/dzeta  dz/dzeta]
    //
    //  Hence, for surface and curve, Jt has shapes (d-1)xd and 1x3, resp
    //
    //  See also solve_sq
    geom_dim = xs.size(1);
    topo_dim = b_sfe->derivs_geom.size(2);
    std::memset(&dv[0], 0, 9U * sizeof(real_T));
    n = xs.size(0);
    for (int32_T k{0}; k < n; k++) {
      for (int32_T b_i{0}; b_i < topo_dim; b_i++) {
        for (int32_T j{0}; j < geom_dim; j++) {
          i = j + 3 * b_i;
          dv[i] += xs[j + xs.size(1) * k] *
                   b_sfe->derivs_geom[b_i + b_sfe->derivs_geom.size(2) * k];
        }
      }
    }
    if (xs.size(1) == b_sfe->derivs_geom.size(2)) {
      if (xs.size(1) == 1) {
        d = dv[0];
      } else if (xs.size(1) == 2) {
        // det2 - Compute determinant of 2x2 matrix.
        d = dv[0] * dv[4] - dv[1] * dv[3];
      } else {
        // det3 - Compute determinant of 3x3 matrix.
        d = (dv[2] * (dv[3] * dv[7] - dv[4] * dv[6]) +
             dv[5] * (dv[1] * dv[6] - dv[0] * dv[7])) +
            dv[8] * (dv[0] * dv[4] - dv[1] * dv[3]);
      }
    } else if (b_sfe->derivs_geom.size(2) == 1) {
      d = dv[0] * dv[0] + dv[1] * dv[1];
      if (xs.size(1) == 3) {
        d += dv[2] * dv[2];
      }
      d = std::sqrt(d);
    } else {
      //  must be 2x3
      // cross_lastcol - Compute cross(J(1,:),J(2,:)) and store to J(3,:)
      dv[6] = dv[1] * dv[5] - dv[2] * dv[4];
      dv[7] = dv[2] * dv[3] - dv[0] * dv[5];
      dv[8] = dv[0] * dv[4] - dv[1] * dv[3];
      d = std::sqrt((dv[6] * dv[6] + dv[7] * dv[7]) + dv[8] * dv[8]);
    }
    b_sfe->jacTs.set_size(3, 3);
    for (i = 0; i < 9; i++) {
      b_sfe->jacTs[i] = dv[i];
    }
    for (int32_T q{0}; q < sfe_idx_0_tmp_tmp; q++) {
      b_sfe->wdetJ[q] = d * b_sfe->ws[q];
    }
  } else {
    //  Super-parametric
    loop_ub = b_sfe->nqp * 3;
    b_sfe->jacTs.set_size(loop_ub, 3);
    for (int32_T q{0}; q < sfe_idx_0_tmp_tmp; q++) {
      int32_T geom_dim;
      int32_T n;
      int32_T y;
      y = q * 3;
      // compute_jact - Compute Jacobian^T and its determinant from q-th deriv
      // in table
      //
      //    [Jt, d] = compute_jactt(xs, derivs, q)
      //
      //  NOTES
      //  -----
      //  Jt is always shape of 3x3. But only topo_dim-by-geom_dim will be
      //  accessed for computing Jacobian matrix. Note that for 3D surfaces, the
      //  normal direction corresponding to q-th qpiont will be saved to the
      //  last row of J.
      //
      //  In particular, the orientation for the transpose of Jacobian matrix is
      //
      //             [dx/dxi    dy/dxi    dz/dxi  ]
      //        Jt = [dx/deta   dy/deta   dz/deta ]
      //             [dx/dzeta  dy/dzeta  dz/dzeta]
      //
      //  Hence, for surface and curve, Jt has shapes (d-1)xd and 1x3, resp
      //
      //  See also solve_sq
      geom_dim = xs.size(1);
      topo_dim = b_sfe->derivs_geom.size(2);
      std::memset(&dv[0], 0, 9U * sizeof(real_T));
      n = xs.size(0);
      for (int32_T k{0}; k < n; k++) {
        for (int32_T b_i{0}; b_i < topo_dim; b_i++) {
          for (int32_T j{0}; j < geom_dim; j++) {
            i = j + 3 * b_i;
            dv[i] += xs[j + xs.size(1) * k] *
                     b_sfe->derivs_geom[(b_i + b_sfe->derivs_geom.size(2) * k) +
                                        b_sfe->derivs_geom.size(2) *
                                            b_sfe->derivs_geom.size(1) * q];
          }
        }
      }
      if (xs.size(1) == b_sfe->derivs_geom.size(2)) {
        if (xs.size(1) == 1) {
          v = dv[0];
        } else if (xs.size(1) == 2) {
          // det2 - Compute determinant of 2x2 matrix.
          v = dv[0] * dv[4] - dv[1] * dv[3];
        } else {
          // det3 - Compute determinant of 3x3 matrix.
          v = (dv[2] * (dv[3] * dv[7] - dv[4] * dv[6]) +
               dv[5] * (dv[1] * dv[6] - dv[0] * dv[7])) +
              dv[8] * (dv[0] * dv[4] - dv[1] * dv[3]);
        }
      } else if (b_sfe->derivs_geom.size(2) == 1) {
        v = dv[0] * dv[0] + dv[1] * dv[1];
        if (xs.size(1) == 3) {
          v += dv[2] * dv[2];
        }
        v = std::sqrt(v);
      } else {
        //  must be 2x3
        // cross_lastcol - Compute cross(J(1,:),J(2,:)) and store to J(3,:)
        dv[6] = dv[1] * dv[5] - dv[2] * dv[4];
        dv[7] = dv[2] * dv[3] - dv[0] * dv[5];
        dv[8] = dv[0] * dv[4] - dv[1] * dv[3];
        v = std::sqrt((dv[6] * dv[6] + dv[7] * dv[7]) + dv[8] * dv[8]);
      }
      for (i = 0; i < 3; i++) {
        loop_ub = i + y;
        b_sfe->jacTs[3 * loop_ub] = dv[3 * i];
        b_sfe->jacTs[3 * loop_ub + 1] = dv[3 * i + 1];
        b_sfe->jacTs[3 * loop_ub + 2] = dv[3 * i + 2];
      }
      b_sfe->wdetJ[q] = v;
      b_sfe->wdetJ[q] = b_sfe->wdetJ[q] * b_sfe->ws[q];
    }
  }
}

static void sfe_init_grad(SfeObject *b_sfe, int32_T q)
{
  real_T Jt[9];
  int32_T dim;
  int32_T n;
  // sfe_grad - Compute gradients of shape functions in physical space
  //
  //    sfe = sfe_init_grad(sfe, q)
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An SfeObject instance
  //    q:          Quadrature point index
  //
  //  See also SfeObject, sfe_init, sfe_elem_stiff
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(b_sfe->geom_dim == b_sfe->topo_dim, "not implemented");
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(q <= b_sfe->nqp, "out of bound of qpoint range");
  if (b_sfe->jacTs.size(0) == 3) {
    for (int32_T i{0}; i < 3; i++) {
      Jt[3 * i] = b_sfe->jacTs[3 * i];
      Jt[3 * i + 1] = b_sfe->jacTs[3 * i + 1];
      Jt[3 * i + 2] = b_sfe->jacTs[3 * i + 2];
    }
  } else {
    int32_T y;
    y = (q - 1) * 3;
    for (int32_T i{0}; i < 3; i++) {
      int32_T Jt_tmp;
      Jt_tmp = i + y;
      Jt[3 * i] = b_sfe->jacTs[3 * Jt_tmp];
      Jt[3 * i + 1] = b_sfe->jacTs[3 * Jt_tmp + 1];
      Jt[3 * i + 2] = b_sfe->jacTs[3 * Jt_tmp + 2];
    }
  }
  dim = b_sfe->derivs_sol.size(2);
  n = b_sfe->derivs_sol.size(1);
  b_sfe->grads_sol.set_size(b_sfe->derivs_sol.size(1),
                            b_sfe->derivs_sol.size(2));
  for (int32_T b_i{0}; b_i < n; b_i++) {
    for (int32_T d{0}; d < dim; d++) {
      b_sfe->grads_sol[d + b_sfe->grads_sol.size(1) * b_i] =
          b_sfe->derivs_sol[(d + b_sfe->derivs_sol.size(2) * b_i) +
                            b_sfe->derivs_sol.size(2) *
                                b_sfe->derivs_sol.size(1) * (q - 1)];
    }
  }
  if (b_sfe->geom_dim == b_sfe->topo_dim) {
    boolean_T info;
    info = solve_sq(Jt, b_sfe->geom_dim, b_sfe->grads_sol);
    //  m2cAssert  Throw error if condition false at runtime
    //
    //    m2cAssert(cond)
    //    m2cAssert(cond,msg)
    //    m2cAssert(cond,msg,A1,...,An)
    //    m2cAssert(cond,errID,msg)
    //    m2cAssert(cond,errID,msg,A1,...,An)
    //
    //  The interface of `m2cAssert` is compatible with MATLAB's built-in
    //  `assert`,  but it generates runtime assertion instead of compile-time
    //  assertion.
    //
    //  Note
    //  ----
    //  The MATLAB built-in `assert` is mostly used for compile-time error
    //  checking, and it has no effect for runtime error checking in LIB mode.
    //  Use `m2cAssert` instead for runtime error checking. Like the built-in
    //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
    //  into a code-generation-time character string. If you want to use both
    //  code-generation-time and runtime assertions, it is recommended to put
    //  `m2cAssert` before the built-in `assert`.
    //
    //  See also assert, m2cError, m2cWarning
    m2cAssert(!info, "singular Jacobian");
  }
}

static boolean_T solve_sq(real_T J[9], int32_T n,
                          ::coder::array<real_T, 2U> &b1)
{
  int32_T m1;
  boolean_T info;
  // solve_local - Solve local 1x1, 2x2, or 3x3 systems
  //
  //    [J, info, b] = solve_sq(J, n, b)
  //    [J, info, b1, b2] = solve_sq(J, n, b1, b2)
  //    [J, info, b1, b2, b3] = solve_sq(J, n, b1, b2, b3)
  //
  //  PARAMETERS
  //  ----------
  //    J:          A 3x3 matrix
  //    n:          Leading dimension of `J`, where we apply solve
  //    b1,b2,b3:   Right-hand of n-by-ndim, which are for derivatives. Each row
  //                corresponds to the derivatives of a quadrature point. On
  //                output, each row will be overwritten by corresponding
  //                gradients.
  //
  //  NOTES
  //  -----
  //  This function is designed for `sfelib`, where bs is nx{1,2,3}, which are
  //  the gradients. In addition, this function solves for all gradients in one
  //  call to avoid the overhead of factorization the tiny system `J`.
  //
  //  In `sfelib`, J is always 3x3, thus we need the second input argument
  //  to specify the actual dimension of the matrix, e.g., n=2 means J(1:2,1:2)
  //  will be factorized. Note that `n` must he the column size of b?.
  //
  //  Algebraically speaking, this function applies x=(J\b')';
  m1 = b1.size(0) - 1;
  info = false;
  if (n == 1) {
    if (J[0] == 0.0) {
      info = true;
    } else {
      real_T ji;
      ji = 1.0 / J[0];
      for (int32_T i{0}; i <= m1; i++) {
        b1[b1.size(1) * i] = b1[b1.size(1) * i] * ji;
      }
    }
  } else {
    real_T pivot;
    real_T t;
    boolean_T guard1{false};
    boolean_T guard2{false};
    boolean_T guard3{false};
    guard1 = false;
    guard2 = false;
    guard3 = false;
    if (n == 2) {
      if (std::abs(J[0]) >= std::abs(J[3])) {
        pivot = J[0];
        if (J[0] == 0.0) {
          info = true;
        } else {
          guard2 = true;
        }
      } else {
        pivot = J[3];
        t = J[3];
        J[3] = J[0];
        J[0] = t;
        t = J[4];
        J[4] = J[1];
        J[1] = t;
        for (int32_T i{0}; i <= m1; i++) {
          t = b1[b1.size(1) * i + 1];
          b1[b1.size(1) * i + 1] = b1[b1.size(1) * i];
          b1[b1.size(1) * i] = t;
        }
        guard2 = true;
      }
    } else {
      real_T d;
      real_T d1;
      //  3x3
      d = std::abs(J[0]);
      d1 = std::abs(J[3]);
      if ((d >= d1) && (d >= std::abs(J[6]))) {
        pivot = J[0];
        if (J[0] == 0.0) {
          info = true;
        } else {
          guard3 = true;
        }
      } else if (d1 >= std::abs(J[6])) {
        pivot = J[3];
        if (J[3] == 0.0) {
          info = true;
        } else {
          t = J[3];
          J[3] = J[0];
          J[0] = t;
          t = J[4];
          J[4] = J[1];
          J[1] = t;
          t = J[5];
          J[5] = J[2];
          J[2] = t;
          for (int32_T i{0}; i <= m1; i++) {
            t = b1[b1.size(1) * i + 1];
            b1[b1.size(1) * i + 1] = b1[b1.size(1) * i];
            b1[b1.size(1) * i] = t;
          }
          guard3 = true;
        }
      } else {
        pivot = J[6];
        t = J[6];
        J[6] = J[0];
        J[0] = t;
        t = J[7];
        J[7] = J[1];
        J[1] = t;
        t = J[8];
        J[8] = J[2];
        J[2] = t;
        for (int32_T i{0}; i <= m1; i++) {
          t = b1[b1.size(1) * i + 2];
          b1[b1.size(1) * i + 2] = b1[b1.size(1) * i];
          b1[b1.size(1) * i] = t;
        }
        guard3 = true;
      }
    }
    if (guard3) {
      J[3] /= pivot;
      J[4] -= J[1] * J[3];
      J[5] -= J[2] * J[3];
      J[6] /= pivot;
      J[7] -= J[1] * J[6];
      J[8] -= J[2] * J[6];
      for (int32_T i{0}; i <= m1; i++) {
        b1[b1.size(1) * i + 1] =
            b1[b1.size(1) * i + 1] - J[3] * b1[b1.size(1) * i];
        b1[b1.size(1) * i + 2] =
            b1[b1.size(1) * i + 2] - J[6] * b1[b1.size(1) * i];
      }
      if (std::abs(J[4]) >= std::abs(J[7])) {
        pivot = J[4];
        if (J[4] == 0.0) {
          info = true;
        } else {
          guard1 = true;
        }
      } else {
        pivot = J[7];
        t = J[6];
        J[6] = J[3];
        J[3] = t;
        t = J[7];
        J[7] = J[4];
        J[4] = t;
        t = J[8];
        J[8] = J[5];
        J[5] = t;
        for (int32_T i{0}; i <= m1; i++) {
          t = b1[b1.size(1) * i + 2];
          b1[b1.size(1) * i + 2] = b1[b1.size(1) * i + 1];
          b1[b1.size(1) * i + 1] = t;
        }
        guard1 = true;
      }
    }
    if (guard2) {
      J[3] /= pivot;
      J[4] -= J[1] * J[3];
      if (J[4] == 0.0) {
        info = true;
      } else {
        for (int32_T i{0}; i <= m1; i++) {
          b1[b1.size(1) * i + 1] =
              (b1[b1.size(1) * i + 1] - J[3] * b1[b1.size(1) * i]) / J[4];
          b1[b1.size(1) * i] =
              (b1[b1.size(1) * i] - J[1] * b1[b1.size(1) * i + 1]) / J[0];
        }
      }
    }
    if (guard1) {
      J[7] /= pivot;
      J[8] -= J[5] * J[7];
      if (J[8] == 0.0) {
        info = true;
      } else {
        for (int32_T i{0}; i <= m1; i++) {
          b1[b1.size(1) * i + 2] =
              (b1[b1.size(1) * i + 2] - J[7] * b1[b1.size(1) * i + 1]) / J[8];
          b1[b1.size(1) * i + 1] =
              (b1[b1.size(1) * i + 1] - J[5] * b1[b1.size(1) * i + 2]) / J[4];
          b1[b1.size(1) * i] =
              ((b1[b1.size(1) * i] - J[2] * b1[b1.size(1) * i + 2]) -
               J[1] * b1[b1.size(1) * i + 1]) /
              J[0];
        }
      }
    }
  }
  return info;
}

static void tabulate_quadratures(int32_T etype, int32_T qd,
                                 ::coder::array<real_T, 2U> &cs,
                                 ::coder::array<real_T, 1U> &ws)
{
  int32_T shape;
  // tabulate_quadratures - Tabulate quadrature rule for given element type
  //    [cs, ws] = tabulate_quadratures(etype, qd)
  // obtain_elemshape - Decode an element geometric shape from etype
  //
  //    shapeid = obtain_elemshape(etype)
  //
  //  RETURN
  //  ------
  //    shapeid:    Integer type of different geometry shapes:
  //                    1 - BAR
  //                    2 - TRI
  //                    3 - QUAD
  //                    4 - TET
  //                    5 - PYRAMID
  //                    6 - PRISM
  //                    7 - HEX
  //
  //  See also obtain_elemdim
  //  shapeid = (etype>>5)&0b111
  shape = etype >> 5 & 7;
  switch (shape) {
  case 1:
    bar_quadrules(qd, cs, ws);
    break;
  case 2:
    tri_quadrules(qd, cs, ws);
    break;
  case 3: {
    //  quad_quadrules - Obtain quadrature points and weights of a quadrilateral
    //  element.
    //
    //     [cs, ws] = quad_quadrules
    //     [cs, ws] = quad_quadrules(degree)
    //
    //  Parameters
    //  ----------
    //   degree: the desired degree of quadrature rule. Default is 1.
    //
    //  Returns
    //  -------
    //   cs: the natural coordinates of quadrature points (nqp-by-2)
    //   ws: the weights of quadrature points (nqp-by-1)
    //
    //  Notes
    //  -----
    //  The natural coordinates are between 0 and 1. All rules have positive
    //  weights.
    //
    //  See also bar_quadrules, tri_quadrules, tet_quadrules, prism_quadrules,
    //  hexa_quadrules, pyra_quadrules
    if (qd <= 1) {
      int32_T nqp;
      nqp = ::sfe_qrules::quad_deg1_qrule();
      cs.set_size(nqp, 2);
      ws.set_size(nqp);
      ::sfe_qrules::quad_deg1_qrule(&cs[0], &(ws.data())[0]);
    } else if (qd <= 3) {
      int32_T nqp;
      nqp = ::sfe_qrules::quad_deg3_qrule();
      cs.set_size(nqp, 2);
      ws.set_size(nqp);
      ::sfe_qrules::quad_deg3_qrule(&cs[0], &(ws.data())[0]);
    } else if (qd <= 5) {
      int32_T nqp;
      nqp = ::sfe_qrules::quad_deg5_qrule();
      cs.set_size(nqp, 2);
      ws.set_size(nqp);
      ::sfe_qrules::quad_deg5_qrule(&cs[0], &(ws.data())[0]);
    } else if (qd <= 7) {
      int32_T nqp;
      nqp = ::sfe_qrules::quad_deg7_qrule();
      cs.set_size(nqp, 2);
      ws.set_size(nqp);
      ::sfe_qrules::quad_deg7_qrule(&cs[0], &(ws.data())[0]);
    } else if (qd <= 9) {
      int32_T nqp;
      nqp = ::sfe_qrules::quad_deg9_qrule();
      cs.set_size(nqp, 2);
      ws.set_size(nqp);
      ::sfe_qrules::quad_deg9_qrule(&cs[0], &(ws.data())[0]);
    } else if (qd <= 11) {
      int32_T nqp;
      nqp = ::sfe_qrules::quad_deg11_qrule();
      cs.set_size(nqp, 2);
      ws.set_size(nqp);
      ::sfe_qrules::quad_deg11_qrule(&cs[0], &(ws.data())[0]);
    } else {
      int32_T nqp;
      if (qd > 13) {
        //  m2cWarning  Display warning message
        //
        //     m2cWarning(msg)
        //     m2cWarning(msg,A1,...,An)
        //     m2cWarning(warnID,___)
        //
        //  This function performs similar to MATLAB's built-in `warning` but it
        //  supports code generation in both MEX and LIB mode.
        //
        //  Notes
        //  -----
        //  The format must be a constant string during code-generation time.
        //
        //  See also warning, m2cError, m2cAssert
        m2cWarnMsgIdAndTxt("bar_quadrules:UnsupportedDegree",
                           "Only support up to degree 13");
      }
      nqp = ::sfe_qrules::quad_deg13_qrule();
      cs.set_size(nqp, 2);
      ws.set_size(nqp);
      ::sfe_qrules::quad_deg13_qrule(&cs[0], &(ws.data())[0]);
    }
  } break;
  case 4: {
    //  tet_quadrules - Obtain quadrature points and weights of a tetrahedral
    //  element.
    //
    //     [cs, ws] = tet_quadrules
    //     [cs, ws] = tet_quadrules(degree)
    //
    //  Parameters
    //  ----------
    //   degree: the desired degree of quadrature rule. Default is 1.
    //
    //  Returns
    //  -------
    //   cs: the natural coordinates of quadrature points (nqp-by-3)
    //   ws: the weights of quadrature points (nqp-by-1)
    //
    //  Notes
    //  -----
    //  The natural coordinates are between 0 and 1. All rules have positive
    //  weights.
    //
    //  References
    //  ----------
    //  https://people.sc.fsu.edu/~jburkardt/datasets/quadrature_rules_tet/quadrature_rules_tet.html
    //  https://nines.cs.kuleuven.be/ecf/mtables.html
    //
    //  See also bar_quadrules, tri_quadrules, quad_quadrules, prism_quadrules,
    //  hexa_quadrules, pyra_quadrules
    if (qd <= 1) {
      int32_T nqp;
      nqp = ::sfe_qrules::tet_deg1_qrule();
      cs.set_size(nqp, 3);
      ws.set_size(nqp);
      ::sfe_qrules::tet_deg1_qrule(&cs[0], &(ws.data())[0]);
    } else if (qd <= 2) {
      int32_T nqp;
      nqp = ::sfe_qrules::tet_deg2_qrule();
      cs.set_size(nqp, 3);
      ws.set_size(nqp);
      ::sfe_qrules::tet_deg2_qrule(&cs[0], &(ws.data())[0]);
    } else if (qd <= 3) {
      int32_T nqp;
      nqp = ::sfe_qrules::tet_deg3_qrule();
      cs.set_size(nqp, 3);
      ws.set_size(nqp);
      ::sfe_qrules::tet_deg3_qrule(&cs[0], &(ws.data())[0]);
    } else if (qd <= 5) {
      int32_T nqp;
      nqp = ::sfe_qrules::tet_deg5_qrule();
      cs.set_size(nqp, 3);
      ws.set_size(nqp);
      ::sfe_qrules::tet_deg5_qrule(&cs[0], &(ws.data())[0]);
    } else if (qd <= 6) {
      int32_T nqp;
      nqp = ::sfe_qrules::tet_deg6_qrule();
      cs.set_size(nqp, 3);
      ws.set_size(nqp);
      ::sfe_qrules::tet_deg6_qrule(&cs[0], &(ws.data())[0]);
    } else if (qd <= 7) {
      int32_T nqp;
      nqp = ::sfe_qrules::tet_deg7_qrule();
      cs.set_size(nqp, 3);
      ws.set_size(nqp);
      ::sfe_qrules::tet_deg7_qrule(&cs[0], &(ws.data())[0]);
    } else if (qd <= 9) {
      int32_T nqp;
      //  The degree-8 quadrature rule KEAST9 has negative weights, so we do
      //  not use it. Instead, use degree-9 degenerated prismatic rule instead.
      nqp = ::sfe_qrules::tet_deg9_qrule();
      cs.set_size(nqp, 3);
      ws.set_size(nqp);
      ::sfe_qrules::tet_deg9_qrule(&cs[0], &(ws.data())[0]);
    } else if (qd <= 11) {
      int32_T nqp;
      nqp = ::sfe_qrules::tet_deg11_qrule();
      cs.set_size(nqp, 3);
      ws.set_size(nqp);
      ::sfe_qrules::tet_deg11_qrule(&cs[0], &(ws.data())[0]);
    } else {
      int32_T nqp;
      if (qd > 13) {
        //  m2cWarning  Display warning message
        //
        //     m2cWarning(msg)
        //     m2cWarning(msg,A1,...,An)
        //     m2cWarning(warnID,___)
        //
        //  This function performs similar to MATLAB's built-in `warning` but it
        //  supports code generation in both MEX and LIB mode.
        //
        //  Notes
        //  -----
        //  The format must be a constant string during code-generation time.
        //
        //  See also warning, m2cError, m2cAssert
        m2cWarnMsgIdAndTxt("tet_quadrules:UnsupportedDegree",
                           "Only support up to degree 13");
      }
      nqp = ::sfe_qrules::tet_deg13_qrule();
      cs.set_size(nqp, 3);
      ws.set_size(nqp);
      ::sfe_qrules::tet_deg13_qrule(&cs[0], &(ws.data())[0]);
    }
  } break;
  case 7: {
    //  hexa_quadrules - Obtain quadrature points and weights of a hexahedral
    //  element.
    //
    //     [cs, ws] = hexa_quadrules
    //     [cs, ws] = hexa_quadrules(degree)
    //
    //  Parameters
    //  ----------
    //   degree: the desired degree of quadrature rule. Default is 1.
    //
    //  Returns
    //  -------
    //   cs: the natural coordinates of quadrature points (nqp-by-3)
    //   ws: the weights of quadrature points (nqp-by-1)
    //
    //  Notes
    //  -----
    //  The natural coordinates are between 0 and 1. All rules have positive
    //  weights.
    //
    //  See also bar_quadrules, tri_quadrules, quad_quadrules, tet_quadrules,
    //  prism_quadrules, pyra_quadrules
    if (qd <= 1) {
      int32_T nqp;
      nqp = ::sfe_qrules::hexa_deg1_qrule();
      cs.set_size(nqp, 3);
      ws.set_size(nqp);
      ::sfe_qrules::hexa_deg1_qrule(&cs[0], &(ws.data())[0]);
    } else if (qd <= 3) {
      int32_T nqp;
      nqp = ::sfe_qrules::hexa_deg3_qrule();
      cs.set_size(nqp, 3);
      ws.set_size(nqp);
      ::sfe_qrules::hexa_deg3_qrule(&cs[0], &(ws.data())[0]);
    } else if (qd <= 5) {
      int32_T nqp;
      nqp = ::sfe_qrules::hexa_deg5_qrule();
      cs.set_size(nqp, 3);
      ws.set_size(nqp);
      ::sfe_qrules::hexa_deg5_qrule(&cs[0], &(ws.data())[0]);
    } else if (qd <= 7) {
      int32_T nqp;
      nqp = ::sfe_qrules::hexa_deg7_qrule();
      cs.set_size(nqp, 3);
      ws.set_size(nqp);
      ::sfe_qrules::hexa_deg7_qrule(&cs[0], &(ws.data())[0]);
    } else if (qd <= 9) {
      int32_T nqp;
      nqp = ::sfe_qrules::hexa_deg9_qrule();
      cs.set_size(nqp, 3);
      ws.set_size(nqp);
      ::sfe_qrules::hexa_deg9_qrule(&cs[0], &(ws.data())[0]);
    } else if (qd <= 11) {
      int32_T nqp;
      nqp = ::sfe_qrules::hexa_deg11_qrule();
      cs.set_size(nqp, 3);
      ws.set_size(nqp);
      ::sfe_qrules::hexa_deg11_qrule(&cs[0], &(ws.data())[0]);
    } else {
      int32_T nqp;
      if (qd > 13) {
        //  m2cWarning  Display warning message
        //
        //     m2cWarning(msg)
        //     m2cWarning(msg,A1,...,An)
        //     m2cWarning(warnID,___)
        //
        //  This function performs similar to MATLAB's built-in `warning` but it
        //  supports code generation in both MEX and LIB mode.
        //
        //  Notes
        //  -----
        //  The format must be a constant string during code-generation time.
        //
        //  See also warning, m2cError, m2cAssert
        m2cWarnMsgIdAndTxt("hexa_quadrules:UnsupportedDegree",
                           "Only support up to degree 13");
      }
      nqp = ::sfe_qrules::hexa_deg13_qrule();
      cs.set_size(nqp, 3);
      ws.set_size(nqp);
      ::sfe_qrules::hexa_deg13_qrule(&cs[0], &(ws.data())[0]);
    }
  } break;
  case 6: {
    //  prism_quadrules - Obtain quadrature points and weights of a prismatic
    //  element.
    //
    //     [cs, ws] = prism_quadrules
    //     [cs, ws] = prism_quadrules(degree)
    //
    //  Parameters
    //  ----------
    //   degree: the desired degree of quadrature rule. Default is 1.
    //
    //  Returns
    //  -------
    //   cs: the natural coordinates of quadrature points (nqp-by-3)
    //   ws: the weights of quadrature points (nqp-by-1)
    //
    //  Notes
    //  -----
    //  The natural coordinates are between 0 and 1. All rules have positive
    //  weights.
    //
    //  See also bar_quadrules, tri_quadrules, quad_quadrules, tet_quadrules,
    //  hexa_quadrules, pyra_quadrules
    if (qd <= 1) {
      int32_T nqp;
      nqp = ::sfe_qrules::prism_deg1_qrule();
      cs.set_size(nqp, 3);
      ws.set_size(nqp);
      ::sfe_qrules::prism_deg1_qrule(&cs[0], &(ws.data())[0]);
    } else if (qd <= 2) {
      int32_T nqp;
      nqp = ::sfe_qrules::prism_deg2_qrule();
      cs.set_size(nqp, 3);
      ws.set_size(nqp);
      ::sfe_qrules::prism_deg2_qrule(&cs[0], &(ws.data())[0]);
    } else if (qd <= 3) {
      int32_T nqp;
      nqp = ::sfe_qrules::prism_deg3_qrule();
      cs.set_size(nqp, 3);
      ws.set_size(nqp);
      ::sfe_qrules::prism_deg3_qrule(&cs[0], &(ws.data())[0]);
    } else if (qd <= 5) {
      int32_T nqp;
      nqp = ::sfe_qrules::prism_deg5_qrule();
      cs.set_size(nqp, 3);
      ws.set_size(nqp);
      ::sfe_qrules::prism_deg5_qrule(&cs[0], &(ws.data())[0]);
    } else if (qd <= 7) {
      int32_T nqp;
      nqp = ::sfe_qrules::prism_deg7_qrule();
      cs.set_size(nqp, 3);
      ws.set_size(nqp);
      ::sfe_qrules::prism_deg7_qrule(&cs[0], &(ws.data())[0]);
    } else if (qd <= 9) {
      int32_T nqp;
      nqp = ::sfe_qrules::prism_deg9_qrule();
      cs.set_size(nqp, 3);
      ws.set_size(nqp);
      ::sfe_qrules::prism_deg9_qrule(&cs[0], &(ws.data())[0]);
    } else if (qd <= 11) {
      int32_T nqp;
      nqp = ::sfe_qrules::prism_deg11_qrule();
      cs.set_size(nqp, 3);
      ws.set_size(nqp);
      ::sfe_qrules::prism_deg11_qrule(&cs[0], &(ws.data())[0]);
    } else {
      int32_T nqp;
      if (qd > 13) {
        //  m2cWarning  Display warning message
        //
        //     m2cWarning(msg)
        //     m2cWarning(msg,A1,...,An)
        //     m2cWarning(warnID,___)
        //
        //  This function performs similar to MATLAB's built-in `warning` but it
        //  supports code generation in both MEX and LIB mode.
        //
        //  Notes
        //  -----
        //  The format must be a constant string during code-generation time.
        //
        //  See also warning, m2cError, m2cAssert
        m2cWarnMsgIdAndTxt("prism_quadrules:UnsupportedDegree",
                           "Only support up to degree 13");
      }
      nqp = ::sfe_qrules::prism_deg13_qrule();
      cs.set_size(nqp, 3);
      ws.set_size(nqp);
      ::sfe_qrules::prism_deg13_qrule(&cs[0], &(ws.data())[0]);
    }
  } break;
  default:
    //  m2cAssert  Throw error if condition false at runtime
    //
    //    m2cAssert(cond)
    //    m2cAssert(cond,msg)
    //    m2cAssert(cond,msg,A1,...,An)
    //    m2cAssert(cond,errID,msg)
    //    m2cAssert(cond,errID,msg,A1,...,An)
    //
    //  The interface of `m2cAssert` is compatible with MATLAB's built-in
    //  `assert`,  but it generates runtime assertion instead of compile-time
    //  assertion.
    //
    //  Note
    //  ----
    //  The MATLAB built-in `assert` is mostly used for compile-time error
    //  checking, and it has no effect for runtime error checking in LIB mode.
    //  Use `m2cAssert` instead for runtime error checking. Like the built-in
    //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
    //  into a code-generation-time character string. If you want to use both
    //  code-generation-time and runtime assertions, it is recommended to put
    //  `m2cAssert` before the built-in `assert`.
    //
    //  See also assert, m2cError, m2cWarning
    m2cAssert(shape == 5, "Unsupported element type");
    pyra_quadrules(qd, cs, ws);
    break;
  }
}

static void tabulate_quadratures_deg_1(int32_T etype,
                                       ::coder::array<real_T, 2U> &cs,
                                       ::coder::array<real_T, 1U> &ws)
{
  int32_T shape;
  // tabulate_quadratures_deg_1 - Tabulate quadrature rule for given element
  // type
  //    [cs, ws] = tabulate_quadratures_deg_1(etype)
  // obtain_elemshape - Decode an element geometric shape from etype
  //
  //    shapeid = obtain_elemshape(etype)
  //
  //  RETURN
  //  ------
  //    shapeid:    Integer type of different geometry shapes:
  //                    1 - BAR
  //                    2 - TRI
  //                    3 - QUAD
  //                    4 - TET
  //                    5 - PYRAMID
  //                    6 - PRISM
  //                    7 - HEX
  //
  //  See also obtain_elemdim
  //  shapeid = (etype>>5)&0b111
  shape = etype >> 5 & 7;
  switch (shape) {
  case 1: {
    int32_T nqp;
    nqp = ::sfe_qrules::bar_deg1_qrule();
    cs.set_size(nqp, 1);
    ws.set_size(nqp);
    ::sfe_qrules::bar_deg1_qrule(&cs[0], &(ws.data())[0]);
  } break;
  case 2: {
    int32_T nqp;
    nqp = ::sfe_qrules::tri_deg1_qrule();
    cs.set_size(nqp, 2);
    ws.set_size(nqp);
    ::sfe_qrules::tri_deg1_qrule(&cs[0], &(ws.data())[0]);
  } break;
  case 3: {
    int32_T nqp;
    nqp = ::sfe_qrules::quad_deg1_qrule();
    cs.set_size(nqp, 2);
    ws.set_size(nqp);
    ::sfe_qrules::quad_deg1_qrule(&cs[0], &(ws.data())[0]);
  } break;
  case 4: {
    int32_T nqp;
    nqp = ::sfe_qrules::tet_deg1_qrule();
    cs.set_size(nqp, 3);
    ws.set_size(nqp);
    ::sfe_qrules::tet_deg1_qrule(&cs[0], &(ws.data())[0]);
  } break;
  case 7: {
    int32_T nqp;
    nqp = ::sfe_qrules::hexa_deg1_qrule();
    cs.set_size(nqp, 3);
    ws.set_size(nqp);
    ::sfe_qrules::hexa_deg1_qrule(&cs[0], &(ws.data())[0]);
  } break;
  case 6: {
    int32_T nqp;
    nqp = ::sfe_qrules::prism_deg1_qrule();
    cs.set_size(nqp, 3);
    ws.set_size(nqp);
    ::sfe_qrules::prism_deg1_qrule(&cs[0], &(ws.data())[0]);
  } break;
  default: {
    int32_T nqp;
    //  m2cAssert  Throw error if condition false at runtime
    //
    //    m2cAssert(cond)
    //    m2cAssert(cond,msg)
    //    m2cAssert(cond,msg,A1,...,An)
    //    m2cAssert(cond,errID,msg)
    //    m2cAssert(cond,errID,msg,A1,...,An)
    //
    //  The interface of `m2cAssert` is compatible with MATLAB's built-in
    //  `assert`,  but it generates runtime assertion instead of compile-time
    //  assertion.
    //
    //  Note
    //  ----
    //  The MATLAB built-in `assert` is mostly used for compile-time error
    //  checking, and it has no effect for runtime error checking in LIB mode.
    //  Use `m2cAssert` instead for runtime error checking. Like the built-in
    //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
    //  into a code-generation-time character string. If you want to use both
    //  code-generation-time and runtime assertions, it is recommended to put
    //  `m2cAssert` before the built-in `assert`.
    //
    //  See also assert, m2cError, m2cWarning
    m2cAssert(shape == 5, "Unsupported element type");
    nqp = ::sfe_qrules::pyra_deg1_qrule();
    cs.set_size(nqp, 3);
    ws.set_size(nqp);
    ::sfe_qrules::pyra_deg1_qrule(&cs[0], &(ws.data())[0]);
  } break;
  }
}

static void tabulate_shapefuncs(int32_T etype,
                                const ::coder::array<real_T, 2U> &cs,
                                ::coder::array<real_T, 2U> &sfvals,
                                ::coder::array<real_T, 3U> &sdvals)
{
  int32_T shape;
  // tabulate_shapefuncs - kernel for tabulating shape functions
  // obtain_elemdim - Obtain the dimension of an element
  //
  //    dim = obtain_elemdim(etype)
  //
  //  See also obtain_elemshape
  // obtain_elemshape - Decode an element geometric shape from etype
  //
  //    shapeid = obtain_elemshape(etype)
  //
  //  RETURN
  //  ------
  //    shapeid:    Integer type of different geometry shapes:
  //                    1 - BAR
  //                    2 - TRI
  //                    3 - QUAD
  //                    4 - TET
  //                    5 - PYRAMID
  //                    6 - PRISM
  //                    7 - HEX
  //
  //  See also obtain_elemdim
  //  shapeid = (etype>>5)&0b111
  shape = etype >> 5 & 7;
  switch (((shape > 0) + (shape > 1)) + (shape > 3)) {
  case 3:
    sfe3_tabulate_shapefuncs(etype, cs, sfvals, sdvals);
    break;
  case 2:
    sfe2_tabulate_shapefuncs(etype, cs, sfvals, sdvals);
    break;
  default:
    sfe1_tabulate_shapefuncs(etype, cs, sfvals, sdvals);
    break;
  }
}

static void tabulate_shapefuncs_deg_1(int32_T etype,
                                      const ::coder::array<real_T, 2U> &cs,
                                      ::coder::array<real_T, 2U> &sfvals,
                                      ::coder::array<real_T, 3U> &sdvals)
{
  real_T tmp_data[1029];
  int32_T i;
  int32_T nqp;
  nqp = cs.size(0) - 1;
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  i = iv[etype - 1];
  sfvals.set_size(cs.size(0), i);
  sdvals.set_size(cs.size(0), i, cs.size(1));
  switch (etype) {
  case 36: {
    int32_T i1;
    boolean_T b;
    boolean_T b1;
    b = true;
    b1 = ((cs.size(1) <= 0) || (cs.size(0) <= 0));
    i = cs.size(1) * cs.size(0);
    i1 = 0;
    for (int32_T q{0}; q <= nqp; q++) {
      real_T N[2];
      real_T deriv[2];
      if (b1 || (q >= i)) {
        i1 = 0;
        b = true;
      } else if (b) {
        b = false;
        i1 = q % cs.size(0) * cs.size(1) + q / cs.size(0);
      } else {
        int32_T loop_ub;
        loop_ub = cs.size(1) * cs.size(0) - 1;
        if (i1 > MAX_int32_T - cs.size(1)) {
          i1 = q % cs.size(0) * cs.size(1) + q / cs.size(0);
        } else {
          i1 += cs.size(1);
          if (i1 > loop_ub) {
            i1 -= loop_ub;
          }
        }
      }
      // bar_2 - Compute shape functions and their derivatives of bar_2
      //
      //     ncoords = bar_2
      //     [sfvals,sdvals] = bar_2(xi)
      //
      // Parameters
      // ----------
      //     xi: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 2-by-1
      //     sdvals: vector of size 2-by-1
      ::sfe_sfuncs::bar_2_sfunc(cs[i1], &N[0], &deriv[0]);
      sfvals[sfvals.size(1) * q] = N[0];
      sdvals[sdvals.size(2) * sdvals.size(1) * q] = deriv[0];
      sfvals[sfvals.size(1) * q + 1] = N[1];
      sdvals[sdvals.size(2) + sdvals.size(2) * sdvals.size(1) * q] = deriv[1];
    }
  } break;
  case 68: {
    for (int32_T q{0}; q <= nqp; q++) {
      real_T dv2[6];
      real_T dv5[3];
      int32_T i1;
      int32_T i2;
      int32_T loop_ub;
      int32_T tmp_size_idx_1;
      int32_T tmp_size_idx_2;
      int16_T unnamed_idx_1;
      int16_T unnamed_idx_2;
      // tri_3 - Compute shape functions and their derivatives of tri_3
      //
      //     ncoords = tri_3
      //     [sfvals,sdvals] = tri_3(xi,eta)
      //
      // Parameters
      // ----------
      //     xi,eta: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 3-by-1
      //     sdvals: vector of size 3-by-2
      ::sfe_sfuncs::tri_3_sfunc(cs[cs.size(1) * q], cs[cs.size(1) * q + 1],
                                &dv5[0], &dv2[0]);
      loop_ub = sfvals.size(1);
      for (i = 0; i < loop_ub; i++) {
        sfvals[i + sfvals.size(1) * q] = dv5[i];
      }
      unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i = 0;
      i1 = 0;
      loop_ub = 0;
      i2 = 0;
      tmp_size_idx_2 = sdvals.size(2);
      tmp_size_idx_1 = sdvals.size(1);
      for (int32_T i3{0}; i3 < unnamed_idx_1 * unnamed_idx_2; i3++) {
        tmp_data[i1 + tmp_size_idx_2 * i] = dv2[i2 + (loop_ub << 1)];
        loop_ub++;
        i++;
        if (i > tmp_size_idx_1 - 1) {
          i = 0;
          i1++;
        }
        if (loop_ub > 2) {
          loop_ub = 0;
          i2++;
        }
      }
      for (i = 0; i < tmp_size_idx_1; i++) {
        for (i1 = 0; i1 < tmp_size_idx_2; i1++) {
          sdvals[(i1 + sdvals.size(2) * i) +
                 sdvals.size(2) * sdvals.size(1) * q] =
              tmp_data[i1 + tmp_size_idx_2 * i];
        }
      }
    }
  } break;
  case 100: {
    for (int32_T q{0}; q <= nqp; q++) {
      real_T dv[8];
      real_T dv1[4];
      int32_T i1;
      int32_T i2;
      int32_T loop_ub;
      int32_T tmp_size_idx_1;
      int32_T tmp_size_idx_2;
      int16_T unnamed_idx_1;
      int16_T unnamed_idx_2;
      // quad_4 - Bilinear quadrilateral element
      //     [sfvals,sdvals] = quad_4(xi,eta)
      //
      //   Input:
      //      xi, eta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 4-by-1
      //      sdvals: vector of size 4-by-2
      //
      //     nodes_nat_coors = quad_4
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also quad_9, quad_16, quad_gl_16, quad_25, quad_gl_25
      ::sfe_sfuncs::quad_4_sfunc(cs[cs.size(1) * q], cs[cs.size(1) * q + 1],
                                 &dv1[0], &dv[0]);
      loop_ub = sfvals.size(1);
      for (i = 0; i < loop_ub; i++) {
        sfvals[i + sfvals.size(1) * q] = dv1[i];
      }
      unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i = 0;
      i1 = 0;
      loop_ub = 0;
      i2 = 0;
      tmp_size_idx_2 = sdvals.size(2);
      tmp_size_idx_1 = sdvals.size(1);
      for (int32_T i3{0}; i3 < unnamed_idx_1 * unnamed_idx_2; i3++) {
        tmp_data[i1 + tmp_size_idx_2 * i] = dv[i2 + (loop_ub << 1)];
        loop_ub++;
        i++;
        if (i > tmp_size_idx_1 - 1) {
          i = 0;
          i1++;
        }
        if (loop_ub > 3) {
          loop_ub = 0;
          i2++;
        }
      }
      for (i = 0; i < tmp_size_idx_1; i++) {
        for (i1 = 0; i1 < tmp_size_idx_2; i1++) {
          sdvals[(i1 + sdvals.size(2) * i) +
                 sdvals.size(2) * sdvals.size(1) * q] =
              tmp_data[i1 + tmp_size_idx_2 * i];
        }
      }
    }
  } break;
  case 132: {
    for (int32_T q{0}; q <= nqp; q++) {
      real_T dv6[12];
      real_T dv1[4];
      int32_T i1;
      int32_T i2;
      int32_T loop_ub;
      int32_T tmp_size_idx_1;
      int32_T tmp_size_idx_2;
      int16_T unnamed_idx_1;
      int16_T unnamed_idx_2;
      // tet_4 - Compute shape functions and their derivatives of tet_4
      //
      //     ncoords = tet_4
      //     [sfvals,sdvals] = tet_4(xi,eta,zeta)
      //
      // Parameters
      // ----------
      //     xi,eta,zeta: natural coordinates ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 4-by-1
      //     sdvals: vector of size 4-by-3
      ::sfe_sfuncs::tet_4_sfunc(cs[cs.size(1) * q], cs[cs.size(1) * q + 1],
                                cs[cs.size(1) * q + 2], &dv1[0], &dv6[0]);
      loop_ub = sfvals.size(1);
      for (i = 0; i < loop_ub; i++) {
        sfvals[i + sfvals.size(1) * q] = dv1[i];
      }
      unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i = 0;
      i1 = 0;
      loop_ub = 0;
      i2 = 0;
      tmp_size_idx_2 = sdvals.size(2);
      tmp_size_idx_1 = sdvals.size(1);
      for (int32_T i3{0}; i3 < unnamed_idx_1 * unnamed_idx_2; i3++) {
        tmp_data[i1 + tmp_size_idx_2 * i] = dv6[i2 + 3 * loop_ub];
        loop_ub++;
        i++;
        if (i > tmp_size_idx_1 - 1) {
          i = 0;
          i1++;
        }
        if (loop_ub > 3) {
          loop_ub = 0;
          i2++;
        }
      }
      for (i = 0; i < tmp_size_idx_1; i++) {
        for (i1 = 0; i1 < tmp_size_idx_2; i1++) {
          sdvals[(i1 + sdvals.size(2) * i) +
                 sdvals.size(2) * sdvals.size(1) * q] =
              tmp_data[i1 + tmp_size_idx_2 * i];
        }
      }
    }
  } break;
  case 164: {
    for (int32_T q{0}; q <= nqp; q++) {
      real_T dv8[15];
      real_T dv7[5];
      int32_T i1;
      int32_T i2;
      int32_T loop_ub;
      int32_T tmp_size_idx_1;
      int32_T tmp_size_idx_2;
      int16_T unnamed_idx_1;
      int16_T unnamed_idx_2;
      // pyra_5 - Compute shape functions and their derivatives of pyra_5
      //
      //     ncoords = pyra_5
      //     [sfvals,sdvals] = pyra_5(xi,eta,zeta)
      //
      // Parameters
      // ----------
      //     xi,eta: natural coordinates ranging between -1 and 1
      //     zeta: natural coordinate ranging between 0 and 1
      //
      // Returns
      // -------
      //     ncoords: natural coordinates of nodes if nargin==0
      //
      //                          OR
      //
      //     sfvals: vector of size 5-by-1
      //     sdvals: vector of size 5-by-3
      // Note
      // ----
      //  The shape functions are based on Bedrosian rational basis functions.
      ::sfe_sfuncs::pyra_5_sfunc(cs[cs.size(1) * q], cs[cs.size(1) * q + 1],
                                 cs[cs.size(1) * q + 2], &dv7[0], &dv8[0]);
      loop_ub = sfvals.size(1);
      for (i = 0; i < loop_ub; i++) {
        sfvals[i + sfvals.size(1) * q] = dv7[i];
      }
      unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i = 0;
      i1 = 0;
      loop_ub = 0;
      i2 = 0;
      tmp_size_idx_2 = sdvals.size(2);
      tmp_size_idx_1 = sdvals.size(1);
      for (int32_T i3{0}; i3 < unnamed_idx_1 * unnamed_idx_2; i3++) {
        tmp_data[i1 + tmp_size_idx_2 * i] = dv8[i2 + 3 * loop_ub];
        loop_ub++;
        i++;
        if (i > tmp_size_idx_1 - 1) {
          i = 0;
          i1++;
        }
        if (loop_ub > 4) {
          loop_ub = 0;
          i2++;
        }
      }
      for (i = 0; i < tmp_size_idx_1; i++) {
        for (i1 = 0; i1 < tmp_size_idx_2; i1++) {
          sdvals[(i1 + sdvals.size(2) * i) +
                 sdvals.size(2) * sdvals.size(1) * q] =
              tmp_data[i1 + tmp_size_idx_2 * i];
        }
      }
    }
  } break;
  case 196: {
    for (int32_T q{0}; q <= nqp; q++) {
      real_T dv4[18];
      real_T dv2[6];
      int32_T i1;
      int32_T i2;
      int32_T loop_ub;
      int32_T tmp_size_idx_1;
      int32_T tmp_size_idx_2;
      int16_T unnamed_idx_1;
      int16_T unnamed_idx_2;
      // prism_6 - Linear prismatic element
      //     [sfvals,sdvals] = prism_6(xi,eta,zeta)
      //
      //   Input:
      //      xi, eta, zeta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 6-by-1
      //      sdvals: vector of size 6-by-3
      //
      //     nodes_nat_coors = prism_6
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also prism_18, prism_40, prism_gl_40, prism_75, prism_gl_75
      ::sfe_sfuncs::prism_6_sfunc(cs[cs.size(1) * q], cs[cs.size(1) * q + 1],
                                  cs[cs.size(1) * q + 2], &dv2[0], &dv4[0]);
      loop_ub = sfvals.size(1);
      for (i = 0; i < loop_ub; i++) {
        sfvals[i + sfvals.size(1) * q] = dv2[i];
      }
      unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i = 0;
      i1 = 0;
      loop_ub = 0;
      i2 = 0;
      tmp_size_idx_2 = sdvals.size(2);
      tmp_size_idx_1 = sdvals.size(1);
      for (int32_T i3{0}; i3 < unnamed_idx_1 * unnamed_idx_2; i3++) {
        tmp_data[i1 + tmp_size_idx_2 * i] = dv4[i2 + 3 * loop_ub];
        loop_ub++;
        i++;
        if (i > tmp_size_idx_1 - 1) {
          i = 0;
          i1++;
        }
        if (loop_ub > 5) {
          loop_ub = 0;
          i2++;
        }
      }
      for (i = 0; i < tmp_size_idx_1; i++) {
        for (i1 = 0; i1 < tmp_size_idx_2; i1++) {
          sdvals[(i1 + sdvals.size(2) * i) +
                 sdvals.size(2) * sdvals.size(1) * q] =
              tmp_data[i1 + tmp_size_idx_2 * i];
        }
      }
    }
  } break;
  default: {
    for (int32_T q{0}; q <= nqp; q++) {
      real_T dv3[24];
      real_T dv[8];
      int32_T i1;
      int32_T i2;
      int32_T loop_ub;
      int32_T tmp_size_idx_1;
      int32_T tmp_size_idx_2;
      int16_T unnamed_idx_1;
      int16_T unnamed_idx_2;
      // hexa_8 - Trilinear hexahedral element
      //     [sfvals,sdvals] = hexa_8(xi,eta,zeta)
      //
      //   Input:
      //      xi, eta, zeta: range between 0 and 1.
      //   Output:
      //      sfvals: vector of size 8-by-1
      //      sdvals: vector of size 8-by-3
      //
      //     nodes_nat_coors = hexa_8
      //   If no input argument, return natural coordinates of nodes
      //
      //   See also hexa_27, hexa_64, hexa_gl_64, hexa_125, hexa_gl_125
      ::sfe_sfuncs::hexa_8_sfunc(cs[cs.size(1) * q], cs[cs.size(1) * q + 1],
                                 cs[cs.size(1) * q + 2], &dv[0], &dv3[0]);
      loop_ub = sfvals.size(1);
      for (i = 0; i < loop_ub; i++) {
        sfvals[i + sfvals.size(1) * q] = dv[i];
      }
      unnamed_idx_1 = static_cast<int16_T>(sdvals.size(1));
      unnamed_idx_2 = static_cast<int16_T>(sdvals.size(2));
      i = 0;
      i1 = 0;
      loop_ub = 0;
      i2 = 0;
      tmp_size_idx_2 = sdvals.size(2);
      tmp_size_idx_1 = sdvals.size(1);
      for (int32_T i3{0}; i3 < unnamed_idx_1 * unnamed_idx_2; i3++) {
        tmp_data[i1 + tmp_size_idx_2 * i] = dv3[i2 + 3 * loop_ub];
        loop_ub++;
        i++;
        if (i > tmp_size_idx_1 - 1) {
          i = 0;
          i1++;
        }
        if (loop_ub > 7) {
          loop_ub = 0;
          i2++;
        }
      }
      for (i = 0; i < tmp_size_idx_1; i++) {
        for (i1 = 0; i1 < tmp_size_idx_2; i1++) {
          sdvals[(i1 + sdvals.size(2) * i) +
                 sdvals.size(2) * sdvals.size(1) * q] =
              tmp_data[i1 + tmp_size_idx_2 * i];
        }
      }
    }
  } break;
  }
}

static void tet_20(real_T xi, real_T eta, real_T zeta, real_T sfvals[20],
                   real_T sdvals[60])
{
  // tet_20 - Compute shape functions and their derivatives of tet_20
  //
  //     ncoords = tet_20
  //     [sfvals,sdvals] = tet_20(xi,eta,zeta)
  //
  // Parameters
  // ----------
  //     xi,eta,zeta: natural coordinates ranging between 0 and 1
  //
  // Returns
  // -------
  //     ncoords: natural coordinates of nodes if nargin==0
  //
  //                          OR
  //
  //     sfvals: vector of size 20-by-1
  //     sdvals: vector of size 20-by-3
  ::sfe_sfuncs::tet_20_sfunc(xi, eta, zeta, &sfvals[0], &sdvals[0]);
}

static void tet_35(real_T xi, real_T eta, real_T zeta, real_T sfvals[35],
                   real_T sdvals[105])
{
  // tet_35 - Compute shape functions and their derivatives of tet_35
  //
  //     ncoords = tet_35
  //     [sfvals,sdvals] = tet_35(xi,eta,zeta)
  //
  // Parameters
  // ----------
  //     xi,eta,zeta: natural coordinates ranging between 0 and 1
  //
  // Returns
  // -------
  //     ncoords: natural coordinates of nodes if nargin==0
  //
  //                          OR
  //
  //     sfvals: vector of size 35-by-1
  //     sdvals: vector of size 35-by-3
  ::sfe_sfuncs::tet_35_sfunc(xi, eta, zeta, &sfvals[0], &sdvals[0]);
}

static void tet_56(real_T xi, real_T eta, real_T zeta, real_T sfvals[56],
                   real_T sdvals[168])
{
  // tet_56 - Compute shape functions and their derivatives of tet_56
  //
  //     ncoords = tet_56
  //     [sfvals,sdvals] = tet_56(xi,eta,zeta)
  //
  // Parameters
  // ----------
  //     xi,eta,zeta: natural coordinates ranging between 0 and 1
  //
  // Returns
  // -------
  //     ncoords: natural coordinates of nodes if nargin==0
  //
  //                          OR
  //
  //     sfvals: vector of size 56-by-1
  //     sdvals: vector of size 56-by-3
  ::sfe_sfuncs::tet_56_sfunc(xi, eta, zeta, &sfvals[0], &sdvals[0]);
}

static void tet_84(real_T xi, real_T eta, real_T zeta, real_T sfvals[84],
                   real_T sdvals[252])
{
  // tet_84 - Compute shape functions and their derivatives of tet_84
  //
  //     ncoords = tet_84
  //     [sfvals,sdvals] = tet_84(xi,eta,zeta,varargin)
  //
  // Parameters
  // ----------
  //     xi,eta,zeta,varargin: natural coordinates ranging between 0 and 1
  //
  // Returns
  // -------
  //     ncoords: natural coordinates of nodes if nargin==0
  //
  //                          OR
  //
  //     sfvals: vector of size 84-by-1
  //     sdvals: vector of size 84-by-3
  ::sfe_sfuncs::tet_84_sfunc(xi, eta, zeta, &sfvals[0], &sdvals[0]);
}

static void tet_gl_20(real_T xi, real_T eta, real_T zeta, real_T sfvals[20],
                      real_T sdvals[60])
{
  // tet_gl_20 - Compute shape functions and their derivatives of tet_gl_20
  //
  //     ncoords = tet_gl_20
  //     [sfvals,sdvals] = tet_gl_20(xi,eta,zeta)
  //
  // Parameters
  // ----------
  //     xi,eta,zeta: natural coordinates ranging between 0 and 1
  //
  // Returns
  // -------
  //     ncoords: natural coordinates of nodes if nargin==0
  //
  //                          OR
  //
  //     sfvals: vector of size 20-by-1
  //     sdvals: vector of size 20-by-3
  ::sfe_sfuncs::tet_gl_20_sfunc(xi, eta, zeta, &sfvals[0], &sdvals[0]);
}

static void tet_gl_35(real_T xi, real_T eta, real_T zeta, real_T sfvals[35],
                      real_T sdvals[105])
{
  // tet_gl_35 - Compute shape functions and their derivatives of tet_gl_35
  //
  //     ncoords = tet_gl_35
  //     [sfvals,sdvals] = tet_gl_35(xi,eta,zeta)
  //
  // Parameters
  // ----------
  //     xi,eta,zeta: natural coordinates ranging between 0 and 1
  //
  // Returns
  // -------
  //     ncoords: natural coordinates of nodes if nargin==0
  //
  //                          OR
  //
  //     sfvals: vector of size 35-by-1
  //     sdvals: vector of size 35-by-3
  ::sfe_sfuncs::tet_gl_35_sfunc(xi, eta, zeta, &sfvals[0], &sdvals[0]);
}

static void tri_21(real_T xi, real_T eta, real_T sfvals[21], real_T sdvals[42])
{
  // tri_21 - Compute shape functions and their derivatives of tri_21
  //
  //     ncoords = tri_21
  //     [sfvals,sdvals] = tri_21(xi,eta)
  //
  // Parameters
  // ----------
  //     xi,eta: natural coordinates ranging between 0 and 1
  //
  // Returns
  // -------
  //     ncoords: natural coordinates of nodes if nargin==0
  //
  //                          OR
  //
  //     sfvals: vector of size 21-by-1
  //     sdvals: vector of size 21-by-2
  ::sfe_sfuncs::tri_21_sfunc(xi, eta, &sfvals[0], &sdvals[0]);
}

static void tri_28(real_T xi, real_T eta, real_T sfvals[28], real_T sdvals[56])
{
  // tri_28 - Compute shape functions and their derivatives of tri_28
  //
  //     ncoords = tri_28
  //     [sfvals,sdvals] = tri_28(xi,eta)
  //
  // Parameters
  // ----------
  //     xi,eta: natural coordinates ranging between 0 and 1
  //
  // Returns
  // -------
  //     ncoords: natural coordinates of nodes if nargin==0
  //
  //                          OR
  //
  //     sfvals: vector of size 28-by-1
  //     sdvals: vector of size 28-by-2
  ::sfe_sfuncs::tri_28_sfunc(xi, eta, &sfvals[0], &sdvals[0]);
}

static void tri_fek_15(real_T xi, real_T eta, real_T sfvals[15],
                       real_T sdvals[30])
{
  // tri_fek_15 - Compute shape functions and their derivatives of tri_fek_15
  //
  //     ncoords = tri_fek_15
  //     [sfvals,sdvals] = tri_fek_15(xi,eta)
  //
  // Parameters
  // ----------
  //     xi,eta: natural coordinates ranging between 0 and 1
  //
  // Returns
  // -------
  //     ncoords: natural coordinates of nodes if nargin==0
  //
  //                          OR
  //
  //     sfvals: vector of size 15-by-1
  //     sdvals: vector of size 15-by-2
  ::sfe_sfuncs::tri_fek_15_sfunc(xi, eta, &sfvals[0], &sdvals[0]);
}

static void tri_fek_21(real_T xi, real_T eta, real_T sfvals[21],
                       real_T sdvals[42])
{
  // tri_fek_21 - Compute shape functions and their derivatives of tri_fek_21
  //
  //     ncoords = tri_fek_21
  //     [sfvals,sdvals] = tri_fek_21(xi,eta)
  //
  // Parameters
  // ----------
  //     xi,eta: natural coordinates ranging between 0 and 1
  //
  // Returns
  // -------
  //     ncoords: natural coordinates of nodes if nargin==0
  //
  //                          OR
  //
  //     sfvals: vector of size 21-by-1
  //     sdvals: vector of size 21-by-2
  ::sfe_sfuncs::tri_fek_21_sfunc(xi, eta, &sfvals[0], &sdvals[0]);
}

static void tri_fek_28(real_T xi, real_T eta, real_T sfvals[28],
                       real_T sdvals[56])
{
  // tri_fek_28 - Compute shape functions and their derivatives of tri_fek_28
  //
  //     ncoords = tri_fek_28
  //     [sfvals,sdvals] = tri_fek_28(xi,eta)
  //
  // Parameters
  // ----------
  //     xi,eta: natural coordinates ranging between 0 and 1
  //
  // Returns
  // -------
  //     ncoords: natural coordinates of nodes if nargin==0
  //
  //                          OR
  //
  //     sfvals: vector of size 28-by-1
  //     sdvals: vector of size 28-by-2
  ::sfe_sfuncs::tri_fek_28_sfunc(xi, eta, &sfvals[0], &sdvals[0]);
}

static void tri_gl_21(real_T xi, real_T eta, real_T sfvals[21],
                      real_T sdvals[42])
{
  // tri_gl_21 - Compute shape functions and their derivatives of tri_gl_21
  //
  //     ncoords = tri_gl_21
  //     [sfvals,sdvals] = tri_gl_21(xi,eta)
  //
  // Parameters
  // ----------
  //     xi,eta: natural coordinates ranging between 0 and 1
  //
  // Returns
  // -------
  //     ncoords: natural coordinates of nodes if nargin==0
  //
  //                          OR
  //
  //     sfvals: vector of size 21-by-1
  //     sdvals: vector of size 21-by-2
  ::sfe_sfuncs::tri_gl_21_sfunc(xi, eta, &sfvals[0], &sdvals[0]);
}

static void tri_quadrules(int32_T degree, ::coder::array<real_T, 2U> &cs,
                          ::coder::array<real_T, 1U> &ws)
{
  //  tri_quadrules - Obtain quadrature points and weights of a triangular
  //  element.
  //
  //     [cs, ws] = tri_quadrules
  //     [cs, ws] = tri_quadrules(degree)
  //
  //  Parameters
  //  ----------
  //   degree: the desired degree of quadrature rule. Default is 1.
  //
  //  Returns
  //  -------
  //   cs: the natural coordinates of quadrature points (nqp-by-2)
  //   ws: the weights of quadrature points (nqp-by-1)
  //
  //  Notes
  //  -----
  //  The natural coordinates are between 0 and 1. All rules have positive
  //  weights.
  //
  //  See also bar_quadrules, quad_quadrules, tet_quadrules, prism_quadrules,
  //  hexa_quadrules, pyra_quadrules
  if (degree <= 1) {
    int32_T nqp;
    nqp = ::sfe_qrules::tri_deg1_qrule();
    cs.set_size(nqp, 2);
    ws.set_size(nqp);
    ::sfe_qrules::tri_deg1_qrule(&cs[0], &(ws.data())[0]);
  } else if (degree <= 2) {
    int32_T nqp;
    nqp = ::sfe_qrules::tri_deg2_qrule();
    cs.set_size(nqp, 2);
    ws.set_size(nqp);
    ::sfe_qrules::tri_deg2_qrule(&cs[0], &(ws.data())[0]);
  } else if (degree <= 4) {
    int32_T nqp;
    nqp = ::sfe_qrules::tri_deg4_qrule();
    cs.set_size(nqp, 2);
    ws.set_size(nqp);
    ::sfe_qrules::tri_deg4_qrule(&cs[0], &(ws.data())[0]);
  } else if (degree <= 5) {
    int32_T nqp;
    nqp = ::sfe_qrules::tri_deg5_qrule();
    cs.set_size(nqp, 2);
    ws.set_size(nqp);
    ::sfe_qrules::tri_deg5_qrule(&cs[0], &(ws.data())[0]);
  } else if (degree <= 7) {
    int32_T nqp;
    nqp = ::sfe_qrules::tri_deg7_qrule();
    cs.set_size(nqp, 2);
    ws.set_size(nqp);
    ::sfe_qrules::tri_deg7_qrule(&cs[0], &(ws.data())[0]);
  } else if (degree <= 8) {
    int32_T nqp;
    nqp = ::sfe_qrules::tri_deg8_qrule();
    cs.set_size(nqp, 2);
    ws.set_size(nqp);
    ::sfe_qrules::tri_deg8_qrule(&cs[0], &(ws.data())[0]);
  } else if (degree <= 9) {
    int32_T nqp;
    nqp = ::sfe_qrules::tri_deg9_qrule();
    cs.set_size(nqp, 2);
    ws.set_size(nqp);
    ::sfe_qrules::tri_deg9_qrule(&cs[0], &(ws.data())[0]);
  } else if (degree <= 11) {
    int32_T nqp;
    nqp = ::sfe_qrules::tri_deg11_qrule();
    cs.set_size(nqp, 2);
    ws.set_size(nqp);
    ::sfe_qrules::tri_deg11_qrule(&cs[0], &(ws.data())[0]);
  } else {
    int32_T nqp;
    if (degree > 13) {
      //  m2cWarning  Display warning message
      //
      //     m2cWarning(msg)
      //     m2cWarning(msg,A1,...,An)
      //     m2cWarning(warnID,___)
      //
      //  This function performs similar to MATLAB's built-in `warning` but it
      //  supports code generation in both MEX and LIB mode.
      //
      //  Notes
      //  -----
      //  The format must be a constant string during code-generation time.
      //
      //  See also warning, m2cError, m2cAssert
      m2cWarnMsgIdAndTxt("tri_quadrules:UnsupportedDegree",
                         "Only support up to degree 13");
    }
    nqp = ::sfe_qrules::tri_deg13_qrule();
    cs.set_size(nqp, 2);
    ws.set_size(nqp);
    ::sfe_qrules::tri_deg13_qrule(&cs[0], &(ws.data())[0]);
  }
}

void sfe_bnd_init1(SfeObject *b_sfe, int32_T etypes, int8_T facetid,
                   const ::coder::array<real_T, 2U> &xs,
                   int32_T qd_or_natcoords,
                   const ::coder::array<real_T, 2U> &varargin_1)
{
  int32_T lids_size;
  int16_T lids_data[50];
  uint8_T geom_bnd_etype;
  boolean_T cond;
  // sfe_bnd_init - Initialize an SfeObject instance for boundary element
  //
  //    sfe = sfe_bnd_init(sfe, etypes, facetid, xs)
  //    sfe = sfe_bnd_init(sfe, etypes, facetid, xs, natcoords)
  //    sfe = sfe_bnd_init(sfe, etypes, facetid, xs, qd)
  //    sfe = sfe_bnd_init(sfe, etypes, facetid, xs, qd, userquad)
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An SfeObject instance
  //    etypes:     Element type(s), which can be a 2-vector, scalar, or [].
  //                A 2-vector specifies the solution and geometric element
  //                types, and it supports iso-, sub- and super-parametric
  //                elements. If two element types are equal, then one can use a
  //                scalar. An empty array ([]) instructs the function to reuse
  //                the element type and the tabulation stored in the `sfe`
  //                object (typically from a previous call).
  //    facetid:    Local facet ID, which defines the edge (2D) or face (3D) on
  //                which we will initialize the boundary element. Note that we
  //                use CGNS numbering regarding node and facet ordering.
  //    xs:         Physical coordinates of the element, which is defined in
  //                the geometric space.
  //    qd:         Quadrature degree. A zero value indicates the default
  //    quadrature
  //                rules based on the element types. If -1 is passed in, then
  //                the code will assume user-provided quadrature rule
  //                information
  //    userquad:   This field is only accessed if qd==-1. If provided, then
  //                userquad must be a nqp-by-(1+dim-1) array, where the first
  //                column vector is the quadrature weights while the rest
  //                entries are their corresponding quadrature points in the
  //                reference element. Note that the quadrature points defined
  //                in the the facet is one dimension less than that in the
  //                volume element.
  //
  //  In particular, the user can pass in specific natural coordinates on which
  //  we will compute shape functions and derivatives. In this situation, we
  //  will skip the computation of Jacobian.
  //
  //    natcoords:  List of natural coordinates defined by the user
  //
  //  See also sfe_init, obtain_facets
  //  check if valid combo
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(true, "invalid element combination");
  if ((facetid >= 1) && (facetid <= obtain_facets(etypes))) {
    cond = true;
  } else {
    cond = false;
  }
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(cond, "facet ID out of range");
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(xs.size(0) == iv[etypes - 1], "unmatched nnodes");
  obtain_facets(etypes, facetid, &geom_bnd_etype, lids_data, &lids_size);
  b_sfe->xswork.set_size(lids_size, xs.size(1));
  for (int32_T i{0}; i < lids_size; i++) {
    int32_T b_i;
    b_i = xs.size(1);
    for (int32_T d{0}; d < b_i; d++) {
      b_sfe->xswork[d + b_sfe->xswork.size(1) * i] =
          xs[d + xs.size(1) * (lids_data[i] - 1)];
    }
  }
  uint8_T b_trial_bnd_etype[2];
  uint8_T trial_bnd_etype;
  b_sfe->facetid = facetid;
  trial_bnd_etype = obtain_facets(etypes, facetid);
  b_trial_bnd_etype[0] = trial_bnd_etype;
  b_trial_bnd_etype[1] = geom_bnd_etype;
  sfe_init(b_sfe, b_trial_bnd_etype, b_sfe->xswork, qd_or_natcoords,
           varargin_1);
  //  reset to volume cell types
  b_sfe->etypes[0] = etypes;
  b_sfe->etypes[1] = etypes;
  //  NOTE the number of nodes in sfe is based on facet elements
}

void sfe_bnd_init10(SfeObject *b_sfe, int8_T facetid,
                    const ::coder::array<real_T, 2U> &xs, int32_T)
{
  int32_T lids_size;
  int16_T lids_data[50];
  uint8_T geom_bnd_etype;
  boolean_T flag;
  // sfe_bnd_init - Initialize an SfeObject instance for boundary element
  //
  //    sfe = sfe_bnd_init(sfe, etypes, facetid, xs)
  //    sfe = sfe_bnd_init(sfe, etypes, facetid, xs, natcoords)
  //    sfe = sfe_bnd_init(sfe, etypes, facetid, xs, qd)
  //    sfe = sfe_bnd_init(sfe, etypes, facetid, xs, qd, userquad)
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An SfeObject instance
  //    etypes:     Element type(s), which can be a 2-vector, scalar, or [].
  //                A 2-vector specifies the solution and geometric element
  //                types, and it supports iso-, sub- and super-parametric
  //                elements. If two element types are equal, then one can use a
  //                scalar. An empty array ([]) instructs the function to reuse
  //                the element type and the tabulation stored in the `sfe`
  //                object (typically from a previous call).
  //    facetid:    Local facet ID, which defines the edge (2D) or face (3D) on
  //                which we will initialize the boundary element. Note that we
  //                use CGNS numbering regarding node and facet ordering.
  //    xs:         Physical coordinates of the element, which is defined in
  //                the geometric space.
  //    qd:         Quadrature degree. A zero value indicates the default
  //    quadrature
  //                rules based on the element types. If -1 is passed in, then
  //                the code will assume user-provided quadrature rule
  //                information
  //    userquad:   This field is only accessed if qd==-1. If provided, then
  //                userquad must be a nqp-by-(1+dim-1) array, where the first
  //                column vector is the quadrature weights while the rest
  //                entries are their corresponding quadrature points in the
  //                reference element. Note that the quadrature points defined
  //                in the the facet is one dimension less than that in the
  //                volume element.
  //
  //  In particular, the user can pass in specific natural coordinates on which
  //  we will compute shape functions and derivatives. In this situation, we
  //  will skip the computation of Jacobian.
  //
  //    natcoords:  List of natural coordinates defined by the user
  //
  //  See also sfe_init, obtain_facets
  //  pre-initialized
  //  check if valid combo
  flag = (b_sfe->etypes[0] == b_sfe->etypes[1]);
  if (!flag) {
    //  then the shapes must match
    // obtain_elemshape - Decode an element geometric shape from etype
    //
    //    shapeid = obtain_elemshape(etype)
    //
    //  RETURN
    //  ------
    //    shapeid:    Integer type of different geometry shapes:
    //                    1 - BAR
    //                    2 - TRI
    //                    3 - QUAD
    //                    4 - TET
    //                    5 - PYRAMID
    //                    6 - PRISM
    //                    7 - HEX
    //
    //  See also obtain_elemdim
    //  shapeid = (etype>>5)&0b111
    // obtain_elemshape - Decode an element geometric shape from etype
    //
    //    shapeid = obtain_elemshape(etype)
    //
    //  RETURN
    //  ------
    //    shapeid:    Integer type of different geometry shapes:
    //                    1 - BAR
    //                    2 - TRI
    //                    3 - QUAD
    //                    4 - TET
    //                    5 - PYRAMID
    //                    6 - PRISM
    //                    7 - HEX
    //
    //  See also obtain_elemdim
    //  shapeid = (etype>>5)&0b111
    flag = ((b_sfe->etypes[0] >> 5 & 7) == (b_sfe->etypes[1] >> 5 & 7));
  }
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(flag, "invalid element combination");
  if ((facetid >= 1) && (facetid <= obtain_facets(b_sfe->etypes[0]))) {
    flag = true;
  } else {
    flag = false;
  }
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(flag, "facet ID out of range");
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(xs.size(0) == iv[b_sfe->etypes[1] - 1], "unmatched nnodes");
  obtain_facets(b_sfe->etypes[1], facetid, &geom_bnd_etype, lids_data,
                &lids_size);
  b_sfe->xswork.set_size(lids_size, xs.size(1));
  for (int32_T i{0}; i < lids_size; i++) {
    int32_T b_i;
    b_i = xs.size(1);
    for (int32_T d{0}; d < b_i; d++) {
      b_sfe->xswork[d + b_sfe->xswork.size(1) * i] =
          xs[d + xs.size(1) * (lids_data[i] - 1)];
    }
  }
  b_sfe->facetid = facetid;
  //  remain already-initialized stage
  sfe_init(b_sfe, b_sfe->xswork);
}

void sfe_bnd_init11(SfeObject *b_sfe, int8_T facetid,
                    const ::coder::array<real_T, 2U> &xs)
{
  int32_T lids_size;
  int16_T lids_data[50];
  uint8_T geom_bnd_etype;
  boolean_T flag;
  // sfe_bnd_init - Initialize an SfeObject instance for boundary element
  //
  //    sfe = sfe_bnd_init(sfe, etypes, facetid, xs)
  //    sfe = sfe_bnd_init(sfe, etypes, facetid, xs, natcoords)
  //    sfe = sfe_bnd_init(sfe, etypes, facetid, xs, qd)
  //    sfe = sfe_bnd_init(sfe, etypes, facetid, xs, qd, userquad)
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An SfeObject instance
  //    etypes:     Element type(s), which can be a 2-vector, scalar, or [].
  //                A 2-vector specifies the solution and geometric element
  //                types, and it supports iso-, sub- and super-parametric
  //                elements. If two element types are equal, then one can use a
  //                scalar. An empty array ([]) instructs the function to reuse
  //                the element type and the tabulation stored in the `sfe`
  //                object (typically from a previous call).
  //    facetid:    Local facet ID, which defines the edge (2D) or face (3D) on
  //                which we will initialize the boundary element. Note that we
  //                use CGNS numbering regarding node and facet ordering.
  //    xs:         Physical coordinates of the element, which is defined in
  //                the geometric space.
  //    qd:         Quadrature degree. A zero value indicates the default
  //    quadrature
  //                rules based on the element types. If -1 is passed in, then
  //                the code will assume user-provided quadrature rule
  //                information
  //    userquad:   This field is only accessed if qd==-1. If provided, then
  //                userquad must be a nqp-by-(1+dim-1) array, where the first
  //                column vector is the quadrature weights while the rest
  //                entries are their corresponding quadrature points in the
  //                reference element. Note that the quadrature points defined
  //                in the the facet is one dimension less than that in the
  //                volume element.
  //
  //  In particular, the user can pass in specific natural coordinates on which
  //  we will compute shape functions and derivatives. In this situation, we
  //  will skip the computation of Jacobian.
  //
  //    natcoords:  List of natural coordinates defined by the user
  //
  //  See also sfe_init, obtain_facets
  //  pre-initialized
  //  check if valid combo
  flag = (b_sfe->etypes[0] == b_sfe->etypes[1]);
  if (!flag) {
    //  then the shapes must match
    // obtain_elemshape - Decode an element geometric shape from etype
    //
    //    shapeid = obtain_elemshape(etype)
    //
    //  RETURN
    //  ------
    //    shapeid:    Integer type of different geometry shapes:
    //                    1 - BAR
    //                    2 - TRI
    //                    3 - QUAD
    //                    4 - TET
    //                    5 - PYRAMID
    //                    6 - PRISM
    //                    7 - HEX
    //
    //  See also obtain_elemdim
    //  shapeid = (etype>>5)&0b111
    // obtain_elemshape - Decode an element geometric shape from etype
    //
    //    shapeid = obtain_elemshape(etype)
    //
    //  RETURN
    //  ------
    //    shapeid:    Integer type of different geometry shapes:
    //                    1 - BAR
    //                    2 - TRI
    //                    3 - QUAD
    //                    4 - TET
    //                    5 - PYRAMID
    //                    6 - PRISM
    //                    7 - HEX
    //
    //  See also obtain_elemdim
    //  shapeid = (etype>>5)&0b111
    flag = ((b_sfe->etypes[0] >> 5 & 7) == (b_sfe->etypes[1] >> 5 & 7));
  }
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(flag, "invalid element combination");
  if ((facetid >= 1) && (facetid <= obtain_facets(b_sfe->etypes[0]))) {
    flag = true;
  } else {
    flag = false;
  }
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(flag, "facet ID out of range");
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(xs.size(0) == iv[b_sfe->etypes[1] - 1], "unmatched nnodes");
  obtain_facets(b_sfe->etypes[1], facetid, &geom_bnd_etype, lids_data,
                &lids_size);
  b_sfe->xswork.set_size(lids_size, xs.size(1));
  for (int32_T i{0}; i < lids_size; i++) {
    int32_T b_i;
    b_i = xs.size(1);
    for (int32_T d{0}; d < b_i; d++) {
      b_sfe->xswork[d + b_sfe->xswork.size(1) * i] =
          xs[d + xs.size(1) * (lids_data[i] - 1)];
    }
  }
  b_sfe->facetid = facetid;
  //  remain already-initialized stage
  sfe_init(b_sfe, b_sfe->xswork);
}

void sfe_bnd_init12(SfeObject *b_sfe, int8_T facetid,
                    const ::coder::array<real_T, 2U> &xs,
                    const ::coder::array<real_T, 2U> &)
{
  int32_T lids_size;
  int16_T lids_data[50];
  uint8_T geom_bnd_etype;
  boolean_T flag;
  // sfe_bnd_init - Initialize an SfeObject instance for boundary element
  //
  //    sfe = sfe_bnd_init(sfe, etypes, facetid, xs)
  //    sfe = sfe_bnd_init(sfe, etypes, facetid, xs, natcoords)
  //    sfe = sfe_bnd_init(sfe, etypes, facetid, xs, qd)
  //    sfe = sfe_bnd_init(sfe, etypes, facetid, xs, qd, userquad)
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An SfeObject instance
  //    etypes:     Element type(s), which can be a 2-vector, scalar, or [].
  //                A 2-vector specifies the solution and geometric element
  //                types, and it supports iso-, sub- and super-parametric
  //                elements. If two element types are equal, then one can use a
  //                scalar. An empty array ([]) instructs the function to reuse
  //                the element type and the tabulation stored in the `sfe`
  //                object (typically from a previous call).
  //    facetid:    Local facet ID, which defines the edge (2D) or face (3D) on
  //                which we will initialize the boundary element. Note that we
  //                use CGNS numbering regarding node and facet ordering.
  //    xs:         Physical coordinates of the element, which is defined in
  //                the geometric space.
  //    qd:         Quadrature degree. A zero value indicates the default
  //    quadrature
  //                rules based on the element types. If -1 is passed in, then
  //                the code will assume user-provided quadrature rule
  //                information
  //    userquad:   This field is only accessed if qd==-1. If provided, then
  //                userquad must be a nqp-by-(1+dim-1) array, where the first
  //                column vector is the quadrature weights while the rest
  //                entries are their corresponding quadrature points in the
  //                reference element. Note that the quadrature points defined
  //                in the the facet is one dimension less than that in the
  //                volume element.
  //
  //  In particular, the user can pass in specific natural coordinates on which
  //  we will compute shape functions and derivatives. In this situation, we
  //  will skip the computation of Jacobian.
  //
  //    natcoords:  List of natural coordinates defined by the user
  //
  //  See also sfe_init, obtain_facets
  //  pre-initialized
  //  check if valid combo
  flag = (b_sfe->etypes[0] == b_sfe->etypes[1]);
  if (!flag) {
    //  then the shapes must match
    // obtain_elemshape - Decode an element geometric shape from etype
    //
    //    shapeid = obtain_elemshape(etype)
    //
    //  RETURN
    //  ------
    //    shapeid:    Integer type of different geometry shapes:
    //                    1 - BAR
    //                    2 - TRI
    //                    3 - QUAD
    //                    4 - TET
    //                    5 - PYRAMID
    //                    6 - PRISM
    //                    7 - HEX
    //
    //  See also obtain_elemdim
    //  shapeid = (etype>>5)&0b111
    // obtain_elemshape - Decode an element geometric shape from etype
    //
    //    shapeid = obtain_elemshape(etype)
    //
    //  RETURN
    //  ------
    //    shapeid:    Integer type of different geometry shapes:
    //                    1 - BAR
    //                    2 - TRI
    //                    3 - QUAD
    //                    4 - TET
    //                    5 - PYRAMID
    //                    6 - PRISM
    //                    7 - HEX
    //
    //  See also obtain_elemdim
    //  shapeid = (etype>>5)&0b111
    flag = ((b_sfe->etypes[0] >> 5 & 7) == (b_sfe->etypes[1] >> 5 & 7));
  }
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(flag, "invalid element combination");
  if ((facetid >= 1) && (facetid <= obtain_facets(b_sfe->etypes[0]))) {
    flag = true;
  } else {
    flag = false;
  }
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(flag, "facet ID out of range");
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(xs.size(0) == iv[b_sfe->etypes[1] - 1], "unmatched nnodes");
  obtain_facets(b_sfe->etypes[1], facetid, &geom_bnd_etype, lids_data,
                &lids_size);
  b_sfe->xswork.set_size(lids_size, xs.size(1));
  for (int32_T i{0}; i < lids_size; i++) {
    int32_T b_i;
    b_i = xs.size(1);
    for (int32_T d{0}; d < b_i; d++) {
      b_sfe->xswork[d + b_sfe->xswork.size(1) * i] =
          xs[d + xs.size(1) * (lids_data[i] - 1)];
    }
  }
  b_sfe->facetid = facetid;
  //  remain already-initialized stage
  b_sfe_init(b_sfe, b_sfe->xswork);
}

void sfe_bnd_init2(SfeObject *b_sfe, int32_T etypes, int8_T facetid,
                   const ::coder::array<real_T, 2U> &xs,
                   int32_T qd_or_natcoords)
{
  int32_T lids_size;
  int16_T lids_data[50];
  uint8_T geom_bnd_etype;
  boolean_T cond;
  // sfe_bnd_init - Initialize an SfeObject instance for boundary element
  //
  //    sfe = sfe_bnd_init(sfe, etypes, facetid, xs)
  //    sfe = sfe_bnd_init(sfe, etypes, facetid, xs, natcoords)
  //    sfe = sfe_bnd_init(sfe, etypes, facetid, xs, qd)
  //    sfe = sfe_bnd_init(sfe, etypes, facetid, xs, qd, userquad)
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An SfeObject instance
  //    etypes:     Element type(s), which can be a 2-vector, scalar, or [].
  //                A 2-vector specifies the solution and geometric element
  //                types, and it supports iso-, sub- and super-parametric
  //                elements. If two element types are equal, then one can use a
  //                scalar. An empty array ([]) instructs the function to reuse
  //                the element type and the tabulation stored in the `sfe`
  //                object (typically from a previous call).
  //    facetid:    Local facet ID, which defines the edge (2D) or face (3D) on
  //                which we will initialize the boundary element. Note that we
  //                use CGNS numbering regarding node and facet ordering.
  //    xs:         Physical coordinates of the element, which is defined in
  //                the geometric space.
  //    qd:         Quadrature degree. A zero value indicates the default
  //    quadrature
  //                rules based on the element types. If -1 is passed in, then
  //                the code will assume user-provided quadrature rule
  //                information
  //    userquad:   This field is only accessed if qd==-1. If provided, then
  //                userquad must be a nqp-by-(1+dim-1) array, where the first
  //                column vector is the quadrature weights while the rest
  //                entries are their corresponding quadrature points in the
  //                reference element. Note that the quadrature points defined
  //                in the the facet is one dimension less than that in the
  //                volume element.
  //
  //  In particular, the user can pass in specific natural coordinates on which
  //  we will compute shape functions and derivatives. In this situation, we
  //  will skip the computation of Jacobian.
  //
  //    natcoords:  List of natural coordinates defined by the user
  //
  //  See also sfe_init, obtain_facets
  //  check if valid combo
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(true, "invalid element combination");
  if ((facetid >= 1) && (facetid <= obtain_facets(etypes))) {
    cond = true;
  } else {
    cond = false;
  }
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(cond, "facet ID out of range");
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(xs.size(0) == iv[etypes - 1], "unmatched nnodes");
  obtain_facets(etypes, facetid, &geom_bnd_etype, lids_data, &lids_size);
  b_sfe->xswork.set_size(lids_size, xs.size(1));
  for (int32_T i{0}; i < lids_size; i++) {
    int32_T b_i;
    b_i = xs.size(1);
    for (int32_T d{0}; d < b_i; d++) {
      b_sfe->xswork[d + b_sfe->xswork.size(1) * i] =
          xs[d + xs.size(1) * (lids_data[i] - 1)];
    }
  }
  uint8_T b_trial_bnd_etype[2];
  uint8_T trial_bnd_etype;
  b_sfe->facetid = facetid;
  trial_bnd_etype = obtain_facets(etypes, facetid);
  b_trial_bnd_etype[0] = trial_bnd_etype;
  b_trial_bnd_etype[1] = geom_bnd_etype;
  sfe_init(b_sfe, b_trial_bnd_etype, b_sfe->xswork, qd_or_natcoords);
  //  reset to volume cell types
  b_sfe->etypes[0] = etypes;
  b_sfe->etypes[1] = etypes;
  //  NOTE the number of nodes in sfe is based on facet elements
}

void sfe_bnd_init3(SfeObject *b_sfe, int32_T etypes, int8_T facetid,
                   const ::coder::array<real_T, 2U> &xs)
{
  int32_T lids_size;
  int16_T lids_data[50];
  uint8_T geom_bnd_etype;
  boolean_T cond;
  // sfe_bnd_init - Initialize an SfeObject instance for boundary element
  //
  //    sfe = sfe_bnd_init(sfe, etypes, facetid, xs)
  //    sfe = sfe_bnd_init(sfe, etypes, facetid, xs, natcoords)
  //    sfe = sfe_bnd_init(sfe, etypes, facetid, xs, qd)
  //    sfe = sfe_bnd_init(sfe, etypes, facetid, xs, qd, userquad)
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An SfeObject instance
  //    etypes:     Element type(s), which can be a 2-vector, scalar, or [].
  //                A 2-vector specifies the solution and geometric element
  //                types, and it supports iso-, sub- and super-parametric
  //                elements. If two element types are equal, then one can use a
  //                scalar. An empty array ([]) instructs the function to reuse
  //                the element type and the tabulation stored in the `sfe`
  //                object (typically from a previous call).
  //    facetid:    Local facet ID, which defines the edge (2D) or face (3D) on
  //                which we will initialize the boundary element. Note that we
  //                use CGNS numbering regarding node and facet ordering.
  //    xs:         Physical coordinates of the element, which is defined in
  //                the geometric space.
  //    qd:         Quadrature degree. A zero value indicates the default
  //    quadrature
  //                rules based on the element types. If -1 is passed in, then
  //                the code will assume user-provided quadrature rule
  //                information
  //    userquad:   This field is only accessed if qd==-1. If provided, then
  //                userquad must be a nqp-by-(1+dim-1) array, where the first
  //                column vector is the quadrature weights while the rest
  //                entries are their corresponding quadrature points in the
  //                reference element. Note that the quadrature points defined
  //                in the the facet is one dimension less than that in the
  //                volume element.
  //
  //  In particular, the user can pass in specific natural coordinates on which
  //  we will compute shape functions and derivatives. In this situation, we
  //  will skip the computation of Jacobian.
  //
  //    natcoords:  List of natural coordinates defined by the user
  //
  //  See also sfe_init, obtain_facets
  //  check if valid combo
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(true, "invalid element combination");
  if ((facetid >= 1) && (facetid <= obtain_facets(etypes))) {
    cond = true;
  } else {
    cond = false;
  }
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(cond, "facet ID out of range");
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(xs.size(0) == iv[etypes - 1], "unmatched nnodes");
  obtain_facets(etypes, facetid, &geom_bnd_etype, lids_data, &lids_size);
  b_sfe->xswork.set_size(lids_size, xs.size(1));
  for (int32_T i{0}; i < lids_size; i++) {
    int32_T b_i;
    b_i = xs.size(1);
    for (int32_T d{0}; d < b_i; d++) {
      b_sfe->xswork[d + b_sfe->xswork.size(1) * i] =
          xs[d + xs.size(1) * (lids_data[i] - 1)];
    }
  }
  uint8_T b_trial_bnd_etype[2];
  uint8_T trial_bnd_etype;
  b_sfe->facetid = facetid;
  trial_bnd_etype = obtain_facets(etypes, facetid);
  b_trial_bnd_etype[0] = trial_bnd_etype;
  b_trial_bnd_etype[1] = geom_bnd_etype;
  sfe_init(b_sfe, b_trial_bnd_etype, b_sfe->xswork);
  //  reset to volume cell types
  b_sfe->etypes[0] = etypes;
  b_sfe->etypes[1] = etypes;
  //  NOTE the number of nodes in sfe is based on facet elements
}

void sfe_bnd_init4(SfeObject *b_sfe, int32_T etypes, int8_T facetid,
                   const ::coder::array<real_T, 2U> &xs,
                   const ::coder::array<real_T, 2U> &qd_or_natcoords)
{
  int32_T lids_size;
  int16_T lids_data[50];
  uint8_T geom_bnd_etype;
  boolean_T cond;
  // sfe_bnd_init - Initialize an SfeObject instance for boundary element
  //
  //    sfe = sfe_bnd_init(sfe, etypes, facetid, xs)
  //    sfe = sfe_bnd_init(sfe, etypes, facetid, xs, natcoords)
  //    sfe = sfe_bnd_init(sfe, etypes, facetid, xs, qd)
  //    sfe = sfe_bnd_init(sfe, etypes, facetid, xs, qd, userquad)
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An SfeObject instance
  //    etypes:     Element type(s), which can be a 2-vector, scalar, or [].
  //                A 2-vector specifies the solution and geometric element
  //                types, and it supports iso-, sub- and super-parametric
  //                elements. If two element types are equal, then one can use a
  //                scalar. An empty array ([]) instructs the function to reuse
  //                the element type and the tabulation stored in the `sfe`
  //                object (typically from a previous call).
  //    facetid:    Local facet ID, which defines the edge (2D) or face (3D) on
  //                which we will initialize the boundary element. Note that we
  //                use CGNS numbering regarding node and facet ordering.
  //    xs:         Physical coordinates of the element, which is defined in
  //                the geometric space.
  //    qd:         Quadrature degree. A zero value indicates the default
  //    quadrature
  //                rules based on the element types. If -1 is passed in, then
  //                the code will assume user-provided quadrature rule
  //                information
  //    userquad:   This field is only accessed if qd==-1. If provided, then
  //                userquad must be a nqp-by-(1+dim-1) array, where the first
  //                column vector is the quadrature weights while the rest
  //                entries are their corresponding quadrature points in the
  //                reference element. Note that the quadrature points defined
  //                in the the facet is one dimension less than that in the
  //                volume element.
  //
  //  In particular, the user can pass in specific natural coordinates on which
  //  we will compute shape functions and derivatives. In this situation, we
  //  will skip the computation of Jacobian.
  //
  //    natcoords:  List of natural coordinates defined by the user
  //
  //  See also sfe_init, obtain_facets
  //  check if valid combo
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(true, "invalid element combination");
  if ((facetid >= 1) && (facetid <= obtain_facets(etypes))) {
    cond = true;
  } else {
    cond = false;
  }
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(cond, "facet ID out of range");
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(xs.size(0) == iv[etypes - 1], "unmatched nnodes");
  obtain_facets(etypes, facetid, &geom_bnd_etype, lids_data, &lids_size);
  b_sfe->xswork.set_size(lids_size, xs.size(1));
  for (int32_T i{0}; i < lids_size; i++) {
    int32_T b_i;
    b_i = xs.size(1);
    for (int32_T d{0}; d < b_i; d++) {
      b_sfe->xswork[d + b_sfe->xswork.size(1) * i] =
          xs[d + xs.size(1) * (lids_data[i] - 1)];
    }
  }
  uint8_T b_trial_bnd_etype[2];
  uint8_T trial_bnd_etype;
  b_sfe->facetid = facetid;
  trial_bnd_etype = obtain_facets(etypes, facetid);
  b_trial_bnd_etype[0] = trial_bnd_etype;
  b_trial_bnd_etype[1] = geom_bnd_etype;
  sfe_init(b_sfe, b_trial_bnd_etype, b_sfe->xswork, qd_or_natcoords);
  //  reset to volume cell types
  b_sfe->etypes[0] = etypes;
  b_sfe->etypes[1] = etypes;
  //  NOTE the number of nodes in sfe is based on facet elements
}

void sfe_bnd_init5(SfeObject *b_sfe, const int32_T etypes[2], int8_T facetid,
                   const ::coder::array<real_T, 2U> &xs,
                   int32_T qd_or_natcoords,
                   const ::coder::array<real_T, 2U> &varargin_1)
{
  int32_T geom_etype;
  int32_T lids_size;
  int16_T lids_data[50];
  uint8_T geom_bnd_etype;
  boolean_T flag;
  // sfe_bnd_init - Initialize an SfeObject instance for boundary element
  //
  //    sfe = sfe_bnd_init(sfe, etypes, facetid, xs)
  //    sfe = sfe_bnd_init(sfe, etypes, facetid, xs, natcoords)
  //    sfe = sfe_bnd_init(sfe, etypes, facetid, xs, qd)
  //    sfe = sfe_bnd_init(sfe, etypes, facetid, xs, qd, userquad)
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An SfeObject instance
  //    etypes:     Element type(s), which can be a 2-vector, scalar, or [].
  //                A 2-vector specifies the solution and geometric element
  //                types, and it supports iso-, sub- and super-parametric
  //                elements. If two element types are equal, then one can use a
  //                scalar. An empty array ([]) instructs the function to reuse
  //                the element type and the tabulation stored in the `sfe`
  //                object (typically from a previous call).
  //    facetid:    Local facet ID, which defines the edge (2D) or face (3D) on
  //                which we will initialize the boundary element. Note that we
  //                use CGNS numbering regarding node and facet ordering.
  //    xs:         Physical coordinates of the element, which is defined in
  //                the geometric space.
  //    qd:         Quadrature degree. A zero value indicates the default
  //    quadrature
  //                rules based on the element types. If -1 is passed in, then
  //                the code will assume user-provided quadrature rule
  //                information
  //    userquad:   This field is only accessed if qd==-1. If provided, then
  //                userquad must be a nqp-by-(1+dim-1) array, where the first
  //                column vector is the quadrature weights while the rest
  //                entries are their corresponding quadrature points in the
  //                reference element. Note that the quadrature points defined
  //                in the the facet is one dimension less than that in the
  //                volume element.
  //
  //  In particular, the user can pass in specific natural coordinates on which
  //  we will compute shape functions and derivatives. In this situation, we
  //  will skip the computation of Jacobian.
  //
  //    natcoords:  List of natural coordinates defined by the user
  //
  //  See also sfe_init, obtain_facets
  if (etypes[1] == 0) {
    geom_etype = etypes[0];
  } else {
    geom_etype = etypes[1];
  }
  //  check if valid combo
  flag = (etypes[0] == geom_etype);
  if (!flag) {
    //  then the shapes must match
    // obtain_elemshape - Decode an element geometric shape from etype
    //
    //    shapeid = obtain_elemshape(etype)
    //
    //  RETURN
    //  ------
    //    shapeid:    Integer type of different geometry shapes:
    //                    1 - BAR
    //                    2 - TRI
    //                    3 - QUAD
    //                    4 - TET
    //                    5 - PYRAMID
    //                    6 - PRISM
    //                    7 - HEX
    //
    //  See also obtain_elemdim
    //  shapeid = (etype>>5)&0b111
    // obtain_elemshape - Decode an element geometric shape from etype
    //
    //    shapeid = obtain_elemshape(etype)
    //
    //  RETURN
    //  ------
    //    shapeid:    Integer type of different geometry shapes:
    //                    1 - BAR
    //                    2 - TRI
    //                    3 - QUAD
    //                    4 - TET
    //                    5 - PYRAMID
    //                    6 - PRISM
    //                    7 - HEX
    //
    //  See also obtain_elemdim
    //  shapeid = (etype>>5)&0b111
    flag = ((etypes[0] >> 5 & 7) == (geom_etype >> 5 & 7));
  }
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(flag, "invalid element combination");
  if ((facetid >= 1) && (facetid <= obtain_facets(etypes[0]))) {
    flag = true;
  } else {
    flag = false;
  }
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(flag, "facet ID out of range");
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(xs.size(0) == iv[geom_etype - 1], "unmatched nnodes");
  obtain_facets(geom_etype, facetid, &geom_bnd_etype, lids_data, &lids_size);
  b_sfe->xswork.set_size(lids_size, xs.size(1));
  for (int32_T i{0}; i < lids_size; i++) {
    int32_T b_i;
    b_i = xs.size(1);
    for (int32_T d{0}; d < b_i; d++) {
      b_sfe->xswork[d + b_sfe->xswork.size(1) * i] =
          xs[d + xs.size(1) * (lids_data[i] - 1)];
    }
  }
  uint8_T b_trial_bnd_etype[2];
  uint8_T trial_bnd_etype;
  b_sfe->facetid = facetid;
  trial_bnd_etype = obtain_facets(etypes[0], facetid);
  b_trial_bnd_etype[0] = trial_bnd_etype;
  b_trial_bnd_etype[1] = geom_bnd_etype;
  sfe_init(b_sfe, b_trial_bnd_etype, b_sfe->xswork, qd_or_natcoords,
           varargin_1);
  //  reset to volume cell types
  b_sfe->etypes[0] = etypes[0];
  b_sfe->etypes[1] = geom_etype;
  //  NOTE the number of nodes in sfe is based on facet elements
}

void sfe_bnd_init6(SfeObject *b_sfe, const int32_T etypes[2], int8_T facetid,
                   const ::coder::array<real_T, 2U> &xs,
                   int32_T qd_or_natcoords)
{
  int32_T geom_etype;
  int32_T lids_size;
  int16_T lids_data[50];
  uint8_T geom_bnd_etype;
  boolean_T flag;
  // sfe_bnd_init - Initialize an SfeObject instance for boundary element
  //
  //    sfe = sfe_bnd_init(sfe, etypes, facetid, xs)
  //    sfe = sfe_bnd_init(sfe, etypes, facetid, xs, natcoords)
  //    sfe = sfe_bnd_init(sfe, etypes, facetid, xs, qd)
  //    sfe = sfe_bnd_init(sfe, etypes, facetid, xs, qd, userquad)
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An SfeObject instance
  //    etypes:     Element type(s), which can be a 2-vector, scalar, or [].
  //                A 2-vector specifies the solution and geometric element
  //                types, and it supports iso-, sub- and super-parametric
  //                elements. If two element types are equal, then one can use a
  //                scalar. An empty array ([]) instructs the function to reuse
  //                the element type and the tabulation stored in the `sfe`
  //                object (typically from a previous call).
  //    facetid:    Local facet ID, which defines the edge (2D) or face (3D) on
  //                which we will initialize the boundary element. Note that we
  //                use CGNS numbering regarding node and facet ordering.
  //    xs:         Physical coordinates of the element, which is defined in
  //                the geometric space.
  //    qd:         Quadrature degree. A zero value indicates the default
  //    quadrature
  //                rules based on the element types. If -1 is passed in, then
  //                the code will assume user-provided quadrature rule
  //                information
  //    userquad:   This field is only accessed if qd==-1. If provided, then
  //                userquad must be a nqp-by-(1+dim-1) array, where the first
  //                column vector is the quadrature weights while the rest
  //                entries are their corresponding quadrature points in the
  //                reference element. Note that the quadrature points defined
  //                in the the facet is one dimension less than that in the
  //                volume element.
  //
  //  In particular, the user can pass in specific natural coordinates on which
  //  we will compute shape functions and derivatives. In this situation, we
  //  will skip the computation of Jacobian.
  //
  //    natcoords:  List of natural coordinates defined by the user
  //
  //  See also sfe_init, obtain_facets
  if (etypes[1] == 0) {
    geom_etype = etypes[0];
  } else {
    geom_etype = etypes[1];
  }
  //  check if valid combo
  flag = (etypes[0] == geom_etype);
  if (!flag) {
    //  then the shapes must match
    // obtain_elemshape - Decode an element geometric shape from etype
    //
    //    shapeid = obtain_elemshape(etype)
    //
    //  RETURN
    //  ------
    //    shapeid:    Integer type of different geometry shapes:
    //                    1 - BAR
    //                    2 - TRI
    //                    3 - QUAD
    //                    4 - TET
    //                    5 - PYRAMID
    //                    6 - PRISM
    //                    7 - HEX
    //
    //  See also obtain_elemdim
    //  shapeid = (etype>>5)&0b111
    // obtain_elemshape - Decode an element geometric shape from etype
    //
    //    shapeid = obtain_elemshape(etype)
    //
    //  RETURN
    //  ------
    //    shapeid:    Integer type of different geometry shapes:
    //                    1 - BAR
    //                    2 - TRI
    //                    3 - QUAD
    //                    4 - TET
    //                    5 - PYRAMID
    //                    6 - PRISM
    //                    7 - HEX
    //
    //  See also obtain_elemdim
    //  shapeid = (etype>>5)&0b111
    flag = ((etypes[0] >> 5 & 7) == (geom_etype >> 5 & 7));
  }
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(flag, "invalid element combination");
  if ((facetid >= 1) && (facetid <= obtain_facets(etypes[0]))) {
    flag = true;
  } else {
    flag = false;
  }
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(flag, "facet ID out of range");
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(xs.size(0) == iv[geom_etype - 1], "unmatched nnodes");
  obtain_facets(geom_etype, facetid, &geom_bnd_etype, lids_data, &lids_size);
  b_sfe->xswork.set_size(lids_size, xs.size(1));
  for (int32_T i{0}; i < lids_size; i++) {
    int32_T b_i;
    b_i = xs.size(1);
    for (int32_T d{0}; d < b_i; d++) {
      b_sfe->xswork[d + b_sfe->xswork.size(1) * i] =
          xs[d + xs.size(1) * (lids_data[i] - 1)];
    }
  }
  uint8_T b_trial_bnd_etype[2];
  uint8_T trial_bnd_etype;
  b_sfe->facetid = facetid;
  trial_bnd_etype = obtain_facets(etypes[0], facetid);
  b_trial_bnd_etype[0] = trial_bnd_etype;
  b_trial_bnd_etype[1] = geom_bnd_etype;
  sfe_init(b_sfe, b_trial_bnd_etype, b_sfe->xswork, qd_or_natcoords);
  //  reset to volume cell types
  b_sfe->etypes[0] = etypes[0];
  b_sfe->etypes[1] = geom_etype;
  //  NOTE the number of nodes in sfe is based on facet elements
}

void sfe_bnd_init7(SfeObject *b_sfe, const int32_T etypes[2], int8_T facetid,
                   const ::coder::array<real_T, 2U> &xs)
{
  int32_T geom_etype;
  int32_T lids_size;
  int16_T lids_data[50];
  uint8_T geom_bnd_etype;
  boolean_T flag;
  // sfe_bnd_init - Initialize an SfeObject instance for boundary element
  //
  //    sfe = sfe_bnd_init(sfe, etypes, facetid, xs)
  //    sfe = sfe_bnd_init(sfe, etypes, facetid, xs, natcoords)
  //    sfe = sfe_bnd_init(sfe, etypes, facetid, xs, qd)
  //    sfe = sfe_bnd_init(sfe, etypes, facetid, xs, qd, userquad)
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An SfeObject instance
  //    etypes:     Element type(s), which can be a 2-vector, scalar, or [].
  //                A 2-vector specifies the solution and geometric element
  //                types, and it supports iso-, sub- and super-parametric
  //                elements. If two element types are equal, then one can use a
  //                scalar. An empty array ([]) instructs the function to reuse
  //                the element type and the tabulation stored in the `sfe`
  //                object (typically from a previous call).
  //    facetid:    Local facet ID, which defines the edge (2D) or face (3D) on
  //                which we will initialize the boundary element. Note that we
  //                use CGNS numbering regarding node and facet ordering.
  //    xs:         Physical coordinates of the element, which is defined in
  //                the geometric space.
  //    qd:         Quadrature degree. A zero value indicates the default
  //    quadrature
  //                rules based on the element types. If -1 is passed in, then
  //                the code will assume user-provided quadrature rule
  //                information
  //    userquad:   This field is only accessed if qd==-1. If provided, then
  //                userquad must be a nqp-by-(1+dim-1) array, where the first
  //                column vector is the quadrature weights while the rest
  //                entries are their corresponding quadrature points in the
  //                reference element. Note that the quadrature points defined
  //                in the the facet is one dimension less than that in the
  //                volume element.
  //
  //  In particular, the user can pass in specific natural coordinates on which
  //  we will compute shape functions and derivatives. In this situation, we
  //  will skip the computation of Jacobian.
  //
  //    natcoords:  List of natural coordinates defined by the user
  //
  //  See also sfe_init, obtain_facets
  if (etypes[1] == 0) {
    geom_etype = etypes[0];
  } else {
    geom_etype = etypes[1];
  }
  //  check if valid combo
  flag = (etypes[0] == geom_etype);
  if (!flag) {
    //  then the shapes must match
    // obtain_elemshape - Decode an element geometric shape from etype
    //
    //    shapeid = obtain_elemshape(etype)
    //
    //  RETURN
    //  ------
    //    shapeid:    Integer type of different geometry shapes:
    //                    1 - BAR
    //                    2 - TRI
    //                    3 - QUAD
    //                    4 - TET
    //                    5 - PYRAMID
    //                    6 - PRISM
    //                    7 - HEX
    //
    //  See also obtain_elemdim
    //  shapeid = (etype>>5)&0b111
    // obtain_elemshape - Decode an element geometric shape from etype
    //
    //    shapeid = obtain_elemshape(etype)
    //
    //  RETURN
    //  ------
    //    shapeid:    Integer type of different geometry shapes:
    //                    1 - BAR
    //                    2 - TRI
    //                    3 - QUAD
    //                    4 - TET
    //                    5 - PYRAMID
    //                    6 - PRISM
    //                    7 - HEX
    //
    //  See also obtain_elemdim
    //  shapeid = (etype>>5)&0b111
    flag = ((etypes[0] >> 5 & 7) == (geom_etype >> 5 & 7));
  }
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(flag, "invalid element combination");
  if ((facetid >= 1) && (facetid <= obtain_facets(etypes[0]))) {
    flag = true;
  } else {
    flag = false;
  }
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(flag, "facet ID out of range");
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(xs.size(0) == iv[geom_etype - 1], "unmatched nnodes");
  obtain_facets(geom_etype, facetid, &geom_bnd_etype, lids_data, &lids_size);
  b_sfe->xswork.set_size(lids_size, xs.size(1));
  for (int32_T i{0}; i < lids_size; i++) {
    int32_T b_i;
    b_i = xs.size(1);
    for (int32_T d{0}; d < b_i; d++) {
      b_sfe->xswork[d + b_sfe->xswork.size(1) * i] =
          xs[d + xs.size(1) * (lids_data[i] - 1)];
    }
  }
  uint8_T b_trial_bnd_etype[2];
  uint8_T trial_bnd_etype;
  b_sfe->facetid = facetid;
  trial_bnd_etype = obtain_facets(etypes[0], facetid);
  b_trial_bnd_etype[0] = trial_bnd_etype;
  b_trial_bnd_etype[1] = geom_bnd_etype;
  sfe_init(b_sfe, b_trial_bnd_etype, b_sfe->xswork);
  //  reset to volume cell types
  b_sfe->etypes[0] = etypes[0];
  b_sfe->etypes[1] = geom_etype;
  //  NOTE the number of nodes in sfe is based on facet elements
}

void sfe_bnd_init8(SfeObject *b_sfe, const int32_T etypes[2], int8_T facetid,
                   const ::coder::array<real_T, 2U> &xs,
                   const ::coder::array<real_T, 2U> &qd_or_natcoords)
{
  int32_T geom_etype;
  int32_T lids_size;
  int16_T lids_data[50];
  uint8_T geom_bnd_etype;
  boolean_T flag;
  // sfe_bnd_init - Initialize an SfeObject instance for boundary element
  //
  //    sfe = sfe_bnd_init(sfe, etypes, facetid, xs)
  //    sfe = sfe_bnd_init(sfe, etypes, facetid, xs, natcoords)
  //    sfe = sfe_bnd_init(sfe, etypes, facetid, xs, qd)
  //    sfe = sfe_bnd_init(sfe, etypes, facetid, xs, qd, userquad)
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An SfeObject instance
  //    etypes:     Element type(s), which can be a 2-vector, scalar, or [].
  //                A 2-vector specifies the solution and geometric element
  //                types, and it supports iso-, sub- and super-parametric
  //                elements. If two element types are equal, then one can use a
  //                scalar. An empty array ([]) instructs the function to reuse
  //                the element type and the tabulation stored in the `sfe`
  //                object (typically from a previous call).
  //    facetid:    Local facet ID, which defines the edge (2D) or face (3D) on
  //                which we will initialize the boundary element. Note that we
  //                use CGNS numbering regarding node and facet ordering.
  //    xs:         Physical coordinates of the element, which is defined in
  //                the geometric space.
  //    qd:         Quadrature degree. A zero value indicates the default
  //    quadrature
  //                rules based on the element types. If -1 is passed in, then
  //                the code will assume user-provided quadrature rule
  //                information
  //    userquad:   This field is only accessed if qd==-1. If provided, then
  //                userquad must be a nqp-by-(1+dim-1) array, where the first
  //                column vector is the quadrature weights while the rest
  //                entries are their corresponding quadrature points in the
  //                reference element. Note that the quadrature points defined
  //                in the the facet is one dimension less than that in the
  //                volume element.
  //
  //  In particular, the user can pass in specific natural coordinates on which
  //  we will compute shape functions and derivatives. In this situation, we
  //  will skip the computation of Jacobian.
  //
  //    natcoords:  List of natural coordinates defined by the user
  //
  //  See also sfe_init, obtain_facets
  if (etypes[1] == 0) {
    geom_etype = etypes[0];
  } else {
    geom_etype = etypes[1];
  }
  //  check if valid combo
  flag = (etypes[0] == geom_etype);
  if (!flag) {
    //  then the shapes must match
    // obtain_elemshape - Decode an element geometric shape from etype
    //
    //    shapeid = obtain_elemshape(etype)
    //
    //  RETURN
    //  ------
    //    shapeid:    Integer type of different geometry shapes:
    //                    1 - BAR
    //                    2 - TRI
    //                    3 - QUAD
    //                    4 - TET
    //                    5 - PYRAMID
    //                    6 - PRISM
    //                    7 - HEX
    //
    //  See also obtain_elemdim
    //  shapeid = (etype>>5)&0b111
    // obtain_elemshape - Decode an element geometric shape from etype
    //
    //    shapeid = obtain_elemshape(etype)
    //
    //  RETURN
    //  ------
    //    shapeid:    Integer type of different geometry shapes:
    //                    1 - BAR
    //                    2 - TRI
    //                    3 - QUAD
    //                    4 - TET
    //                    5 - PYRAMID
    //                    6 - PRISM
    //                    7 - HEX
    //
    //  See also obtain_elemdim
    //  shapeid = (etype>>5)&0b111
    flag = ((etypes[0] >> 5 & 7) == (geom_etype >> 5 & 7));
  }
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(flag, "invalid element combination");
  if ((facetid >= 1) && (facetid <= obtain_facets(etypes[0]))) {
    flag = true;
  } else {
    flag = false;
  }
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(flag, "facet ID out of range");
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(xs.size(0) == iv[geom_etype - 1], "unmatched nnodes");
  obtain_facets(geom_etype, facetid, &geom_bnd_etype, lids_data, &lids_size);
  b_sfe->xswork.set_size(lids_size, xs.size(1));
  for (int32_T i{0}; i < lids_size; i++) {
    int32_T b_i;
    b_i = xs.size(1);
    for (int32_T d{0}; d < b_i; d++) {
      b_sfe->xswork[d + b_sfe->xswork.size(1) * i] =
          xs[d + xs.size(1) * (lids_data[i] - 1)];
    }
  }
  uint8_T b_trial_bnd_etype[2];
  uint8_T trial_bnd_etype;
  b_sfe->facetid = facetid;
  trial_bnd_etype = obtain_facets(etypes[0], facetid);
  b_trial_bnd_etype[0] = trial_bnd_etype;
  b_trial_bnd_etype[1] = geom_bnd_etype;
  sfe_init(b_sfe, b_trial_bnd_etype, b_sfe->xswork, qd_or_natcoords);
  //  reset to volume cell types
  b_sfe->etypes[0] = etypes[0];
  b_sfe->etypes[1] = geom_etype;
  //  NOTE the number of nodes in sfe is based on facet elements
}

void sfe_bnd_init9(SfeObject *b_sfe, int8_T facetid,
                   const ::coder::array<real_T, 2U> &xs, int32_T,
                   const ::coder::array<real_T, 2U> &)
{
  int32_T lids_size;
  int16_T lids_data[50];
  uint8_T geom_bnd_etype;
  boolean_T flag;
  // sfe_bnd_init - Initialize an SfeObject instance for boundary element
  //
  //    sfe = sfe_bnd_init(sfe, etypes, facetid, xs)
  //    sfe = sfe_bnd_init(sfe, etypes, facetid, xs, natcoords)
  //    sfe = sfe_bnd_init(sfe, etypes, facetid, xs, qd)
  //    sfe = sfe_bnd_init(sfe, etypes, facetid, xs, qd, userquad)
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An SfeObject instance
  //    etypes:     Element type(s), which can be a 2-vector, scalar, or [].
  //                A 2-vector specifies the solution and geometric element
  //                types, and it supports iso-, sub- and super-parametric
  //                elements. If two element types are equal, then one can use a
  //                scalar. An empty array ([]) instructs the function to reuse
  //                the element type and the tabulation stored in the `sfe`
  //                object (typically from a previous call).
  //    facetid:    Local facet ID, which defines the edge (2D) or face (3D) on
  //                which we will initialize the boundary element. Note that we
  //                use CGNS numbering regarding node and facet ordering.
  //    xs:         Physical coordinates of the element, which is defined in
  //                the geometric space.
  //    qd:         Quadrature degree. A zero value indicates the default
  //    quadrature
  //                rules based on the element types. If -1 is passed in, then
  //                the code will assume user-provided quadrature rule
  //                information
  //    userquad:   This field is only accessed if qd==-1. If provided, then
  //                userquad must be a nqp-by-(1+dim-1) array, where the first
  //                column vector is the quadrature weights while the rest
  //                entries are their corresponding quadrature points in the
  //                reference element. Note that the quadrature points defined
  //                in the the facet is one dimension less than that in the
  //                volume element.
  //
  //  In particular, the user can pass in specific natural coordinates on which
  //  we will compute shape functions and derivatives. In this situation, we
  //  will skip the computation of Jacobian.
  //
  //    natcoords:  List of natural coordinates defined by the user
  //
  //  See also sfe_init, obtain_facets
  //  pre-initialized
  //  check if valid combo
  flag = (b_sfe->etypes[0] == b_sfe->etypes[1]);
  if (!flag) {
    //  then the shapes must match
    // obtain_elemshape - Decode an element geometric shape from etype
    //
    //    shapeid = obtain_elemshape(etype)
    //
    //  RETURN
    //  ------
    //    shapeid:    Integer type of different geometry shapes:
    //                    1 - BAR
    //                    2 - TRI
    //                    3 - QUAD
    //                    4 - TET
    //                    5 - PYRAMID
    //                    6 - PRISM
    //                    7 - HEX
    //
    //  See also obtain_elemdim
    //  shapeid = (etype>>5)&0b111
    // obtain_elemshape - Decode an element geometric shape from etype
    //
    //    shapeid = obtain_elemshape(etype)
    //
    //  RETURN
    //  ------
    //    shapeid:    Integer type of different geometry shapes:
    //                    1 - BAR
    //                    2 - TRI
    //                    3 - QUAD
    //                    4 - TET
    //                    5 - PYRAMID
    //                    6 - PRISM
    //                    7 - HEX
    //
    //  See also obtain_elemdim
    //  shapeid = (etype>>5)&0b111
    flag = ((b_sfe->etypes[0] >> 5 & 7) == (b_sfe->etypes[1] >> 5 & 7));
  }
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(flag, "invalid element combination");
  if ((facetid >= 1) && (facetid <= obtain_facets(b_sfe->etypes[0]))) {
    flag = true;
  } else {
    flag = false;
  }
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(flag, "facet ID out of range");
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(xs.size(0) == iv[b_sfe->etypes[1] - 1], "unmatched nnodes");
  obtain_facets(b_sfe->etypes[1], facetid, &geom_bnd_etype, lids_data,
                &lids_size);
  b_sfe->xswork.set_size(lids_size, xs.size(1));
  for (int32_T i{0}; i < lids_size; i++) {
    int32_T b_i;
    b_i = xs.size(1);
    for (int32_T d{0}; d < b_i; d++) {
      b_sfe->xswork[d + b_sfe->xswork.size(1) * i] =
          xs[d + xs.size(1) * (lids_data[i] - 1)];
    }
  }
  b_sfe->facetid = facetid;
  //  remain already-initialized stage
  sfe_init(b_sfe, b_sfe->xswork);
}

void sfe_elem_dbc1(::coder::array<real_T, 2U> &elemmat,
                   ::coder::array<real_T, 1U> &load,
                   const ::coder::array<boolean_T, 1U> &dtags)
{
  int32_T n;
  // sfe_elem_dbc - Apply Dirichlet boundary conditions (DBC)
  //
  //    [elemmat, load] = sfe_elem_dbc(elemmat, load, dtags)
  //    [elemmat, load] = sfe_elem_dbc(elemmat, load, dtags, dvals)
  //    [elemmat, load] = sfe_elem_dbc(elemmat, load, dtags, dvals, gdofs)
  //
  //  PARAMETERS
  //  ----------
  //    element:    Local element matrix
  //    load:       Local load vector
  //    dtags:      Dirichlet boundary tags
  //    dvals:      Dirichlet boundary values (empty or omitted means zeros)
  //    gdofs:      Global DOF map (optional)
  //
  //  RETURNS
  //    element:    Upon successful return, its Dirichlet nodes are eliminated
  //    load:       Upon successful return, its values are updated due to the
  //                elimination of Dirichlet nodes
  //
  //  NOTES
  //  -----
  //  First, we apply DBC symmetrically in that the columns are also eliminated.
  //  Hence, we require the users to pass in the load vector.
  //
  //  Next, this routine supports both local and global Dirichlet tags and
  //  values. If gdofs is missing, then we assume that dtags and dvals have the
  //  same sizes of elemmat and load. On the other side, then we assume they are
  //  global vectors, and the global DOF map (gdofs, whose length is the same
  //  size of those in elemmat and load) will help access the proper values
  //  therein.
  //
  //  See also sfe_elem_stiff, sfe_elem_load
  n = elemmat.size(0) - 1;
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(load.size(0) == elemmat.size(0), "");
  for (int32_T i{0}; i <= n; i++) {
    if (dtags[i]) {
      int32_T b_i;
      //  not a dirichlet node
      for (int32_T j{0}; j <= n; j++) {
        elemmat[i + elemmat.size(1) * j] = 0.0;
      }
      b_i = elemmat.size(1);
      for (int32_T j{0}; j < b_i; j++) {
        elemmat[j + elemmat.size(1) * i] = 0.0;
      }
      elemmat[i + elemmat.size(1) * i] = 1.0;
      load[i] = 0.0;
    }
  }
}

void sfe_elem_dbc2(::coder::array<real_T, 2U> &elemmat,
                   ::coder::array<real_T, 1U> &load,
                   const ::coder::array<boolean_T, 1U> &dtags,
                   const ::coder::array<real_T, 1U> &dvals)
{
  int32_T n;
  // sfe_elem_dbc - Apply Dirichlet boundary conditions (DBC)
  //
  //    [elemmat, load] = sfe_elem_dbc(elemmat, load, dtags)
  //    [elemmat, load] = sfe_elem_dbc(elemmat, load, dtags, dvals)
  //    [elemmat, load] = sfe_elem_dbc(elemmat, load, dtags, dvals, gdofs)
  //
  //  PARAMETERS
  //  ----------
  //    element:    Local element matrix
  //    load:       Local load vector
  //    dtags:      Dirichlet boundary tags
  //    dvals:      Dirichlet boundary values (empty or omitted means zeros)
  //    gdofs:      Global DOF map (optional)
  //
  //  RETURNS
  //    element:    Upon successful return, its Dirichlet nodes are eliminated
  //    load:       Upon successful return, its values are updated due to the
  //                elimination of Dirichlet nodes
  //
  //  NOTES
  //  -----
  //  First, we apply DBC symmetrically in that the columns are also eliminated.
  //  Hence, we require the users to pass in the load vector.
  //
  //  Next, this routine supports both local and global Dirichlet tags and
  //  values. If gdofs is missing, then we assume that dtags and dvals have the
  //  same sizes of elemmat and load. On the other side, then we assume they are
  //  global vectors, and the global DOF map (gdofs, whose length is the same
  //  size of those in elemmat and load) will help access the proper values
  //  therein.
  //
  //  See also sfe_elem_stiff, sfe_elem_load
  n = elemmat.size(0) - 1;
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(load.size(0) == elemmat.size(0), "");
  for (int32_T i{0}; i <= n; i++) {
    if (dtags[i]) {
      real_T dv;
      int32_T b_i;
      //  not a dirichlet node
      dv = 0.0;
      if (dvals.size(0) != 0) {
        dv = dvals[i];
      }
      if (dv != 0.0) {
        for (int32_T j{0}; j <= n; j++) {
          load[j] = load[j] - elemmat[i + elemmat.size(1) * j] * dv;
          elemmat[i + elemmat.size(1) * j] = 0.0;
        }
      } else {
        for (int32_T j{0}; j <= n; j++) {
          elemmat[i + elemmat.size(1) * j] = 0.0;
        }
      }
      b_i = elemmat.size(1);
      for (int32_T j{0}; j < b_i; j++) {
        elemmat[j + elemmat.size(1) * i] = 0.0;
      }
      elemmat[i + elemmat.size(1) * i] = 1.0;
      load[i] = dv;
    }
  }
}

void sfe_elem_dbc3(::coder::array<real_T, 2U> &elemmat,
                   ::coder::array<real_T, 1U> &load,
                   const ::coder::array<boolean_T, 1U> &dtags,
                   const ::coder::array<real_T, 1U> &dvals,
                   const ::coder::array<int32_T, 1U> &gdofs)
{
  int32_T n;
  // sfe_elem_dbc - Apply Dirichlet boundary conditions (DBC)
  //
  //    [elemmat, load] = sfe_elem_dbc(elemmat, load, dtags)
  //    [elemmat, load] = sfe_elem_dbc(elemmat, load, dtags, dvals)
  //    [elemmat, load] = sfe_elem_dbc(elemmat, load, dtags, dvals, gdofs)
  //
  //  PARAMETERS
  //  ----------
  //    element:    Local element matrix
  //    load:       Local load vector
  //    dtags:      Dirichlet boundary tags
  //    dvals:      Dirichlet boundary values (empty or omitted means zeros)
  //    gdofs:      Global DOF map (optional)
  //
  //  RETURNS
  //    element:    Upon successful return, its Dirichlet nodes are eliminated
  //    load:       Upon successful return, its values are updated due to the
  //                elimination of Dirichlet nodes
  //
  //  NOTES
  //  -----
  //  First, we apply DBC symmetrically in that the columns are also eliminated.
  //  Hence, we require the users to pass in the load vector.
  //
  //  Next, this routine supports both local and global Dirichlet tags and
  //  values. If gdofs is missing, then we assume that dtags and dvals have the
  //  same sizes of elemmat and load. On the other side, then we assume they are
  //  global vectors, and the global DOF map (gdofs, whose length is the same
  //  size of those in elemmat and load) will help access the proper values
  //  therein.
  //
  //  See also sfe_elem_stiff, sfe_elem_load
  n = elemmat.size(0) - 1;
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(load.size(0) == elemmat.size(0), "");
  for (int32_T i{0}; i <= n; i++) {
    if (dtags[gdofs[i] - 1]) {
      real_T dv;
      int32_T b_i;
      //  not a dirichlet node
      dv = 0.0;
      if (dvals.size(0) != 0) {
        dv = dvals[gdofs[i] - 1];
      }
      if (dv != 0.0) {
        for (int32_T j{0}; j <= n; j++) {
          load[j] = load[j] - elemmat[i + elemmat.size(1) * j] * dv;
          elemmat[i + elemmat.size(1) * j] = 0.0;
        }
      } else {
        for (int32_T j{0}; j <= n; j++) {
          elemmat[i + elemmat.size(1) * j] = 0.0;
        }
      }
      b_i = elemmat.size(1);
      for (int32_T j{0}; j < b_i; j++) {
        elemmat[j + elemmat.size(1) * i] = 0.0;
      }
      elemmat[i + elemmat.size(1) * i] = 1.0;
      load[i] = dv;
    }
  }
}

void sfe_elem_le2d1(SfeObject *b_sfe, real_T mu, real_T lambda,
                    ::coder::array<real_T, 2U> &elemmat)
{
  real_T D[9];
  real_T B[6];
  real_T Bi[6];
  real_T b_D[6];
  real_T c_sfe;
  int32_T i;
  int32_T loop_ub;
  int32_T n;
  int32_T y_tmp;
  // sfe_elem_le2d - Computing the stiffness matrix for linear elasticity in 2D
  //
  //    [sfe, elemmat] = sfe_elem_le2d(sfe, mu, lambda)
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An initialized SfeObject instance
  //    mu, lambda: Lam{\'}e's parameters
  //
  //  RETURNS
  //  -------
  //    sfe:        Same sfe instance with computed gradients therein
  //    elemmat:    Local 2*n-by-2*n element, where n is number of nodes in the
  //                trial space element (assume Galerkin).
  //
  //  NOTES
  //  -----
  //  In 2D, the strain tensor operator reads
  //
  //        [ux,  0]
  //    B = [ 0, uy]
  //        [uy, ux]
  //
  //  and the stiffness tensor (linear) reads
  //
  //        [lambda + 2*mu,        lambda,  0]
  //    D = [       lambda, lambda + 2*mu,  0]
  //        [            0,             0, mu]
  //
  //  The stress tensor operator is then defined as B*D. For linear elasticity,
  //  the stiffness matrix is defined as the integration of B'*D*B. Note that
  //  we store the DOFs locally so that the displacements are clustered, i.e.,
  //  [u1,v1,u2,v2,...]. This typically aligns with the global system ordering
  //  regarding DOFs for solid mechanics.
  //
  //  See also SfeObject, sfe_init, sfe_init_grad, sfe_elem_le3d
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(b_sfe->geom_dim == 2, "");
  n = b_sfe->nnodes[0];
  y_tmp = b_sfe->nnodes[0] << 1;
  elemmat.set_size(y_tmp, y_tmp);
  loop_ub = y_tmp * y_tmp;
  for (i = 0; i < loop_ub; i++) {
    elemmat[i] = 0.0;
  }
  real_T d;
  d = lambda + 2.0 * mu;
  //  stiffness tensor
  D[0] = d;
  D[1] = lambda;
  D[2] = 0.0;
  D[3] = lambda;
  D[4] = d;
  D[5] = 0.0;
  D[6] = 0.0;
  D[7] = 0.0;
  D[8] = mu;
  //  loop through all quadrature points
  i = b_sfe->nqp;
  if ((i - 1 >= 0) && (n - 1 >= 0)) {
    Bi[1] = 0.0;
    Bi[2] = 0.0;
  }
  for (int32_T q{0}; q < i; q++) {
    //  initialize gradient
    sfe_init_grad(b_sfe, q + 1);
    //  compute stiffness matrix Bi'*D*Bj
    for (int32_T b_i{0}; b_i < n; b_i++) {
      real_T elemmat_idx_3;
      real_T ux;
      real_T uy;
      ux = b_sfe->grads_sol[b_sfe->grads_sol.size(1) * b_i];
      uy = b_sfe->grads_sol[b_sfe->grads_sol.size(1) * b_i + 1];
      Bi[0] = ux;
      Bi[3] = uy;
      Bi[4] = uy;
      Bi[5] = ux;
      loop_ub = b_i << 1;
      if (b_i + 1 <= n) {
        B[1] = 0.0;
        B[2] = 0.0;
        c_sfe = b_sfe->wdetJ[q];
        for (int32_T i1{0}; i1 < 3; i1++) {
          ux = D[i1];
          uy = D[i1 + 3];
          elemmat_idx_3 = D[i1 + 6];
          for (int32_T i2{0}; i2 < 2; i2++) {
            b_D[i1 + 3 * i2] =
                (ux * Bi[i2] + uy * Bi[i2 + 2]) + elemmat_idx_3 * Bi[i2 + 4];
          }
        }
      }
      for (int32_T j{b_i + 1}; j <= n; j++) {
        real_T b_B[4];
        int32_T y;
        y = (j - 1) << 1;
        ux = b_sfe->grads_sol[b_sfe->grads_sol.size(1) * (j - 1)];
        uy = b_sfe->grads_sol[b_sfe->grads_sol.size(1) * (j - 1) + 1];
        B[0] = ux;
        B[3] = uy;
        B[4] = uy;
        B[5] = ux;
        for (int32_T i1{0}; i1 < 2; i1++) {
          ux = B[i1];
          uy = B[i1 + 2];
          elemmat_idx_3 = B[i1 + 4];
          for (int32_T i2{0}; i2 < 2; i2++) {
            b_B[i1 + (i2 << 1)] = (ux * b_D[3 * i2] + uy * b_D[3 * i2 + 1]) +
                                  elemmat_idx_3 * b_D[3 * i2 + 2];
          }
        }
        ux = elemmat[(y + elemmat.size(1) * loop_ub) + 1] + b_B[1] * c_sfe;
        uy = elemmat[y + elemmat.size(1) * (loop_ub + 1)] + b_B[2] * c_sfe;
        elemmat_idx_3 =
            elemmat[(y + elemmat.size(1) * (loop_ub + 1)) + 1] + b_B[3] * c_sfe;
        elemmat[y + elemmat.size(1) * loop_ub] =
            elemmat[y + elemmat.size(1) * loop_ub] + b_B[0] * c_sfe;
        elemmat[(y + elemmat.size(1) * loop_ub) + 1] = ux;
        elemmat[y + elemmat.size(1) * (loop_ub + 1)] = uy;
        elemmat[(y + elemmat.size(1) * (loop_ub + 1)) + 1] = elemmat_idx_3;
      }
    }
  }
  //  fill in lower part
  for (int32_T b_i{2}; b_i <= y_tmp; b_i++) {
    for (int32_T j{0}; j <= b_i - 2; j++) {
      elemmat[j + elemmat.size(1) * (b_i - 1)] =
          elemmat[(b_i + elemmat.size(1) * j) - 1];
    }
  }
}

void sfe_elem_le3d1(SfeObject *b_sfe, real_T mu, real_T lambda,
                    ::coder::array<real_T, 2U> &elemmat)
{
  real_T D[36];
  real_T B[18];
  real_T Bi[18];
  real_T c_sfe;
  int32_T elemmat_tmp[3];
  int32_T i;
  int32_T m;
  int32_T n;
  int32_T y_tmp;
  // sfe_elem_le3d - Computing the stiffness matrix for linear elasticity in 3D
  //
  //    [sfe, elemmat] = sfe_elem_le3d(sfe, mu, lambda)
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An initialized SfeObject instance
  //    mu, lambda: Lam{\'}e's parameters
  //
  //  RETURNS
  //  -------
  //    sfe:        Same sfe instance with computed gradients therein
  //    elemmat:    Local 3*n-by-3*n element, where n is number of nodes in the
  //                trial space element (assume Galerkin).
  //
  //  NOTES
  //  -----
  //  In 3D, the strain tensor operator reads
  //
  //        [ux,  0,  0]
  //        [ 0, uy,  0]
  //    B = [ 0,  0, uz]
  //        [uy, ux,  0]
  //        [ 0, uz, uy]
  //        [uz,  0, ux]
  //
  //  and the stiffness tensor (linear) reads
  //
  //        [lambda + 2*mu,        lambda,        lambda,  0,  0,  0]
  //        [       lambda, lambda + 2*mu,        lambda,  0,  0,  0]
  //    D = [       lambda,        lambda, lambda + 2*mu,  0,  0,  0]
  //        [            0,             0,             0, mu,  0,  0]
  //        [            0,             0,             0,  0, mu,  0]
  //        [            0,             0,             0,  0,  0, mu]
  //
  //  The stress tensor operator is then defined as B*D. For linear elasticity,
  //  the stiffness matrix is defined as the integration of B'*D*B. Note that
  //  we store the DOFs locally so that the displacements are clustered, i.e.,
  //  [u1,v1,w1,u2,v2,w2,...]. This typically aligns with the global system
  //  ordering regarding DOFs for solid mechanics.
  //
  //  See also SfeObject, sfe_init, sfe_init_grad
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(b_sfe->geom_dim == 3, "");
  n = b_sfe->nnodes[0];
  y_tmp = b_sfe->nnodes[0] * 3;
  elemmat.set_size(y_tmp, y_tmp);
  y_tmp *= y_tmp;
  for (i = 0; i < y_tmp; i++) {
    elemmat[i] = 0.0;
  }
  real_T d;
  d = lambda + 2.0 * mu;
  //  stiffness tensor
  D[0] = d;
  D[1] = 2.0 * lambda;
  D[2] = 2.0 * lambda;
  D[3] = 0.0;
  D[4] = 0.0;
  D[5] = 0.0;
  D[6] = 2.0 * lambda;
  D[7] = d;
  D[8] = 2.0 * lambda;
  D[9] = 0.0;
  D[10] = 0.0;
  D[11] = 0.0;
  D[12] = 2.0 * lambda;
  D[13] = 2.0 * lambda;
  D[14] = d;
  D[15] = 0.0;
  D[16] = 0.0;
  D[17] = 0.0;
  D[18] = 0.0;
  D[19] = 0.0;
  D[20] = 0.0;
  D[21] = mu;
  D[22] = 0.0;
  D[23] = 0.0;
  D[24] = 0.0;
  D[25] = 0.0;
  D[26] = 0.0;
  D[27] = 0.0;
  D[28] = mu;
  D[29] = 0.0;
  D[30] = 0.0;
  D[31] = 0.0;
  D[32] = 0.0;
  D[33] = 0.0;
  D[34] = 0.0;
  D[35] = mu;
  //  loop through all quadrature points
  i = b_sfe->nqp;
  if ((i - 1 >= 0) && (n - 1 >= 0)) {
    Bi[1] = 0.0;
    Bi[2] = 0.0;
    Bi[3] = 0.0;
    Bi[5] = 0.0;
    Bi[6] = 0.0;
    Bi[7] = 0.0;
    Bi[11] = 0.0;
    Bi[12] = 0.0;
    Bi[16] = 0.0;
  }
  for (int32_T q{0}; q < i; q++) {
    //  initialize gradient
    sfe_init_grad(b_sfe, q + 1);
    //  compute stiffness matrix Bi'*D*Bj
    for (int32_T b_i{0}; b_i < n; b_i++) {
      real_T ux;
      real_T uy;
      real_T uz;
      int32_T y;
      ux = b_sfe->grads_sol[b_sfe->grads_sol.size(1) * b_i];
      uy = b_sfe->grads_sol[b_sfe->grads_sol.size(1) * b_i + 1];
      uz = b_sfe->grads_sol[b_sfe->grads_sol.size(1) * b_i + 2];
      Bi[0] = ux;
      Bi[4] = uy;
      Bi[8] = uz;
      Bi[9] = uy;
      Bi[10] = ux;
      Bi[13] = uz;
      Bi[14] = uy;
      Bi[15] = uz;
      Bi[17] = ux;
      y = b_i * 3;
      if (b_i + 1 <= n) {
        B[1] = 0.0;
        B[2] = 0.0;
        B[3] = 0.0;
        B[5] = 0.0;
        B[6] = 0.0;
        B[7] = 0.0;
        B[11] = 0.0;
        B[12] = 0.0;
        B[16] = 0.0;
        c_sfe = b_sfe->wdetJ[q];
        elemmat_tmp[0] = y + 1;
        elemmat_tmp[1] = y + 2;
        elemmat_tmp[2] = y + 3;
      }
      for (int32_T j{b_i + 1}; j <= n; j++) {
        real_T b_D[18];
        real_T b_B[9];
        real_T b_elemmat[9];
        int32_T i2;
        y = (j - 1) * 3;
        ux = b_sfe->grads_sol[b_sfe->grads_sol.size(1) * (j - 1)];
        uy = b_sfe->grads_sol[b_sfe->grads_sol.size(1) * (j - 1) + 1];
        uz = b_sfe->grads_sol[b_sfe->grads_sol.size(1) * (j - 1) + 2];
        B[0] = ux;
        B[4] = uy;
        B[8] = uz;
        B[9] = uy;
        B[10] = ux;
        B[13] = uz;
        B[14] = uy;
        B[15] = uz;
        B[17] = ux;
        for (int32_T i1{0}; i1 < 6; i1++) {
          for (i2 = 0; i2 < 3; i2++) {
            ux = 0.0;
            for (y_tmp = 0; y_tmp < 6; y_tmp++) {
              ux += D[i1 + 6 * y_tmp] * Bi[i2 + 3 * y_tmp];
            }
            b_D[i1 + 6 * i2] = ux;
          }
        }
        for (int32_T i1{0}; i1 < 3; i1++) {
          for (i2 = 0; i2 < 3; i2++) {
            ux = 0.0;
            for (y_tmp = 0; y_tmp < 6; y_tmp++) {
              ux += B[i1 + 3 * y_tmp] * b_D[y_tmp + 6 * i2];
            }
            b_B[i1 + 3 * i2] = ux;
          }
        }
        for (int32_T i1{0}; i1 < 3; i1++) {
          i2 = elemmat_tmp[i1];
          b_elemmat[3 * i1] =
              elemmat[y + elemmat.size(1) * (i2 - 1)] + b_B[3 * i1] * c_sfe;
          y_tmp = 3 * i1 + 1;
          b_elemmat[y_tmp] = elemmat[(y + elemmat.size(1) * (i2 - 1)) + 1] +
                             b_B[y_tmp] * c_sfe;
          y_tmp = 3 * i1 + 2;
          b_elemmat[y_tmp] = elemmat[(y + elemmat.size(1) * (i2 - 1)) + 2] +
                             b_B[y_tmp] * c_sfe;
        }
        for (int32_T i1{0}; i1 < 3; i1++) {
          i2 = elemmat_tmp[i1];
          elemmat[y + elemmat.size(1) * (i2 - 1)] = b_elemmat[3 * i1];
          elemmat[(y + elemmat.size(1) * (i2 - 1)) + 1] = b_elemmat[3 * i1 + 1];
          elemmat[(y + elemmat.size(1) * (i2 - 1)) + 2] = b_elemmat[3 * i1 + 2];
        }
      }
    }
  }
  //  fill in lower part
  m = 3 * n;
  for (int32_T b_i{2}; b_i <= m; b_i++) {
    for (int32_T j{0}; j <= b_i - 2; j++) {
      elemmat[j + elemmat.size(1) * (b_i - 1)] =
          elemmat[(b_i + elemmat.size(1) * j) - 1];
    }
  }
}

void sfe_elem_load1(const SfeObject *b_sfe,
                    const ::coder::array<real_T, 2U> &fs, boolean_T compwise,
                    ::coder::array<real_T, 1U> &load,
                    ::coder::array<real_T, 1U> &mlump)
{
  int32_T i;
  int32_T loop_ub;
  int32_T n;
  int32_T ncomps;
  // sfe_elem_load - Computing load vector for an element
  //
  //    [sfe, load, mass] = sfe_elem_load(sfe, fs)
  //    [sfe, load, mass] = sfe_elem_load(sfe, fs, compwise)
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An initialized SfeObject instance
  //    fs:         Source term of the element associated to sfe
  //    compwise:   Boolean tag indicating whether to store the integration
  //                component-wise (u1,u2,...,v1,v2,...) or the
  //                opposite (u1,v1,u2,v2,...)
  //
  //  RETURNS
  //  -------
  //    sfe:        Same instance output allows users to use workspaces therein
  //    load:       Local load vector
  //    mass:       lumped mass matrix
  //
  //  See also sfe_init, sfe_elem_stiff
  n = b_sfe->nnodes[0] - 1;
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(b_sfe->nnodes[0] == fs.size(0), "");
  ncomps = fs.size(1);
  load.set_size(fs.size(1) * b_sfe->nnodes[0]);
  loop_ub = fs.size(1) * b_sfe->nnodes[0];
  for (i = 0; i < loop_ub; i++) {
    load[i] = 0.0;
  }
  mlump.set_size(fs.size(1) * b_sfe->nnodes[0]);
  loop_ub = fs.size(1) * b_sfe->nnodes[0];
  for (i = 0; i < loop_ub; i++) {
    mlump[i] = 0.0;
  }
  //  for each quadrature point
  if (compwise) {
    i = b_sfe->nqp;
    for (int32_T q{0}; q < i; q++) {
      real_T wdetj;
      int32_T j;
      wdetj = b_sfe->wdetJ[q];
      j = 0;
      for (int32_T k{0}; k < ncomps; k++) {
        real_T a;
        real_T v;
        int32_T m;
        // interpolate_shape - Interpolate f with q-th shape function in the
        // table
        //
        //    v = interpolate_shape(shapes, q, f)
        //    v = interpolate_shape(shapes, q, f, k)
        m = b_sfe->shapes_sol.size(1);
        v = b_sfe->shapes_sol[b_sfe->shapes_sol.size(1) * q] * fs[k];
        for (int32_T b_i{2}; b_i <= m; b_i++) {
          v += b_sfe->shapes_sol[(b_i + b_sfe->shapes_sol.size(1) * q) - 1] *
               fs[k + fs.size(1) * (b_i - 1)];
        }
        a = v * wdetj;
        for (int32_T b_i{0}; b_i <= n; b_i++) {
          loop_ub = j + b_i;
          load[loop_ub] =
              load[loop_ub] +
              a * b_sfe->shapes_sol[b_i + b_sfe->shapes_sol.size(1) * q];
          mlump[loop_ub] =
              mlump[loop_ub] +
              wdetj * b_sfe->shapes_sol[b_i + b_sfe->shapes_sol.size(1) * q];
        }
        j = (j + n) + 1;
      }
    }
  } else {
    //  tensor blocks of DOFs, not component-wise
    i = b_sfe->nqp;
    for (int32_T q{0}; q < i; q++) {
      real_T wdetj;
      wdetj = b_sfe->wdetJ[q];
      for (int32_T k{0}; k < ncomps; k++) {
        real_T a;
        real_T v;
        int32_T m;
        // interpolate_shape - Interpolate f with q-th shape function in the
        // table
        //
        //    v = interpolate_shape(shapes, q, f)
        //    v = interpolate_shape(shapes, q, f, k)
        m = b_sfe->shapes_sol.size(1);
        v = b_sfe->shapes_sol[b_sfe->shapes_sol.size(1) * q] * fs[k];
        for (int32_T b_i{2}; b_i <= m; b_i++) {
          v += b_sfe->shapes_sol[(b_i + b_sfe->shapes_sol.size(1) * q) - 1] *
               fs[k + fs.size(1) * (b_i - 1)];
        }
        a = v * wdetj;
        for (int32_T b_i{0}; b_i <= n; b_i++) {
          load[k + b_i * ncomps] =
              load[k + b_i * ncomps] +
              a * b_sfe->shapes_sol[b_i + b_sfe->shapes_sol.size(1) * q];
          mlump[k + b_i * ncomps] =
              mlump[k + b_i * ncomps] +
              wdetj * b_sfe->shapes_sol[b_i + b_sfe->shapes_sol.size(1) * q];
        }
      }
    }
  }
}

void sfe_elem_load2(const SfeObject *b_sfe,
                    const ::coder::array<real_T, 2U> &fs,
                    ::coder::array<real_T, 1U> &load,
                    ::coder::array<real_T, 1U> &mlump)
{
  int32_T i;
  int32_T loop_ub;
  int32_T n;
  int32_T ncomps;
  // sfe_elem_load - Computing load vector for an element
  //
  //    [sfe, load, mass] = sfe_elem_load(sfe, fs)
  //    [sfe, load, mass] = sfe_elem_load(sfe, fs, compwise)
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An initialized SfeObject instance
  //    fs:         Source term of the element associated to sfe
  //    compwise:   Boolean tag indicating whether to store the integration
  //                component-wise (u1,u2,...,v1,v2,...) or the
  //                opposite (u1,v1,u2,v2,...)
  //
  //  RETURNS
  //  -------
  //    sfe:        Same instance output allows users to use workspaces therein
  //    load:       Local load vector
  //    mass:       lumped mass matrix
  //
  //  See also sfe_init, sfe_elem_stiff
  n = b_sfe->nnodes[0];
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(b_sfe->nnodes[0] == fs.size(0), "");
  ncomps = fs.size(1);
  load.set_size(fs.size(1) * b_sfe->nnodes[0]);
  loop_ub = fs.size(1) * b_sfe->nnodes[0];
  for (i = 0; i < loop_ub; i++) {
    load[i] = 0.0;
  }
  mlump.set_size(fs.size(1) * b_sfe->nnodes[0]);
  loop_ub = fs.size(1) * b_sfe->nnodes[0];
  for (i = 0; i < loop_ub; i++) {
    mlump[i] = 0.0;
  }
  //  for each quadrature point
  //  tensor blocks of DOFs, not component-wise
  i = b_sfe->nqp;
  for (int32_T q{0}; q < i; q++) {
    real_T wdetj;
    wdetj = b_sfe->wdetJ[q];
    for (int32_T k{0}; k < ncomps; k++) {
      real_T a;
      real_T v;
      int32_T m;
      // interpolate_shape - Interpolate f with q-th shape function in the table
      //
      //    v = interpolate_shape(shapes, q, f)
      //    v = interpolate_shape(shapes, q, f, k)
      m = b_sfe->shapes_sol.size(1);
      v = b_sfe->shapes_sol[b_sfe->shapes_sol.size(1) * q] * fs[k];
      for (int32_T b_i{2}; b_i <= m; b_i++) {
        v += b_sfe->shapes_sol[(b_i + b_sfe->shapes_sol.size(1) * q) - 1] *
             fs[k + fs.size(1) * (b_i - 1)];
      }
      a = v * wdetj;
      for (int32_T b_i{0}; b_i < n; b_i++) {
        load[k + b_i * ncomps] =
            load[k + b_i * ncomps] +
            a * b_sfe->shapes_sol[b_i + b_sfe->shapes_sol.size(1) * q];
        mlump[k + b_i * ncomps] =
            mlump[k + b_i * ncomps] +
            wdetj * b_sfe->shapes_sol[b_i + b_sfe->shapes_sol.size(1) * q];
      }
    }
  }
}

void sfe_elem_mass1(const SfeObject *b_sfe, ::coder::array<real_T, 2U> &elemmat)
{
  int32_T i;
  int32_T loop_ub;
  int32_T m;
  // sfe_elem_mass - Computing the local mass matrix for an element
  //
  //    [sfe, elemmat] = sfe_elem_mass(sfe)
  //    [sfe, elemmat] = sfe_elem_mass(sfe, rho)  * Constant rho
  //    [sfe, elemmat] = sfe_elem_mass(sfe, rho, []) * Spatial varied rho
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An initialized SfeObject instance
  //    rho:        "Density" coefficient to the mass matrix
  //
  //  RETURNS
  //  -------
  //    sfe:        Allow users to use the workspace (dwork?) therein
  //    elemmat:    Local element mass matrix
  //
  //  NOTES
  //  -----
  //  By default, sfe_elem_mass(sfe) computes a mass element matrix with rho=1,
  //  and sfe_elem_mass(sfe, rho) can set the density to another constant
  //  value. To enable spatial varied density, one needs to pass a dummy
  //  variable to the third entry point, i.e., sfe_elem_mass(sfe, rho, []).
  //  Then, rho will assume to be spatial varied.
  //
  //  See also SfeObject, sfe_elem_stiff
  m = b_sfe->nnodes[0];
  elemmat.set_size(b_sfe->nnodes[0], b_sfe->nnodes[0]);
  loop_ub = b_sfe->nnodes[0] * b_sfe->nnodes[0];
  for (i = 0; i < loop_ub; i++) {
    elemmat[i] = 0.0;
  }
  //  for each qpoint
  i = b_sfe->nqp;
  for (int32_T q{0}; q < i; q++) {
    //  get weighted volume
    for (int32_T b_i{0}; b_i < m; b_i++) {
      real_T psi;
      psi = b_sfe->wdetJ[q] *
            b_sfe->shapes_sol[b_i + b_sfe->shapes_sol.size(1) * q];
      for (int32_T j{b_i + 1}; j <= m; j++) {
        elemmat[(j + elemmat.size(1) * b_i) - 1] =
            elemmat[(j + elemmat.size(1) * b_i) - 1] +
            b_sfe->shapes_sol[(j + b_sfe->shapes_sol.size(1) * q) - 1] * psi;
      }
    }
  }
  //  fill in lower part
  for (int32_T b_i{2}; b_i <= m; b_i++) {
    for (int32_T j{0}; j <= b_i - 2; j++) {
      elemmat[j + elemmat.size(1) * (b_i - 1)] =
          elemmat[(b_i + elemmat.size(1) * j) - 1];
    }
  }
}

void sfe_elem_mass2(const SfeObject *b_sfe, real_T rho,
                    ::coder::array<real_T, 2U> &elemmat)
{
  int32_T i;
  int32_T loop_ub;
  int32_T m;
  // sfe_elem_mass - Computing the local mass matrix for an element
  //
  //    [sfe, elemmat] = sfe_elem_mass(sfe)
  //    [sfe, elemmat] = sfe_elem_mass(sfe, rho)  * Constant rho
  //    [sfe, elemmat] = sfe_elem_mass(sfe, rho, []) * Spatial varied rho
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An initialized SfeObject instance
  //    rho:        "Density" coefficient to the mass matrix
  //
  //  RETURNS
  //  -------
  //    sfe:        Allow users to use the workspace (dwork?) therein
  //    elemmat:    Local element mass matrix
  //
  //  NOTES
  //  -----
  //  By default, sfe_elem_mass(sfe) computes a mass element matrix with rho=1,
  //  and sfe_elem_mass(sfe, rho) can set the density to another constant
  //  value. To enable spatial varied density, one needs to pass a dummy
  //  variable to the third entry point, i.e., sfe_elem_mass(sfe, rho, []).
  //  Then, rho will assume to be spatial varied.
  //
  //  See also SfeObject, sfe_elem_stiff
  m = b_sfe->nnodes[0];
  elemmat.set_size(b_sfe->nnodes[0], b_sfe->nnodes[0]);
  loop_ub = b_sfe->nnodes[0] * b_sfe->nnodes[0];
  for (i = 0; i < loop_ub; i++) {
    elemmat[i] = 0.0;
  }
  //  for each qpoint
  i = b_sfe->nqp;
  for (int32_T q{0}; q < i; q++) {
    real_T wdetj;
    //  get weighted volume
    //  compile-time optimization for constant
    wdetj = b_sfe->wdetJ[q] * rho;
    for (int32_T b_i{0}; b_i < m; b_i++) {
      real_T psi;
      psi = wdetj * b_sfe->shapes_sol[b_i + b_sfe->shapes_sol.size(1) * q];
      for (int32_T j{b_i + 1}; j <= m; j++) {
        elemmat[(j + elemmat.size(1) * b_i) - 1] =
            elemmat[(j + elemmat.size(1) * b_i) - 1] +
            b_sfe->shapes_sol[(j + b_sfe->shapes_sol.size(1) * q) - 1] * psi;
      }
    }
  }
  //  fill in lower part
  for (int32_T b_i{2}; b_i <= m; b_i++) {
    for (int32_T j{0}; j <= b_i - 2; j++) {
      elemmat[j + elemmat.size(1) * (b_i - 1)] =
          elemmat[(b_i + elemmat.size(1) * j) - 1];
    }
  }
}

void sfe_elem_mass3(const SfeObject *b_sfe,
                    const ::coder::array<real_T, 1U> &rho,
                    ::coder::array<real_T, 2U> &elemmat)
{
  int32_T i;
  int32_T loop_ub;
  int32_T m;
  // sfe_elem_mass - Computing the local mass matrix for an element
  //
  //    [sfe, elemmat] = sfe_elem_mass(sfe)
  //    [sfe, elemmat] = sfe_elem_mass(sfe, rho)  * Constant rho
  //    [sfe, elemmat] = sfe_elem_mass(sfe, rho, []) * Spatial varied rho
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An initialized SfeObject instance
  //    rho:        "Density" coefficient to the mass matrix
  //
  //  RETURNS
  //  -------
  //    sfe:        Allow users to use the workspace (dwork?) therein
  //    elemmat:    Local element mass matrix
  //
  //  NOTES
  //  -----
  //  By default, sfe_elem_mass(sfe) computes a mass element matrix with rho=1,
  //  and sfe_elem_mass(sfe, rho) can set the density to another constant
  //  value. To enable spatial varied density, one needs to pass a dummy
  //  variable to the third entry point, i.e., sfe_elem_mass(sfe, rho, []).
  //  Then, rho will assume to be spatial varied.
  //
  //  See also SfeObject, sfe_elem_stiff
  m = b_sfe->nnodes[0];
  elemmat.set_size(b_sfe->nnodes[0], b_sfe->nnodes[0]);
  loop_ub = b_sfe->nnodes[0] * b_sfe->nnodes[0];
  for (i = 0; i < loop_ub; i++) {
    elemmat[i] = 0.0;
  }
  //  for each qpoint
  i = b_sfe->nqp;
  for (int32_T q{0}; q < i; q++) {
    real_T wdetj;
    //  get weighted volume
    if (rho.size(0) == 1) {
      wdetj = b_sfe->wdetJ[q] * rho[0];
    } else {
      real_T v;
      int32_T b_m;
      // interpolate_shape - Interpolate f with q-th shape function in the table
      //
      //    v = interpolate_shape(shapes, q, f)
      //    v = interpolate_shape(shapes, q, f, k)
      b_m = b_sfe->shapes_sol.size(1);
      v = b_sfe->shapes_sol[b_sfe->shapes_sol.size(1) * q] * rho[0];
      for (int32_T b_i{2}; b_i <= b_m; b_i++) {
        v += b_sfe->shapes_sol[(b_i + b_sfe->shapes_sol.size(1) * q) - 1] *
             rho[b_i - 1];
      }
      wdetj = b_sfe->wdetJ[q] * v;
    }
    for (int32_T b_i{0}; b_i < m; b_i++) {
      real_T psi;
      psi = wdetj * b_sfe->shapes_sol[b_i + b_sfe->shapes_sol.size(1) * q];
      for (int32_T j{b_i + 1}; j <= m; j++) {
        elemmat[(j + elemmat.size(1) * b_i) - 1] =
            elemmat[(j + elemmat.size(1) * b_i) - 1] +
            b_sfe->shapes_sol[(j + b_sfe->shapes_sol.size(1) * q) - 1] * psi;
      }
    }
  }
  //  fill in lower part
  for (int32_T b_i{2}; b_i <= m; b_i++) {
    for (int32_T j{0}; j <= b_i - 2; j++) {
      elemmat[j + elemmat.size(1) * (b_i - 1)] =
          elemmat[(b_i + elemmat.size(1) * j) - 1];
    }
  }
}

void sfe_elem_nbc1(const SfeObject *b_sfe, const ::coder::array<real_T, 2U> &g,
                   ::coder::array<real_T, 1U> &load)
{
  int32_T i;
  int32_T loop_ub;
  int32_T n;
  int32_T ncomps;
  // sfe_elem_nbc - Compute local Neumann boundary values as load vectors
  //
  //    [sfe, load] = sfe_elem_nbc(sfe, g)
  //    [sfe, load] = sfe_elem_nbc(sfe, g, compwise)
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An initialized SfeObject instance
  //    g:          Neumann values on the boundary nodes, i.e., dot(grad(u),n)
  //    compwise:   Boolean tag indicating whether to store the integeration
  //                component-wise (u1,u2,...,v1,v2,...) or the
  //                opposite (u1,v1,u2,v2,...)
  //
  //  RETURNS
  //  -------
  //    load:       Integerated Neumann values
  //
  //  See also sfe_elem_load
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(b_sfe->facetid != 0, "must be a boundary element");
  // sfe_elem_load - Computing load vector for an element
  //
  //    [sfe, load, mass] = sfe_elem_load(sfe, fs)
  //    [sfe, load, mass] = sfe_elem_load(sfe, fs, compwise)
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An initialized SfeObject instance
  //    fs:         Source term of the element associated to sfe
  //    compwise:   Boolean tag indicating whether to store the integration
  //                component-wise (u1,u2,...,v1,v2,...) or the
  //                opposite (u1,v1,u2,v2,...)
  //
  //  RETURNS
  //  -------
  //    sfe:        Same instance output allows users to use workspaces therein
  //    load:       Local load vector
  //    mass:       lumped mass matrix
  //
  //  See also sfe_init, sfe_elem_stiff
  n = b_sfe->nnodes[0];
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(b_sfe->nnodes[0] == g.size(0), "");
  ncomps = g.size(1);
  load.set_size(g.size(1) * b_sfe->nnodes[0]);
  loop_ub = g.size(1) * b_sfe->nnodes[0];
  for (i = 0; i < loop_ub; i++) {
    load[i] = 0.0;
  }
  //  for each quadrature point
  //  tensor blocks of DOFs, not component-wise
  i = b_sfe->nqp;
  for (int32_T q{0}; q < i; q++) {
    real_T wdetj;
    wdetj = b_sfe->wdetJ[q];
    for (int32_T k{0}; k < ncomps; k++) {
      real_T a;
      real_T v;
      int32_T m;
      // interpolate_shape - Interpolate f with q-th shape function in the table
      //
      //    v = interpolate_shape(shapes, q, f)
      //    v = interpolate_shape(shapes, q, f, k)
      m = b_sfe->shapes_sol.size(1);
      v = b_sfe->shapes_sol[b_sfe->shapes_sol.size(1) * q] * g[k];
      for (int32_T b_i{2}; b_i <= m; b_i++) {
        v += b_sfe->shapes_sol[(b_i + b_sfe->shapes_sol.size(1) * q) - 1] *
             g[k + g.size(1) * (b_i - 1)];
      }
      a = v * wdetj;
      for (int32_T b_i{0}; b_i < n; b_i++) {
        load[k + b_i * ncomps] =
            load[k + b_i * ncomps] +
            a * b_sfe->shapes_sol[b_i + b_sfe->shapes_sol.size(1) * q];
      }
    }
  }
}

void sfe_elem_nbc2(const SfeObject *b_sfe, const ::coder::array<real_T, 2U> &g,
                   boolean_T compwise, ::coder::array<real_T, 1U> &load)
{
  int32_T i;
  int32_T loop_ub;
  int32_T n;
  int32_T ncomps;
  // sfe_elem_nbc - Compute local Neumann boundary values as load vectors
  //
  //    [sfe, load] = sfe_elem_nbc(sfe, g)
  //    [sfe, load] = sfe_elem_nbc(sfe, g, compwise)
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An initialized SfeObject instance
  //    g:          Neumann values on the boundary nodes, i.e., dot(grad(u),n)
  //    compwise:   Boolean tag indicating whether to store the integeration
  //                component-wise (u1,u2,...,v1,v2,...) or the
  //                opposite (u1,v1,u2,v2,...)
  //
  //  RETURNS
  //  -------
  //    load:       Integerated Neumann values
  //
  //  See also sfe_elem_load
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(b_sfe->facetid != 0, "must be a boundary element");
  // sfe_elem_load - Computing load vector for an element
  //
  //    [sfe, load, mass] = sfe_elem_load(sfe, fs)
  //    [sfe, load, mass] = sfe_elem_load(sfe, fs, compwise)
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An initialized SfeObject instance
  //    fs:         Source term of the element associated to sfe
  //    compwise:   Boolean tag indicating whether to store the integration
  //                component-wise (u1,u2,...,v1,v2,...) or the
  //                opposite (u1,v1,u2,v2,...)
  //
  //  RETURNS
  //  -------
  //    sfe:        Same instance output allows users to use workspaces therein
  //    load:       Local load vector
  //    mass:       lumped mass matrix
  //
  //  See also sfe_init, sfe_elem_stiff
  n = b_sfe->nnodes[0] - 1;
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(b_sfe->nnodes[0] == g.size(0), "");
  ncomps = g.size(1);
  load.set_size(g.size(1) * b_sfe->nnodes[0]);
  loop_ub = g.size(1) * b_sfe->nnodes[0];
  for (i = 0; i < loop_ub; i++) {
    load[i] = 0.0;
  }
  //  for each quadrature point
  if (compwise) {
    i = b_sfe->nqp;
    for (int32_T q{0}; q < i; q++) {
      real_T wdetj;
      int32_T j;
      wdetj = b_sfe->wdetJ[q];
      j = 0;
      for (int32_T k{0}; k < ncomps; k++) {
        real_T a;
        real_T v;
        int32_T m;
        // interpolate_shape - Interpolate f with q-th shape function in the
        // table
        //
        //    v = interpolate_shape(shapes, q, f)
        //    v = interpolate_shape(shapes, q, f, k)
        m = b_sfe->shapes_sol.size(1);
        v = b_sfe->shapes_sol[b_sfe->shapes_sol.size(1) * q] * g[k];
        for (int32_T b_i{2}; b_i <= m; b_i++) {
          v += b_sfe->shapes_sol[(b_i + b_sfe->shapes_sol.size(1) * q) - 1] *
               g[k + g.size(1) * (b_i - 1)];
        }
        a = v * wdetj;
        for (int32_T b_i{0}; b_i <= n; b_i++) {
          loop_ub = j + b_i;
          load[loop_ub] =
              load[loop_ub] +
              a * b_sfe->shapes_sol[b_i + b_sfe->shapes_sol.size(1) * q];
        }
        j = (j + n) + 1;
      }
    }
  } else {
    //  tensor blocks of DOFs, not component-wise
    i = b_sfe->nqp;
    for (int32_T q{0}; q < i; q++) {
      real_T wdetj;
      wdetj = b_sfe->wdetJ[q];
      for (int32_T k{0}; k < ncomps; k++) {
        real_T a;
        real_T v;
        int32_T m;
        // interpolate_shape - Interpolate f with q-th shape function in the
        // table
        //
        //    v = interpolate_shape(shapes, q, f)
        //    v = interpolate_shape(shapes, q, f, k)
        m = b_sfe->shapes_sol.size(1);
        v = b_sfe->shapes_sol[b_sfe->shapes_sol.size(1) * q] * g[k];
        for (int32_T b_i{2}; b_i <= m; b_i++) {
          v += b_sfe->shapes_sol[(b_i + b_sfe->shapes_sol.size(1) * q) - 1] *
               g[k + g.size(1) * (b_i - 1)];
        }
        a = v * wdetj;
        for (int32_T b_i{0}; b_i <= n; b_i++) {
          load[k + b_i * ncomps] =
              load[k + b_i * ncomps] +
              a * b_sfe->shapes_sol[b_i + b_sfe->shapes_sol.size(1) * q];
        }
      }
    }
  }
}

void sfe_elem_stiff1(SfeObject *b_sfe, real_T nu,
                     ::coder::array<real_T, 2U> &elemmat)
{
  int32_T i;
  int32_T loop_ub;
  int32_T m;
  // sfe_elem_stiff - Compute the element-wise stiffness matrix
  //
  //    [sfe, elemmat] = sfe_elem_stiff(sfe, nu)
  //    [sfe, elemmat] = sfe_elem_stiff(sfe, nu, vel)
  //    [sfe, elemmat] = sfe_elem_stiff(sfe, nu, [], int32(1))
  //    [sfe, elemmat] = sfe_elem_stiff(sfe, nu, vel, int32(2))
  //    [sfe, elemmat] = sfe_elem_stiff(sfe, nu, vel, coefftag)
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An initialized SfeObject instance
  //    nu:         Diffusion coefficient
  //    vel:        Advection velocities
  //    coefftag:   Tag indicating coefficient properties (const vs. varied)
  //
  //  RETURNS
  //  -------
  //    sfe:        Gradient fields need to be computed
  //    elemmat:    Local element stiffness matrix
  //
  //  NOTES
  //  -----
  //  This function computes the scalar advection-diffusion operator:
  //                inner(vel,grad(u))-nu*lap(u)
  //  where nu and vel are diffusion coefficient and velocity fields,
  //  respectively. The FE discretization of such operator results in a
  //  (generalized) stiffness matrix. Note that if the velocity fields are
  //  omitted, then this corresponds to the standard stiffness matrix.
  //
  //  In particular, this function supports both constant nu and vel and
  //  spatial varied nu and vel with an element.
  //
  //    sfe_elem_stiff(sfe, nu) omits the advection term and only computes
  //    the diffusion term with a constant nu.
  //
  //    sfe = sfe_elem_stiff(sfe, nu, vel) adds the advection term besides the
  //    diffusion term with a constant velocity field (stored in 1xd)
  //
  //    sfe = sfe_elem_stiff(sfe, nu, [], int32(1)) is similar to the first one
  //    but with a spatial varied nu.
  //
  //    sfe = sfe_elem_stiff(sfe, nu, vel, int32(2)) is similar to the second
  //    one but with a spatial varied velocity field (stored in inf-by-d)
  //
  //  The above four variants are highly optimized. In general, the last
  //  parameter coefftag is an integer whose first two bits denote the
  //  constantness of nu and vel, respectively. 0b01 is the mask for spatial
  //  varied nu and 0b10 is the mask for spatial varied velocity.
  //
  //  See also SfeObject, sfe_elem_mass
  m = b_sfe->nnodes[0] - 1;
  elemmat.set_size(b_sfe->nnodes[0], b_sfe->nnodes[0]);
  loop_ub = b_sfe->nnodes[0] * b_sfe->nnodes[0];
  for (i = 0; i < loop_ub; i++) {
    elemmat[i] = 0.0;
  }
  //  for each qpoint
  i = b_sfe->nqp;
  for (int32_T q{0}; q < i; q++) {
    real_T stiff_coeff;
    //  initialize gradients at this qpoint
    sfe_init_grad(b_sfe, q + 1);
    //  get weighted volume
    //  Stiffness part
    stiff_coeff = nu * b_sfe->wdetJ[q];
    for (int32_T b_i{0}; b_i <= m; b_i++) {
      for (int32_T j{0}; j <= m; j++) {
        loop_ub = b_sfe->geom_dim;
        for (int32_T k{0}; k < loop_ub; k++) {
          elemmat[j + elemmat.size(1) * b_i] =
              elemmat[j + elemmat.size(1) * b_i] +
              stiff_coeff * b_sfe->grads_sol[k + b_sfe->grads_sol.size(1) * j] *
                  b_sfe->grads_sol[k + b_sfe->grads_sol.size(1) * b_i];
        }
      }
    }
    //  Convection part
  }
}

void sfe_elem_stiff2(SfeObject *b_sfe, real_T nu, const real_T vel_data[],
                     const int32_T vel_size[2],
                     ::coder::array<real_T, 2U> &elemmat)
{
  real_T vel_coeff_data[3];
  int32_T i;
  int32_T loop_ub;
  int32_T m;
  // sfe_elem_stiff - Compute the element-wise stiffness matrix
  //
  //    [sfe, elemmat] = sfe_elem_stiff(sfe, nu)
  //    [sfe, elemmat] = sfe_elem_stiff(sfe, nu, vel)
  //    [sfe, elemmat] = sfe_elem_stiff(sfe, nu, [], int32(1))
  //    [sfe, elemmat] = sfe_elem_stiff(sfe, nu, vel, int32(2))
  //    [sfe, elemmat] = sfe_elem_stiff(sfe, nu, vel, coefftag)
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An initialized SfeObject instance
  //    nu:         Diffusion coefficient
  //    vel:        Advection velocities
  //    coefftag:   Tag indicating coefficient properties (const vs. varied)
  //
  //  RETURNS
  //  -------
  //    sfe:        Gradient fields need to be computed
  //    elemmat:    Local element stiffness matrix
  //
  //  NOTES
  //  -----
  //  This function computes the scalar advection-diffusion operator:
  //                inner(vel,grad(u))-nu*lap(u)
  //  where nu and vel are diffusion coefficient and velocity fields,
  //  respectively. The FE discretization of such operator results in a
  //  (generalized) stiffness matrix. Note that if the velocity fields are
  //  omitted, then this corresponds to the standard stiffness matrix.
  //
  //  In particular, this function supports both constant nu and vel and
  //  spatial varied nu and vel with an element.
  //
  //    sfe_elem_stiff(sfe, nu) omits the advection term and only computes
  //    the diffusion term with a constant nu.
  //
  //    sfe = sfe_elem_stiff(sfe, nu, vel) adds the advection term besides the
  //    diffusion term with a constant velocity field (stored in 1xd)
  //
  //    sfe = sfe_elem_stiff(sfe, nu, [], int32(1)) is similar to the first one
  //    but with a spatial varied nu.
  //
  //    sfe = sfe_elem_stiff(sfe, nu, vel, int32(2)) is similar to the second
  //    one but with a spatial varied velocity field (stored in inf-by-d)
  //
  //  The above four variants are highly optimized. In general, the last
  //  parameter coefftag is an integer whose first two bits denote the
  //  constantness of nu and vel, respectively. 0b01 is the mask for spatial
  //  varied nu and 0b10 is the mask for spatial varied velocity.
  //
  //  See also SfeObject, sfe_elem_mass
  m = b_sfe->nnodes[0] - 1;
  elemmat.set_size(b_sfe->nnodes[0], b_sfe->nnodes[0]);
  loop_ub = b_sfe->nnodes[0] * b_sfe->nnodes[0];
  for (i = 0; i < loop_ub; i++) {
    elemmat[i] = 0.0;
  }
  //  for each qpoint
  i = b_sfe->nqp;
  for (int32_T q{0}; q < i; q++) {
    real_T stiff_coeff;
    //  initialize gradients at this qpoint
    sfe_init_grad(b_sfe, q + 1);
    //  get weighted volume
    //  Stiffness part
    stiff_coeff = nu * b_sfe->wdetJ[q];
    for (int32_T b_i{0}; b_i <= m; b_i++) {
      for (int32_T j{0}; j <= m; j++) {
        loop_ub = b_sfe->geom_dim;
        for (int32_T k{0}; k < loop_ub; k++) {
          elemmat[j + elemmat.size(1) * b_i] =
              elemmat[j + elemmat.size(1) * b_i] +
              stiff_coeff * b_sfe->grads_sol[k + b_sfe->grads_sol.size(1) * j] *
                  b_sfe->grads_sol[k + b_sfe->grads_sol.size(1) * b_i];
        }
      }
    }
    //  Convection part
    loop_ub = vel_size[1];
    if (vel_size[1] != 0) {
      std::copy(&vel_data[0], &vel_data[loop_ub], &vel_coeff_data[0]);
      //  scale with weighted volume
      loop_ub = b_sfe->geom_dim;
      for (int32_T k{0}; k < loop_ub; k++) {
        vel_coeff_data[k] *= b_sfe->wdetJ[q];
      }
      for (int32_T b_i{0}; b_i <= m; b_i++) {
        real_T psi;
        psi = b_sfe->shapes_sol[b_i + b_sfe->shapes_sol.size(1) * q];
        for (int32_T j{0}; j <= m; j++) {
          for (int32_T k{0}; k < loop_ub; k++) {
            elemmat[j + elemmat.size(1) * b_i] =
                elemmat[j + elemmat.size(1) * b_i] +
                vel_coeff_data[k] *
                    b_sfe->grads_sol[k + b_sfe->grads_sol.size(1) * j] * psi;
          }
        }
      }
    }
  }
}

void sfe_elem_stiff3(SfeObject *b_sfe, const ::coder::array<real_T, 1U> &nu,
                     ::coder::array<real_T, 2U> &elemmat)
{
  int32_T i;
  int32_T loop_ub;
  int32_T m;
  // sfe_elem_stiff - Compute the element-wise stiffness matrix
  //
  //    [sfe, elemmat] = sfe_elem_stiff(sfe, nu)
  //    [sfe, elemmat] = sfe_elem_stiff(sfe, nu, vel)
  //    [sfe, elemmat] = sfe_elem_stiff(sfe, nu, [], int32(1))
  //    [sfe, elemmat] = sfe_elem_stiff(sfe, nu, vel, int32(2))
  //    [sfe, elemmat] = sfe_elem_stiff(sfe, nu, vel, coefftag)
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An initialized SfeObject instance
  //    nu:         Diffusion coefficient
  //    vel:        Advection velocities
  //    coefftag:   Tag indicating coefficient properties (const vs. varied)
  //
  //  RETURNS
  //  -------
  //    sfe:        Gradient fields need to be computed
  //    elemmat:    Local element stiffness matrix
  //
  //  NOTES
  //  -----
  //  This function computes the scalar advection-diffusion operator:
  //                inner(vel,grad(u))-nu*lap(u)
  //  where nu and vel are diffusion coefficient and velocity fields,
  //  respectively. The FE discretization of such operator results in a
  //  (generalized) stiffness matrix. Note that if the velocity fields are
  //  omitted, then this corresponds to the standard stiffness matrix.
  //
  //  In particular, this function supports both constant nu and vel and
  //  spatial varied nu and vel with an element.
  //
  //    sfe_elem_stiff(sfe, nu) omits the advection term and only computes
  //    the diffusion term with a constant nu.
  //
  //    sfe = sfe_elem_stiff(sfe, nu, vel) adds the advection term besides the
  //    diffusion term with a constant velocity field (stored in 1xd)
  //
  //    sfe = sfe_elem_stiff(sfe, nu, [], int32(1)) is similar to the first one
  //    but with a spatial varied nu.
  //
  //    sfe = sfe_elem_stiff(sfe, nu, vel, int32(2)) is similar to the second
  //    one but with a spatial varied velocity field (stored in inf-by-d)
  //
  //  The above four variants are highly optimized. In general, the last
  //  parameter coefftag is an integer whose first two bits denote the
  //  constantness of nu and vel, respectively. 0b01 is the mask for spatial
  //  varied nu and 0b10 is the mask for spatial varied velocity.
  //
  //  See also SfeObject, sfe_elem_mass
  m = b_sfe->nnodes[0] - 1;
  elemmat.set_size(b_sfe->nnodes[0], b_sfe->nnodes[0]);
  loop_ub = b_sfe->nnodes[0] * b_sfe->nnodes[0];
  for (i = 0; i < loop_ub; i++) {
    elemmat[i] = 0.0;
  }
  //  for each qpoint
  i = b_sfe->nqp;
  for (int32_T q{0}; q < i; q++) {
    real_T stiff_coeff;
    //  initialize gradients at this qpoint
    sfe_init_grad(b_sfe, q + 1);
    //  get weighted volume
    //  Stiffness part
    if (nu.size(0) == 1) {
      stiff_coeff = nu[0] * b_sfe->wdetJ[q];
    } else {
      real_T v;
      int32_T b_m;
      // interpolate_shape - Interpolate f with q-th shape function in the table
      //
      //    v = interpolate_shape(shapes, q, f)
      //    v = interpolate_shape(shapes, q, f, k)
      b_m = b_sfe->shapes_sol.size(1);
      v = b_sfe->shapes_sol[b_sfe->shapes_sol.size(1) * q] * nu[0];
      for (int32_T b_i{2}; b_i <= b_m; b_i++) {
        v += b_sfe->shapes_sol[(b_i + b_sfe->shapes_sol.size(1) * q) - 1] *
             nu[b_i - 1];
      }
      stiff_coeff = v * b_sfe->wdetJ[q];
    }
    for (int32_T b_i{0}; b_i <= m; b_i++) {
      for (int32_T j{0}; j <= m; j++) {
        loop_ub = b_sfe->geom_dim;
        for (int32_T k{0}; k < loop_ub; k++) {
          elemmat[j + elemmat.size(1) * b_i] =
              elemmat[j + elemmat.size(1) * b_i] +
              stiff_coeff * b_sfe->grads_sol[k + b_sfe->grads_sol.size(1) * j] *
                  b_sfe->grads_sol[k + b_sfe->grads_sol.size(1) * b_i];
        }
      }
    }
    //  Convection part
  }
}

void sfe_elem_stiff4(SfeObject *b_sfe, real_T nu,
                     const ::coder::array<real_T, 2U> &vel,
                     ::coder::array<real_T, 2U> &elemmat)
{
  int32_T i;
  int32_T loop_ub;
  int32_T m;
  // sfe_elem_stiff - Compute the element-wise stiffness matrix
  //
  //    [sfe, elemmat] = sfe_elem_stiff(sfe, nu)
  //    [sfe, elemmat] = sfe_elem_stiff(sfe, nu, vel)
  //    [sfe, elemmat] = sfe_elem_stiff(sfe, nu, [], int32(1))
  //    [sfe, elemmat] = sfe_elem_stiff(sfe, nu, vel, int32(2))
  //    [sfe, elemmat] = sfe_elem_stiff(sfe, nu, vel, coefftag)
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An initialized SfeObject instance
  //    nu:         Diffusion coefficient
  //    vel:        Advection velocities
  //    coefftag:   Tag indicating coefficient properties (const vs. varied)
  //
  //  RETURNS
  //  -------
  //    sfe:        Gradient fields need to be computed
  //    elemmat:    Local element stiffness matrix
  //
  //  NOTES
  //  -----
  //  This function computes the scalar advection-diffusion operator:
  //                inner(vel,grad(u))-nu*lap(u)
  //  where nu and vel are diffusion coefficient and velocity fields,
  //  respectively. The FE discretization of such operator results in a
  //  (generalized) stiffness matrix. Note that if the velocity fields are
  //  omitted, then this corresponds to the standard stiffness matrix.
  //
  //  In particular, this function supports both constant nu and vel and
  //  spatial varied nu and vel with an element.
  //
  //    sfe_elem_stiff(sfe, nu) omits the advection term and only computes
  //    the diffusion term with a constant nu.
  //
  //    sfe = sfe_elem_stiff(sfe, nu, vel) adds the advection term besides the
  //    diffusion term with a constant velocity field (stored in 1xd)
  //
  //    sfe = sfe_elem_stiff(sfe, nu, [], int32(1)) is similar to the first one
  //    but with a spatial varied nu.
  //
  //    sfe = sfe_elem_stiff(sfe, nu, vel, int32(2)) is similar to the second
  //    one but with a spatial varied velocity field (stored in inf-by-d)
  //
  //  The above four variants are highly optimized. In general, the last
  //  parameter coefftag is an integer whose first two bits denote the
  //  constantness of nu and vel, respectively. 0b01 is the mask for spatial
  //  varied nu and 0b10 is the mask for spatial varied velocity.
  //
  //  See also SfeObject, sfe_elem_mass
  m = b_sfe->nnodes[0] - 1;
  elemmat.set_size(b_sfe->nnodes[0], b_sfe->nnodes[0]);
  loop_ub = b_sfe->nnodes[0] * b_sfe->nnodes[0];
  for (i = 0; i < loop_ub; i++) {
    elemmat[i] = 0.0;
  }
  //  for each qpoint
  i = b_sfe->nqp;
  for (int32_T q{0}; q < i; q++) {
    real_T stiff_coeff;
    int32_T i1;
    //  initialize gradients at this qpoint
    sfe_init_grad(b_sfe, q + 1);
    //  get weighted volume
    //  Stiffness part
    stiff_coeff = nu * b_sfe->wdetJ[q];
    for (int32_T b_i{0}; b_i <= m; b_i++) {
      for (int32_T j{0}; j <= m; j++) {
        i1 = b_sfe->geom_dim;
        for (int32_T k{0}; k < i1; k++) {
          elemmat[j + elemmat.size(1) * b_i] =
              elemmat[j + elemmat.size(1) * b_i] +
              stiff_coeff * b_sfe->grads_sol[k + b_sfe->grads_sol.size(1) * j] *
                  b_sfe->grads_sol[k + b_sfe->grads_sol.size(1) * b_i];
        }
      }
    }
    //  Convection part
    if ((vel.size(0) != 0) && (vel.size(1) != 0)) {
      real_T vel_coeff_data[3];
      if (vel.size(0) == 1) {
        loop_ub = vel.size(1);
        for (i1 = 0; i1 < loop_ub; i1++) {
          vel_coeff_data[i1] = vel[i1];
        }
      } else {
        i1 = b_sfe->geom_dim;
        for (int32_T k{0}; k < i1; k++) {
          real_T v;
          int32_T b_m;
          // interpolate_shape - Interpolate f with q-th shape function in the
          // table
          //
          //    v = interpolate_shape(shapes, q, f)
          //    v = interpolate_shape(shapes, q, f, k)
          b_m = b_sfe->shapes_sol.size(1);
          v = b_sfe->shapes_sol[b_sfe->shapes_sol.size(1) * q] * vel[k];
          for (int32_T b_i{2}; b_i <= b_m; b_i++) {
            v += b_sfe->shapes_sol[(b_i + b_sfe->shapes_sol.size(1) * q) - 1] *
                 vel[k + vel.size(1) * (b_i - 1)];
          }
          vel_coeff_data[k] = v;
        }
      }
      //  scale with weighted volume
      i1 = b_sfe->geom_dim;
      for (int32_T k{0}; k < i1; k++) {
        vel_coeff_data[k] *= b_sfe->wdetJ[q];
      }
      for (int32_T b_i{0}; b_i <= m; b_i++) {
        real_T psi;
        psi = b_sfe->shapes_sol[b_i + b_sfe->shapes_sol.size(1) * q];
        for (int32_T j{0}; j <= m; j++) {
          for (int32_T k{0}; k < i1; k++) {
            elemmat[j + elemmat.size(1) * b_i] =
                elemmat[j + elemmat.size(1) * b_i] +
                vel_coeff_data[k] *
                    b_sfe->grads_sol[k + b_sfe->grads_sol.size(1) * j] * psi;
          }
        }
      }
    }
  }
}

void sfe_elem_stiff5(SfeObject *b_sfe, const ::coder::array<real_T, 1U> &nu,
                     const ::coder::array<real_T, 2U> &vel, int32_T coefftag,
                     ::coder::array<real_T, 2U> &elemmat)
{
  int32_T i;
  int32_T loop_ub;
  int32_T m;
  // sfe_elem_stiff - Compute the element-wise stiffness matrix
  //
  //    [sfe, elemmat] = sfe_elem_stiff(sfe, nu)
  //    [sfe, elemmat] = sfe_elem_stiff(sfe, nu, vel)
  //    [sfe, elemmat] = sfe_elem_stiff(sfe, nu, [], int32(1))
  //    [sfe, elemmat] = sfe_elem_stiff(sfe, nu, vel, int32(2))
  //    [sfe, elemmat] = sfe_elem_stiff(sfe, nu, vel, coefftag)
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An initialized SfeObject instance
  //    nu:         Diffusion coefficient
  //    vel:        Advection velocities
  //    coefftag:   Tag indicating coefficient properties (const vs. varied)
  //
  //  RETURNS
  //  -------
  //    sfe:        Gradient fields need to be computed
  //    elemmat:    Local element stiffness matrix
  //
  //  NOTES
  //  -----
  //  This function computes the scalar advection-diffusion operator:
  //                inner(vel,grad(u))-nu*lap(u)
  //  where nu and vel are diffusion coefficient and velocity fields,
  //  respectively. The FE discretization of such operator results in a
  //  (generalized) stiffness matrix. Note that if the velocity fields are
  //  omitted, then this corresponds to the standard stiffness matrix.
  //
  //  In particular, this function supports both constant nu and vel and
  //  spatial varied nu and vel with an element.
  //
  //    sfe_elem_stiff(sfe, nu) omits the advection term and only computes
  //    the diffusion term with a constant nu.
  //
  //    sfe = sfe_elem_stiff(sfe, nu, vel) adds the advection term besides the
  //    diffusion term with a constant velocity field (stored in 1xd)
  //
  //    sfe = sfe_elem_stiff(sfe, nu, [], int32(1)) is similar to the first one
  //    but with a spatial varied nu.
  //
  //    sfe = sfe_elem_stiff(sfe, nu, vel, int32(2)) is similar to the second
  //    one but with a spatial varied velocity field (stored in inf-by-d)
  //
  //  The above four variants are highly optimized. In general, the last
  //  parameter coefftag is an integer whose first two bits denote the
  //  constantness of nu and vel, respectively. 0b01 is the mask for spatial
  //  varied nu and 0b10 is the mask for spatial varied velocity.
  //
  //  See also SfeObject, sfe_elem_mass
  m = b_sfe->nnodes[0] - 1;
  elemmat.set_size(b_sfe->nnodes[0], b_sfe->nnodes[0]);
  loop_ub = b_sfe->nnodes[0] * b_sfe->nnodes[0];
  for (i = 0; i < loop_ub; i++) {
    elemmat[i] = 0.0;
  }
  //  for each qpoint
  i = b_sfe->nqp;
  for (int32_T q{0}; q < i; q++) {
    real_T stiff_coeff;
    real_T v;
    int32_T b_m;
    int32_T i1;
    //  initialize gradients at this qpoint
    sfe_init_grad(b_sfe, q + 1);
    //  get weighted volume
    //  Stiffness part
    if ((coefftag & 1) == 1) {
      if (nu.size(0) == 1) {
        stiff_coeff = nu[0] * b_sfe->wdetJ[q];
      } else {
        // interpolate_shape - Interpolate f with q-th shape function in the
        // table
        //
        //    v = interpolate_shape(shapes, q, f)
        //    v = interpolate_shape(shapes, q, f, k)
        b_m = b_sfe->shapes_sol.size(1);
        v = b_sfe->shapes_sol[b_sfe->shapes_sol.size(1) * q] * nu[0];
        for (int32_T b_i{2}; b_i <= b_m; b_i++) {
          v += b_sfe->shapes_sol[(b_i + b_sfe->shapes_sol.size(1) * q) - 1] *
               nu[b_i - 1];
        }
        stiff_coeff = v * b_sfe->wdetJ[q];
      }
    } else {
      stiff_coeff = nu[0] * b_sfe->wdetJ[q];
    }
    for (int32_T b_i{0}; b_i <= m; b_i++) {
      for (int32_T j{0}; j <= m; j++) {
        i1 = b_sfe->geom_dim;
        for (int32_T k{0}; k < i1; k++) {
          elemmat[j + elemmat.size(1) * b_i] =
              elemmat[j + elemmat.size(1) * b_i] +
              stiff_coeff * b_sfe->grads_sol[k + b_sfe->grads_sol.size(1) * j] *
                  b_sfe->grads_sol[k + b_sfe->grads_sol.size(1) * b_i];
        }
      }
    }
    //  Convection part
    if ((vel.size(0) != 0) && (vel.size(1) != 0)) {
      real_T vel_coeff_data[3];
      if ((coefftag >> 1 & 1) == 1) {
        if (vel.size(0) == 1) {
          loop_ub = vel.size(1);
          for (i1 = 0; i1 < loop_ub; i1++) {
            vel_coeff_data[i1] = vel[i1];
          }
        } else {
          i1 = b_sfe->geom_dim;
          for (int32_T k{0}; k < i1; k++) {
            // interpolate_shape - Interpolate f with q-th shape function in the
            // table
            //
            //    v = interpolate_shape(shapes, q, f)
            //    v = interpolate_shape(shapes, q, f, k)
            b_m = b_sfe->shapes_sol.size(1);
            v = b_sfe->shapes_sol[b_sfe->shapes_sol.size(1) * q] * vel[k];
            for (int32_T b_i{2}; b_i <= b_m; b_i++) {
              v +=
                  b_sfe->shapes_sol[(b_i + b_sfe->shapes_sol.size(1) * q) - 1] *
                  vel[k + vel.size(1) * (b_i - 1)];
            }
            vel_coeff_data[k] = v;
          }
        }
      } else {
        loop_ub = vel.size(1) * vel.size(0);
        for (i1 = 0; i1 < loop_ub; i1++) {
          vel_coeff_data[i1] = vel[i1];
        }
      }
      //  scale with weighted volume
      i1 = b_sfe->geom_dim;
      for (int32_T k{0}; k < i1; k++) {
        vel_coeff_data[k] *= b_sfe->wdetJ[q];
      }
      for (int32_T b_i{0}; b_i <= m; b_i++) {
        real_T psi;
        psi = b_sfe->shapes_sol[b_i + b_sfe->shapes_sol.size(1) * q];
        for (int32_T j{0}; j <= m; j++) {
          for (int32_T k{0}; k < i1; k++) {
            elemmat[j + elemmat.size(1) * b_i] =
                elemmat[j + elemmat.size(1) * b_i] +
                vel_coeff_data[k] *
                    b_sfe->grads_sol[k + b_sfe->grads_sol.size(1) * j] * psi;
          }
        }
      }
    }
  }
}

real_T sfe_eval_div1(const SfeObject *b_sfe,
                     const ::coder::array<real_T, 2U> &fs)
{
  real_T d;
  int32_T i;
  boolean_T cond;
  // sfe_eval_grads - Evaluate the divergence of a vector-field function
  //
  //    d = sfe_eval_div(sfe, fs)
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An SfeObject instance, must be initialized and gradients
  //                must be computed
  //    fs:         A vector-field function defined in the trial space. The
  //                dimension of fs is n-by-d, where n is the number of nodes
  //                of an element associated in the trial space, and d is the
  //                geometric dimension
  //
  //  RETURN
  //  ------
  //    d:          The divergence value, scalar field
  //
  //  NOTES
  //  -----
  //  Besides the requirement of initialization, this function must be called
  //  after finishing the computation of gradients of trial functions.
  //
  //  Keep in mind that the gradients of trial basis functions are computed per
  //  quadrature point, thus this function is called within the loops over
  //  quadrature points.
  //
  //  See also sfe_init, sfe_grad
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert((b_sfe->grads_sol.size(0) != 0) && (b_sfe->grads_sol.size(1) != 0),
            "miss trial gradient fields");
  if ((b_sfe->nnodes[0] == fs.size(0)) && (fs.size(1) == b_sfe->geom_dim)) {
    cond = true;
  } else {
    cond = false;
  }
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(cond, "");
  d = 0.0;
  i = b_sfe->nnodes[0];
  for (int32_T j{0}; j < i; j++) {
    int32_T i1;
    i1 = b_sfe->geom_dim;
    for (int32_T k{0}; k < i1; k++) {
      d += b_sfe->grads_sol[k + b_sfe->grads_sol.size(1) * j] *
           fs[k + fs.size(1) * j];
    }
  }
  return d;
}

void sfe_eval_funcs1(const SfeObject *b_sfe, int32_T q,
                     const ::coder::array<real_T, 2U> &fs,
                     ::coder::array<real_T, 2U> &vals)
{
  int32_T m;
  int32_T nrhs;
  // sfe_eval_funcs - Evaluate a set of discrete function values
  //
  //    vals = sfe_eval_funcs(sfe, q, fs)
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An SfeObject instance, must be initialized
  //    q:          Quadrature point index, [1,sfe.nqp]
  //    fs:         A set of function values defined in the trial space. The
  //                dimension of fs is n-by-m, where n is the number of nodes
  //                of an element associated in the trial space, and m is the
  //                number of function fields
  //
  //  RETURN
  //  ------
  //    vals:       Function values at the q-th qpoint in the sfe instance, and
  //                its shape is 1-by-m
  //
  //  NOTES
  //  -----
  //  This function must be called after initialization of an SfeObject instance
  //
  //  See also sfe_init
  // interpolate_shape - Interpolate f with q-th shape function in the table
  //
  //    v = interpolate_shape(shapes, q, f)
  //    v = interpolate_shape(shapes, q, f, k)
  m = b_sfe->shapes_sol.size(1);
  nrhs = fs.size(1) - 1;
  vals.set_size(1, fs.size(1));
  for (int32_T j{0}; j <= nrhs; j++) {
    vals[j] = b_sfe->shapes_sol[b_sfe->shapes_sol.size(1) * (q - 1)] * fs[j];
  }
  for (int32_T i{2}; i <= m; i++) {
    real_T Ni;
    Ni = b_sfe->shapes_sol[(i + b_sfe->shapes_sol.size(1) * (q - 1)) - 1];
    for (int32_T j{0}; j <= nrhs; j++) {
      vals[j] = vals[j] + Ni * fs[j + fs.size(1) * (i - 1)];
    }
  }
}

void sfe_eval_grads1(const SfeObject *b_sfe,
                     const ::coder::array<real_T, 2U> &fs,
                     ::coder::array<real_T, 2U> &grads)
{
  int32_T m;
  // sfe_eval_grads - Evaluate the gradients of a set of function fields
  //
  //    grads = sfe_eval_grads(sfe, fs)
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An SfeObject instance, must be initialized and gradients
  //                must be computed
  //    fs:         A set of function values defined in the trial space. The
  //                dimension of fs is n-by-m, where n is the number of nodes
  //                of an element associated in the trial space, and m is the
  //                number of function fields
  //
  //  RETURN
  //  ------
  //    grads:      The gradient tensor of shape dim-by-m
  //
  //  NOTES
  //  -----
  //  Besides the requirement of initialization, this function must be called
  //  after finishing the computation of gradients of trial functions.
  //
  //  Keep in mind that the gradients of trial basis functions are computed per
  //  quadrature point, thus this function is called within the loops over
  //  quadrature points.
  //
  //  See also sfe_init, sfe_grad
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert((b_sfe->grads_sol.size(0) != 0) && (b_sfe->grads_sol.size(1) != 0),
            "miss trial gradient fields");
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(b_sfe->nnodes[0] == fs.size(0), "");
  m = fs.size(1);
  grads.set_size(b_sfe->geom_dim, fs.size(1));
  for (int32_T i{0}; i < m; i++) {
    int32_T b_i;
    b_i = b_sfe->geom_dim;
    for (int32_T k{0}; k < b_i; k++) {
      real_T v;
      int32_T i1;
      v = 0.0;
      i1 = b_sfe->nnodes[0];
      for (int32_T j{0}; j < i1; j++) {
        v += b_sfe->grads_sol[k + b_sfe->grads_sol.size(1) * j] *
             fs[i + fs.size(1) * j];
      }
      grads[i + grads.size(1) * k] = v;
    }
  }
}

void sfe_init1(SfeObject *b_sfe, int32_T etypes,
               const ::coder::array<real_T, 2U> &xs, int32_T qd_or_natcoords,
               const ::coder::array<real_T, 2U> &userquad)
{
  real_T dv[9];
  real_T v;
  int32_T i;
  int32_T i1;
  int32_T qd_or_natcoords_tmp;
  int32_T shape;
  int32_T topo_dim;
  // sfe_init - Initialize/reinitialize an sfe object for non-boundary element
  //
  //    sfe = sfe_init(sfe, etypes, xs)
  //    sfe = sfe_init(sfe, etypes, xs, natcoords)
  //    sfe = sfe_init(sfe, etypes, xs, qd)
  //    sfe = sfe_init(sfe, etypes, xs, qd, userquad)
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An SfeObject instance
  //    etypes:     Element type(s), which can be a 2-vector, scalar, or [].
  //                A 2-vector specifies the solution and geometric element
  //                types, and it supports iso-, sub- and super-parametric
  //                elements. If two element types are equal, then one can use a
  //                scalar. An empty array ([]) instructs the function to reuse
  //                the element type and the tabulation stored in the `sfe`
  //                object (typically from a previous call).
  //    xs:         Physical coordinates of the element, which is defined in
  //                the geometric space
  //    qd:         Quadrature degree, a zero value indicate the use of default
  //                quadrature rules based on the element types. If `-1` is
  //                passed in, then the code will assume user-provided
  //                quadrature rule information
  //    userquad:   This field is only accessed if qd=-1. If provided, then
  //    userquad
  //                must be a nqp-by-(1+dim) array, where the first column
  //                vector is is the quadrature weights while the rest are their
  //                corresponding quadrature points, defined in the reference
  //                element.
  //
  //  In particular, the user can pass in specific natural coordinates on which
  //  we will compute shape functions and derivatives. In this situation, we
  //  will skip the computation of Jacobian.
  //
  //    natcoords:  List of natural coordinates defined by the user
  //
  //  EXAMPLES
  //  --------
  //  The following initializes a linear triangular element
  //
  //    >> sfe = sfe_init(SfeObject(0), SFE_TRI_3, xs);
  //
  //  The following initializes a quadratic tetrahedral element but with linear
  //  geometry
  //
  //    >> etypes = [SFE_TET_10; SFE_TET_4];
  //    >> sfe = sfe_init(SfeObject(0), etypes, xs);
  //
  //  The following initializes a bi-linear quadrilateral element with
  //  user-provided gravity quadrature rule
  //
  //    >> gravrule = [1, 0.5, 0.5];
  //    >> sfe = sfe_init(SfeObject(0), SFE_QUAD_4, xs, int32(-1), gravrule);
  //
  //  See also SfeObject, ElementTypes, sfe_init_grad
  //  For clarity
  //  Determine solution and geometric spaces
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(true, "invalid element combinations");
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  //  Geometric dimension
  //  Topological dimension
  // obtain_elemdim - Obtain the dimension of an element
  //
  //    dim = obtain_elemdim(etype)
  //
  //  See also obtain_elemshape
  // obtain_elemshape - Decode an element geometric shape from etype
  //
  //    shapeid = obtain_elemshape(etype)
  //
  //  RETURN
  //  ------
  //    shapeid:    Integer type of different geometry shapes:
  //                    1 - BAR
  //                    2 - TRI
  //                    3 - QUAD
  //                    4 - TET
  //                    5 - PYRAMID
  //                    6 - PRISM
  //                    7 - HEX
  //
  //  See also obtain_elemdim
  //  shapeid = (etype>>5)&0b111
  shape = etypes >> 5;
  topo_dim = ((shape > 0) + (shape > 1)) + (shape > 3);
  //  Geometric dimension
  if (xs.size(1) < topo_dim) {
    //  m2cError  Throw error and display message in MATLAB or C++
    //
    //     m2cError(format)
    //     m2cError(format,A1,...,An)
    //     m2cError(errID,___)
    //
    //  This function has the same interface as MATLAB's built-in `error`,
    //  except that the `format` must be a constant string during code
    //  generation.
    //
    //  Notes
    //  -----
    //  The format must be a constant string during code-generation time.
    //
    //  See also error, m2cWarning
    m2cErrMsgIdAndTxt("sfe_init:badDim",
                      "geometric dim cannot be smaller than topo dim");
  }
  b_sfe->geom_dim = xs.size(1);
  //  assign geom dimension
  b_sfe->topo_dim = topo_dim;
  //  assign topo dimension
  //  Make sure the coordinate size are the same
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(iv[etypes - 1] == xs.size(0), "nnodes do not match");
  b_sfe->etypes[0] = etypes;
  b_sfe->etypes[1] = etypes;
  //  Get number of nodes per element
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  i = iv[etypes - 1];
  b_sfe->nnodes[0] = i;
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  b_sfe->nnodes[1] = i;
  //  Set up quadrature
  if (qd_or_natcoords != -1) {
    if (qd_or_natcoords == 0) {
      //  trial+test+nonlinear_geom?1:0
      //  NOTE, this might be overkill for gradient
      // obtain_elemdegree - Decode the element degree from etype
      //
      //    deg = obtain_elemdegree(etype)
      //
      //  See also obtain_elemnnodes
      //  deg = (etype>>2)&0b111;
      // obtain_elemdegree - Decode the element degree from etype
      //
      //    deg = obtain_elemdegree(etype)
      //
      //  See also obtain_elemnnodes
      //  deg = (etype>>2)&0b111;
      qd_or_natcoords_tmp = etypes >> 2 & 7;
      qd_or_natcoords =
          ((qd_or_natcoords_tmp << 1) + (qd_or_natcoords_tmp > 1)) +
          (xs.size(1) > topo_dim);
    }
    tabulate_quadratures(etypes, qd_or_natcoords, b_sfe->cs, b_sfe->ws);
    b_sfe->nqp = b_sfe->ws.size(0);
  } else {
    if ((userquad.size(0) == 0) || (userquad.size(1) == 0)) {
      //  m2cError  Throw error and display message in MATLAB or C++
      //
      //     m2cError(format)
      //     m2cError(format,A1,...,An)
      //     m2cError(errID,___)
      //
      //  This function has the same interface as MATLAB's built-in `error`,
      //  except that the `format` must be a constant string during code
      //  generation.
      //
      //  Notes
      //  -----
      //  The format must be a constant string during code-generation time.
      //
      //  See also error, m2cWarning
      m2cErrMsgIdAndTxt("sfe_init:missUserQuad",
                        "missing user quadrature data");
    }
    if (userquad.size(1) != topo_dim + 1) {
      //  m2cError  Throw error and display message in MATLAB or C++
      //
      //     m2cError(format)
      //     m2cError(format,A1,...,An)
      //     m2cError(errID,___)
      //
      //  This function has the same interface as MATLAB's built-in `error`,
      //  except that the `format` must be a constant string during code
      //  generation.
      //
      //  Notes
      //  -----
      //  The format must be a constant string during code-generation time.
      //
      //  See also error, m2cWarning
      m2cErrMsgIdAndTxt("sfe_init:badUserQuadDim",
                        "bad user quadrature data size");
    }
    b_sfe->nqp = userquad.size(0);
    b_sfe->ws.set_size(userquad.size(0));
    b_sfe->cs.set_size(userquad.size(0), topo_dim);
    i = userquad.size(0);
    for (int32_T q{0}; q < i; q++) {
      b_sfe->ws[q] = userquad[userquad.size(1) * q];
      for (int32_T k{0}; k < topo_dim; k++) {
        b_sfe->cs[k + b_sfe->cs.size(1) * q] =
            userquad[(k + userquad.size(1) * q) + 1];
      }
    }
  }
  //  Solution space shape functions & derivs
  tabulate_shapefuncs(etypes, b_sfe->cs, b_sfe->shapes_sol, b_sfe->derivs_sol);
  //  Geometry space shape functions & derivs
  qd_or_natcoords_tmp = b_sfe->shapes_sol.size(1) * b_sfe->shapes_sol.size(0);
  b_sfe->shapes_geom.set_size(b_sfe->shapes_sol.size(0),
                              b_sfe->shapes_sol.size(1));
  for (i = 0; i < qd_or_natcoords_tmp; i++) {
    b_sfe->shapes_geom[i] = b_sfe->shapes_sol[i];
  }
  qd_or_natcoords_tmp = b_sfe->derivs_sol.size(2) * b_sfe->derivs_sol.size(1) *
                        b_sfe->derivs_sol.size(0);
  b_sfe->derivs_geom.set_size(b_sfe->derivs_sol.size(0),
                              b_sfe->derivs_sol.size(1),
                              b_sfe->derivs_sol.size(2));
  for (i = 0; i < qd_or_natcoords_tmp; i++) {
    b_sfe->derivs_geom[i] = b_sfe->derivs_sol[i];
  }
  //  potentially skip re-tabulating
  //  Compute phy. coordinates of qpoints
  b_sfe->cs_phy.set_size(b_sfe->nqp, xs.size(1));
  i = b_sfe->nqp;
  for (int32_T q{0}; q < i; q++) {
    //  NOTE The following can be optimized efficiently due to the the upper
    //  bound of dimension (i.e., size(xs,2)) is known.
    i1 = xs.size(1);
    for (int32_T k{0}; k < i1; k++) {
      int32_T m;
      // interpolate_shape - Interpolate f with q-th shape function in the table
      //
      //    v = interpolate_shape(shapes, q, f)
      //    v = interpolate_shape(shapes, q, f, k)
      m = b_sfe->shapes_sol.size(1);
      v = b_sfe->shapes_sol[b_sfe->shapes_sol.size(1) * q] * xs[k];
      for (int32_T b_i{2}; b_i <= m; b_i++) {
        v += b_sfe->shapes_sol[(b_i + b_sfe->shapes_sol.size(1) * q) - 1] *
             xs[k + xs.size(1) * (b_i - 1)];
      }
      b_sfe->cs_phy[k + b_sfe->cs_phy.size(1) * q] = v;
    }
  }
  //  Compute Jacobian
  b_sfe->wdetJ.set_size(b_sfe->nqp);
  if ((etypes == 68) || (etypes == 132) || (etypes == 36)) {
    real_T d;
    int32_T geom_dim;
    int32_T n;
    //  A single Jacobian matrix (transpose) is needed for simplex elements
    // compute_jact - Compute Jacobian^T and its determinant from q-th deriv in
    // table
    //
    //    [Jt, d] = compute_jactt(xs, derivs, q)
    //
    //  NOTES
    //  -----
    //  Jt is always shape of 3x3. But only topo_dim-by-geom_dim will be
    //  accessed for computing Jacobian matrix. Note that for 3D surfaces, the
    //  normal direction corresponding to q-th qpiont will be saved to the last
    //  row of J.
    //
    //  In particular, the orientation for the transpose of Jacobian matrix is
    //
    //             [dx/dxi    dy/dxi    dz/dxi  ]
    //        Jt = [dx/deta   dy/deta   dz/deta ]
    //             [dx/dzeta  dy/dzeta  dz/dzeta]
    //
    //  Hence, for surface and curve, Jt has shapes (d-1)xd and 1x3, resp
    //
    //  See also solve_sq
    geom_dim = xs.size(1);
    topo_dim = b_sfe->derivs_sol.size(2);
    std::memset(&dv[0], 0, 9U * sizeof(real_T));
    n = xs.size(0);
    for (int32_T k{0}; k < n; k++) {
      for (int32_T b_i{0}; b_i < topo_dim; b_i++) {
        for (int32_T j{0}; j < geom_dim; j++) {
          i = j + 3 * b_i;
          dv[i] += xs[j + xs.size(1) * k] *
                   b_sfe->derivs_sol[b_i + b_sfe->derivs_sol.size(2) * k];
        }
      }
    }
    if (xs.size(1) == b_sfe->derivs_sol.size(2)) {
      if (xs.size(1) == 1) {
        d = dv[0];
      } else if (xs.size(1) == 2) {
        // det2 - Compute determinant of 2x2 matrix.
        d = dv[0] * dv[4] - dv[1] * dv[3];
      } else {
        // det3 - Compute determinant of 3x3 matrix.
        d = (dv[2] * (dv[3] * dv[7] - dv[4] * dv[6]) +
             dv[5] * (dv[1] * dv[6] - dv[0] * dv[7])) +
            dv[8] * (dv[0] * dv[4] - dv[1] * dv[3]);
      }
    } else if (b_sfe->derivs_sol.size(2) == 1) {
      d = dv[0] * dv[0] + dv[1] * dv[1];
      if (xs.size(1) == 3) {
        d += dv[2] * dv[2];
      }
      d = std::sqrt(d);
    } else {
      //  must be 2x3
      // cross_lastcol - Compute cross(J(1,:),J(2,:)) and store to J(3,:)
      dv[6] = dv[1] * dv[5] - dv[2] * dv[4];
      dv[7] = dv[2] * dv[3] - dv[0] * dv[5];
      dv[8] = dv[0] * dv[4] - dv[1] * dv[3];
      d = std::sqrt((dv[6] * dv[6] + dv[7] * dv[7]) + dv[8] * dv[8]);
    }
    b_sfe->jacTs.set_size(3, 3);
    for (i = 0; i < 9; i++) {
      b_sfe->jacTs[i] = dv[i];
    }
    i = b_sfe->nqp;
    for (int32_T q{0}; q < i; q++) {
      b_sfe->wdetJ[q] = d * b_sfe->ws[q];
    }
  } else {
    //  Super-parametric
    qd_or_natcoords_tmp = b_sfe->nqp * 3;
    b_sfe->jacTs.set_size(qd_or_natcoords_tmp, 3);
    i = b_sfe->nqp;
    for (int32_T q{0}; q < i; q++) {
      int32_T geom_dim;
      int32_T n;
      int32_T y;
      y = q * 3;
      // compute_jact - Compute Jacobian^T and its determinant from q-th deriv
      // in table
      //
      //    [Jt, d] = compute_jactt(xs, derivs, q)
      //
      //  NOTES
      //  -----
      //  Jt is always shape of 3x3. But only topo_dim-by-geom_dim will be
      //  accessed for computing Jacobian matrix. Note that for 3D surfaces, the
      //  normal direction corresponding to q-th qpiont will be saved to the
      //  last row of J.
      //
      //  In particular, the orientation for the transpose of Jacobian matrix is
      //
      //             [dx/dxi    dy/dxi    dz/dxi  ]
      //        Jt = [dx/deta   dy/deta   dz/deta ]
      //             [dx/dzeta  dy/dzeta  dz/dzeta]
      //
      //  Hence, for surface and curve, Jt has shapes (d-1)xd and 1x3, resp
      //
      //  See also solve_sq
      geom_dim = xs.size(1);
      topo_dim = b_sfe->derivs_sol.size(2);
      std::memset(&dv[0], 0, 9U * sizeof(real_T));
      n = xs.size(0);
      for (int32_T k{0}; k < n; k++) {
        for (int32_T b_i{0}; b_i < topo_dim; b_i++) {
          for (int32_T j{0}; j < geom_dim; j++) {
            i1 = j + 3 * b_i;
            dv[i1] += xs[j + xs.size(1) * k] *
                      b_sfe->derivs_sol[(b_i + b_sfe->derivs_sol.size(2) * k) +
                                        b_sfe->derivs_sol.size(2) *
                                            b_sfe->derivs_sol.size(1) * q];
          }
        }
      }
      if (xs.size(1) == b_sfe->derivs_sol.size(2)) {
        if (xs.size(1) == 1) {
          v = dv[0];
        } else if (xs.size(1) == 2) {
          // det2 - Compute determinant of 2x2 matrix.
          v = dv[0] * dv[4] - dv[1] * dv[3];
        } else {
          // det3 - Compute determinant of 3x3 matrix.
          v = (dv[2] * (dv[3] * dv[7] - dv[4] * dv[6]) +
               dv[5] * (dv[1] * dv[6] - dv[0] * dv[7])) +
              dv[8] * (dv[0] * dv[4] - dv[1] * dv[3]);
        }
      } else if (b_sfe->derivs_sol.size(2) == 1) {
        v = dv[0] * dv[0] + dv[1] * dv[1];
        if (xs.size(1) == 3) {
          v += dv[2] * dv[2];
        }
        v = std::sqrt(v);
      } else {
        //  must be 2x3
        // cross_lastcol - Compute cross(J(1,:),J(2,:)) and store to J(3,:)
        dv[6] = dv[1] * dv[5] - dv[2] * dv[4];
        dv[7] = dv[2] * dv[3] - dv[0] * dv[5];
        dv[8] = dv[0] * dv[4] - dv[1] * dv[3];
        v = std::sqrt((dv[6] * dv[6] + dv[7] * dv[7]) + dv[8] * dv[8]);
      }
      for (i1 = 0; i1 < 3; i1++) {
        qd_or_natcoords_tmp = i1 + y;
        b_sfe->jacTs[3 * qd_or_natcoords_tmp] = dv[3 * i1];
        b_sfe->jacTs[3 * qd_or_natcoords_tmp + 1] = dv[3 * i1 + 1];
        b_sfe->jacTs[3 * qd_or_natcoords_tmp + 2] = dv[3 * i1 + 2];
      }
      b_sfe->wdetJ[q] = v;
      b_sfe->wdetJ[q] = b_sfe->wdetJ[q] * b_sfe->ws[q];
    }
  }
}

void sfe_init10(SfeObject *b_sfe, const ::coder::array<real_T, 2U> &xs, int32_T)
{
  real_T dv[9];
  real_T v;
  int32_T i;
  int32_T i1;
  boolean_T cond;
  // sfe_init - Initialize/reinitialize an sfe object for non-boundary element
  //
  //    sfe = sfe_init(sfe, etypes, xs)
  //    sfe = sfe_init(sfe, etypes, xs, natcoords)
  //    sfe = sfe_init(sfe, etypes, xs, qd)
  //    sfe = sfe_init(sfe, etypes, xs, qd, userquad)
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An SfeObject instance
  //    etypes:     Element type(s), which can be a 2-vector, scalar, or [].
  //                A 2-vector specifies the solution and geometric element
  //                types, and it supports iso-, sub- and super-parametric
  //                elements. If two element types are equal, then one can use a
  //                scalar. An empty array ([]) instructs the function to reuse
  //                the element type and the tabulation stored in the `sfe`
  //                object (typically from a previous call).
  //    xs:         Physical coordinates of the element, which is defined in
  //                the geometric space
  //    qd:         Quadrature degree, a zero value indicate the use of default
  //                quadrature rules based on the element types. If `-1` is
  //                passed in, then the code will assume user-provided
  //                quadrature rule information
  //    userquad:   This field is only accessed if qd=-1. If provided, then
  //    userquad
  //                must be a nqp-by-(1+dim) array, where the first column
  //                vector is is the quadrature weights while the rest are their
  //                corresponding quadrature points, defined in the reference
  //                element.
  //
  //  In particular, the user can pass in specific natural coordinates on which
  //  we will compute shape functions and derivatives. In this situation, we
  //  will skip the computation of Jacobian.
  //
  //    natcoords:  List of natural coordinates defined by the user
  //
  //  EXAMPLES
  //  --------
  //  The following initializes a linear triangular element
  //
  //    >> sfe = sfe_init(SfeObject(0), SFE_TRI_3, xs);
  //
  //  The following initializes a quadratic tetrahedral element but with linear
  //  geometry
  //
  //    >> etypes = [SFE_TET_10; SFE_TET_4];
  //    >> sfe = sfe_init(SfeObject(0), etypes, xs);
  //
  //  The following initializes a bi-linear quadrilateral element with
  //  user-provided gravity quadrature rule
  //
  //    >> gravrule = [1, 0.5, 0.5];
  //    >> sfe = sfe_init(SfeObject(0), SFE_QUAD_4, xs, int32(-1), gravrule);
  //
  //  See also SfeObject, ElementTypes, sfe_init_grad
  //  For clarity
  if ((b_sfe->etypes[0] > 0) && (iv[b_sfe->etypes[0] - 1] != 0)) {
    // obtain_elemnnodes - Obtain number of nodes per element given etype
    //
    //     nnodes = obtain_elemnnodes(etype)
    //
    //  This file was generated from update_nnodes_table
    //         % SFE_NODE_1
    //         % SFE_BAR_GL_2
    //         % SFE_BAR_GL_3
    //         % SFE_BAR_4
    //         % SFE_BAR_GL_4
    //         % SFE_BAR_5
    //         % SFE_BAR_GL_5
    //         % SFE_BAR_6
    //         % SFE_BAR_GL_6
    //         % SFE_BAR_7
    //         % SFE_BAR_GL_7
    //         % SFE_TRI_GL_3
    //         % SFE_TRI_GL_6
    //         % SFE_TRI_10
    //         % SFE_TRI_GL_10
    //         % SFE_TRI_15
    //         % SFE_TRI_GL_15
    //         % SFE_TRI_FEK_15
    //         % SFE_TRI_21
    //         % SFE_TRI_GL_21
    //         % SFE_TRI_FEK_21
    //         % SFE_TRI_28
    //         % SFE_TRI_GL_28
    //         % SFE_TRI_FEK_28
    //         % SFE_QUAD_GL_4
    //         % SFE_QUAD_GL_9
    //         % SFE_QUAD_16
    //         % SFE_QUAD_GL_16
    //         % SFE_QUAD_25
    //         % SFE_QUAD_GL_25
    //         % SFE_QUAD_36
    //         % SFE_QUAD_GL_36
    //         % SFE_QUAD_49
    //         % SFE_QUAD_GL_49
    //         % SFE_TET_GL_4
    //         % SFE_TET_GL_10
    //         % SFE_TET_20
    //         % SFE_TET_GL_20
    //         % SFE_TET_35
    //         % SFE_TET_GL_35
    //         % SFE_TET_FEK_35
    //         % SFE_TET_56
    //         % SFE_TET_GL_56
    //         % SFE_TET_FEK_56
    //         % SFE_TET_84
    //         % SFE_TET_GL_84
    //         % SFE_TET_FEK_84
    //         % SFE_PYRA_GL_5
    //         % SFE_PYRA_GL_14
    //         % SFE_PYRA_30
    //         % SFE_PYRA_GL_30
    //         % SFE_PYRA_55
    //         % SFE_PYRA_GL_55
    //         % SFE_PYRA_FEK_55
    //         % SFE_PYRA_91
    //         % SFE_PRISM_GL_6
    //         % SFE_PRISM_GL_18
    //         % SFE_PRISM_40
    //         % SFE_PRISM_GL_40
    //         % SFE_PRISM_75
    //         % SFE_PRISM_GL_75
    //         % SFE_PRISM_FEK_75
    //         % SFE_PRISM_126
    //         % SFE_PRISM_GL_126
    //         % SFE_PRISM_196
    //         % SFE_HEXA_GL_8
    //         % SFE_HEXA_GL_27
    //         % SFE_HEXA_64
    //         % SFE_HEXA_GL_64
    //         % SFE_HEXA_125
    //         % SFE_HEXA_GL_125
    //         % SFE_HEXA_216
    //         % SFE_HEXA_GL_216
    //         % SFE_HEXA_343
    //         % SFE_HEXA_GL_343
    cond = true;
  } else {
    cond = false;
  }
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(cond, "");
  //  potentially skip re-tabulating
  //  Compute phy. coordinates of qpoints
  b_sfe->cs_phy.set_size(b_sfe->nqp, xs.size(1));
  i = b_sfe->nqp;
  for (int32_T q{0}; q < i; q++) {
    //  NOTE The following can be optimized efficiently due to the the upper
    //  bound of dimension (i.e., size(xs,2)) is known.
    i1 = xs.size(1);
    for (int32_T k{0}; k < i1; k++) {
      int32_T m;
      // interpolate_shape - Interpolate f with q-th shape function in the table
      //
      //    v = interpolate_shape(shapes, q, f)
      //    v = interpolate_shape(shapes, q, f, k)
      m = b_sfe->shapes_geom.size(1);
      v = b_sfe->shapes_geom[b_sfe->shapes_geom.size(1) * q] * xs[k];
      for (int32_T b_i{2}; b_i <= m; b_i++) {
        v += b_sfe->shapes_geom[(b_i + b_sfe->shapes_geom.size(1) * q) - 1] *
             xs[k + xs.size(1) * (b_i - 1)];
      }
      b_sfe->cs_phy[k + b_sfe->cs_phy.size(1) * q] = v;
    }
  }
  //  Compute Jacobian
  b_sfe->wdetJ.set_size(b_sfe->nqp);
  if ((b_sfe->etypes[1] == 68) || (b_sfe->etypes[1] == 132) ||
      (b_sfe->etypes[1] == 36)) {
    real_T d;
    int32_T geom_dim;
    int32_T n;
    int32_T topo_dim;
    //  A single Jacobian matrix (transpose) is needed for simplex elements
    // compute_jact - Compute Jacobian^T and its determinant from q-th deriv in
    // table
    //
    //    [Jt, d] = compute_jactt(xs, derivs, q)
    //
    //  NOTES
    //  -----
    //  Jt is always shape of 3x3. But only topo_dim-by-geom_dim will be
    //  accessed for computing Jacobian matrix. Note that for 3D surfaces, the
    //  normal direction corresponding to q-th qpiont will be saved to the last
    //  row of J.
    //
    //  In particular, the orientation for the transpose of Jacobian matrix is
    //
    //             [dx/dxi    dy/dxi    dz/dxi  ]
    //        Jt = [dx/deta   dy/deta   dz/deta ]
    //             [dx/dzeta  dy/dzeta  dz/dzeta]
    //
    //  Hence, for surface and curve, Jt has shapes (d-1)xd and 1x3, resp
    //
    //  See also solve_sq
    geom_dim = xs.size(1);
    topo_dim = b_sfe->derivs_geom.size(2);
    std::memset(&dv[0], 0, 9U * sizeof(real_T));
    n = xs.size(0);
    for (int32_T k{0}; k < n; k++) {
      for (int32_T b_i{0}; b_i < topo_dim; b_i++) {
        for (int32_T j{0}; j < geom_dim; j++) {
          i = j + 3 * b_i;
          dv[i] += xs[j + xs.size(1) * k] *
                   b_sfe->derivs_geom[b_i + b_sfe->derivs_geom.size(2) * k];
        }
      }
    }
    if (xs.size(1) == b_sfe->derivs_geom.size(2)) {
      if (xs.size(1) == 1) {
        d = dv[0];
      } else if (xs.size(1) == 2) {
        // det2 - Compute determinant of 2x2 matrix.
        d = dv[0] * dv[4] - dv[1] * dv[3];
      } else {
        // det3 - Compute determinant of 3x3 matrix.
        d = (dv[2] * (dv[3] * dv[7] - dv[4] * dv[6]) +
             dv[5] * (dv[1] * dv[6] - dv[0] * dv[7])) +
            dv[8] * (dv[0] * dv[4] - dv[1] * dv[3]);
      }
    } else if (b_sfe->derivs_geom.size(2) == 1) {
      d = dv[0] * dv[0] + dv[1] * dv[1];
      if (xs.size(1) == 3) {
        d += dv[2] * dv[2];
      }
      d = std::sqrt(d);
    } else {
      //  must be 2x3
      // cross_lastcol - Compute cross(J(1,:),J(2,:)) and store to J(3,:)
      dv[6] = dv[1] * dv[5] - dv[2] * dv[4];
      dv[7] = dv[2] * dv[3] - dv[0] * dv[5];
      dv[8] = dv[0] * dv[4] - dv[1] * dv[3];
      d = std::sqrt((dv[6] * dv[6] + dv[7] * dv[7]) + dv[8] * dv[8]);
    }
    b_sfe->jacTs.set_size(3, 3);
    for (i = 0; i < 9; i++) {
      b_sfe->jacTs[i] = dv[i];
    }
    i = b_sfe->nqp;
    for (int32_T q{0}; q < i; q++) {
      b_sfe->wdetJ[q] = d * b_sfe->ws[q];
    }
  } else {
    int32_T sfe_idx_0;
    //  Super-parametric
    sfe_idx_0 = b_sfe->nqp * 3;
    b_sfe->jacTs.set_size(sfe_idx_0, 3);
    i = b_sfe->nqp;
    for (int32_T q{0}; q < i; q++) {
      int32_T geom_dim;
      int32_T n;
      int32_T topo_dim;
      int32_T y;
      y = q * 3;
      // compute_jact - Compute Jacobian^T and its determinant from q-th deriv
      // in table
      //
      //    [Jt, d] = compute_jactt(xs, derivs, q)
      //
      //  NOTES
      //  -----
      //  Jt is always shape of 3x3. But only topo_dim-by-geom_dim will be
      //  accessed for computing Jacobian matrix. Note that for 3D surfaces, the
      //  normal direction corresponding to q-th qpiont will be saved to the
      //  last row of J.
      //
      //  In particular, the orientation for the transpose of Jacobian matrix is
      //
      //             [dx/dxi    dy/dxi    dz/dxi  ]
      //        Jt = [dx/deta   dy/deta   dz/deta ]
      //             [dx/dzeta  dy/dzeta  dz/dzeta]
      //
      //  Hence, for surface and curve, Jt has shapes (d-1)xd and 1x3, resp
      //
      //  See also solve_sq
      geom_dim = xs.size(1);
      topo_dim = b_sfe->derivs_geom.size(2);
      std::memset(&dv[0], 0, 9U * sizeof(real_T));
      n = xs.size(0);
      for (int32_T k{0}; k < n; k++) {
        for (int32_T b_i{0}; b_i < topo_dim; b_i++) {
          for (int32_T j{0}; j < geom_dim; j++) {
            i1 = j + 3 * b_i;
            dv[i1] +=
                xs[j + xs.size(1) * k] *
                b_sfe->derivs_geom[(b_i + b_sfe->derivs_geom.size(2) * k) +
                                   b_sfe->derivs_geom.size(2) *
                                       b_sfe->derivs_geom.size(1) * q];
          }
        }
      }
      if (xs.size(1) == b_sfe->derivs_geom.size(2)) {
        if (xs.size(1) == 1) {
          v = dv[0];
        } else if (xs.size(1) == 2) {
          // det2 - Compute determinant of 2x2 matrix.
          v = dv[0] * dv[4] - dv[1] * dv[3];
        } else {
          // det3 - Compute determinant of 3x3 matrix.
          v = (dv[2] * (dv[3] * dv[7] - dv[4] * dv[6]) +
               dv[5] * (dv[1] * dv[6] - dv[0] * dv[7])) +
              dv[8] * (dv[0] * dv[4] - dv[1] * dv[3]);
        }
      } else if (b_sfe->derivs_geom.size(2) == 1) {
        v = dv[0] * dv[0] + dv[1] * dv[1];
        if (xs.size(1) == 3) {
          v += dv[2] * dv[2];
        }
        v = std::sqrt(v);
      } else {
        //  must be 2x3
        // cross_lastcol - Compute cross(J(1,:),J(2,:)) and store to J(3,:)
        dv[6] = dv[1] * dv[5] - dv[2] * dv[4];
        dv[7] = dv[2] * dv[3] - dv[0] * dv[5];
        dv[8] = dv[0] * dv[4] - dv[1] * dv[3];
        v = std::sqrt((dv[6] * dv[6] + dv[7] * dv[7]) + dv[8] * dv[8]);
      }
      for (i1 = 0; i1 < 3; i1++) {
        sfe_idx_0 = i1 + y;
        b_sfe->jacTs[3 * sfe_idx_0] = dv[3 * i1];
        b_sfe->jacTs[3 * sfe_idx_0 + 1] = dv[3 * i1 + 1];
        b_sfe->jacTs[3 * sfe_idx_0 + 2] = dv[3 * i1 + 2];
      }
      b_sfe->wdetJ[q] = v;
      b_sfe->wdetJ[q] = b_sfe->wdetJ[q] * b_sfe->ws[q];
    }
  }
}

void sfe_init11(SfeObject *b_sfe, const ::coder::array<real_T, 2U> &xs)
{
  real_T dv[9];
  real_T v;
  int32_T i;
  int32_T i1;
  boolean_T cond;
  // sfe_init - Initialize/reinitialize an sfe object for non-boundary element
  //
  //    sfe = sfe_init(sfe, etypes, xs)
  //    sfe = sfe_init(sfe, etypes, xs, natcoords)
  //    sfe = sfe_init(sfe, etypes, xs, qd)
  //    sfe = sfe_init(sfe, etypes, xs, qd, userquad)
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An SfeObject instance
  //    etypes:     Element type(s), which can be a 2-vector, scalar, or [].
  //                A 2-vector specifies the solution and geometric element
  //                types, and it supports iso-, sub- and super-parametric
  //                elements. If two element types are equal, then one can use a
  //                scalar. An empty array ([]) instructs the function to reuse
  //                the element type and the tabulation stored in the `sfe`
  //                object (typically from a previous call).
  //    xs:         Physical coordinates of the element, which is defined in
  //                the geometric space
  //    qd:         Quadrature degree, a zero value indicate the use of default
  //                quadrature rules based on the element types. If `-1` is
  //                passed in, then the code will assume user-provided
  //                quadrature rule information
  //    userquad:   This field is only accessed if qd=-1. If provided, then
  //    userquad
  //                must be a nqp-by-(1+dim) array, where the first column
  //                vector is is the quadrature weights while the rest are their
  //                corresponding quadrature points, defined in the reference
  //                element.
  //
  //  In particular, the user can pass in specific natural coordinates on which
  //  we will compute shape functions and derivatives. In this situation, we
  //  will skip the computation of Jacobian.
  //
  //    natcoords:  List of natural coordinates defined by the user
  //
  //  EXAMPLES
  //  --------
  //  The following initializes a linear triangular element
  //
  //    >> sfe = sfe_init(SfeObject(0), SFE_TRI_3, xs);
  //
  //  The following initializes a quadratic tetrahedral element but with linear
  //  geometry
  //
  //    >> etypes = [SFE_TET_10; SFE_TET_4];
  //    >> sfe = sfe_init(SfeObject(0), etypes, xs);
  //
  //  The following initializes a bi-linear quadrilateral element with
  //  user-provided gravity quadrature rule
  //
  //    >> gravrule = [1, 0.5, 0.5];
  //    >> sfe = sfe_init(SfeObject(0), SFE_QUAD_4, xs, int32(-1), gravrule);
  //
  //  See also SfeObject, ElementTypes, sfe_init_grad
  //  For clarity
  if ((b_sfe->etypes[0] > 0) && (iv[b_sfe->etypes[0] - 1] != 0)) {
    // obtain_elemnnodes - Obtain number of nodes per element given etype
    //
    //     nnodes = obtain_elemnnodes(etype)
    //
    //  This file was generated from update_nnodes_table
    //         % SFE_NODE_1
    //         % SFE_BAR_GL_2
    //         % SFE_BAR_GL_3
    //         % SFE_BAR_4
    //         % SFE_BAR_GL_4
    //         % SFE_BAR_5
    //         % SFE_BAR_GL_5
    //         % SFE_BAR_6
    //         % SFE_BAR_GL_6
    //         % SFE_BAR_7
    //         % SFE_BAR_GL_7
    //         % SFE_TRI_GL_3
    //         % SFE_TRI_GL_6
    //         % SFE_TRI_10
    //         % SFE_TRI_GL_10
    //         % SFE_TRI_15
    //         % SFE_TRI_GL_15
    //         % SFE_TRI_FEK_15
    //         % SFE_TRI_21
    //         % SFE_TRI_GL_21
    //         % SFE_TRI_FEK_21
    //         % SFE_TRI_28
    //         % SFE_TRI_GL_28
    //         % SFE_TRI_FEK_28
    //         % SFE_QUAD_GL_4
    //         % SFE_QUAD_GL_9
    //         % SFE_QUAD_16
    //         % SFE_QUAD_GL_16
    //         % SFE_QUAD_25
    //         % SFE_QUAD_GL_25
    //         % SFE_QUAD_36
    //         % SFE_QUAD_GL_36
    //         % SFE_QUAD_49
    //         % SFE_QUAD_GL_49
    //         % SFE_TET_GL_4
    //         % SFE_TET_GL_10
    //         % SFE_TET_20
    //         % SFE_TET_GL_20
    //         % SFE_TET_35
    //         % SFE_TET_GL_35
    //         % SFE_TET_FEK_35
    //         % SFE_TET_56
    //         % SFE_TET_GL_56
    //         % SFE_TET_FEK_56
    //         % SFE_TET_84
    //         % SFE_TET_GL_84
    //         % SFE_TET_FEK_84
    //         % SFE_PYRA_GL_5
    //         % SFE_PYRA_GL_14
    //         % SFE_PYRA_30
    //         % SFE_PYRA_GL_30
    //         % SFE_PYRA_55
    //         % SFE_PYRA_GL_55
    //         % SFE_PYRA_FEK_55
    //         % SFE_PYRA_91
    //         % SFE_PRISM_GL_6
    //         % SFE_PRISM_GL_18
    //         % SFE_PRISM_40
    //         % SFE_PRISM_GL_40
    //         % SFE_PRISM_75
    //         % SFE_PRISM_GL_75
    //         % SFE_PRISM_FEK_75
    //         % SFE_PRISM_126
    //         % SFE_PRISM_GL_126
    //         % SFE_PRISM_196
    //         % SFE_HEXA_GL_8
    //         % SFE_HEXA_GL_27
    //         % SFE_HEXA_64
    //         % SFE_HEXA_GL_64
    //         % SFE_HEXA_125
    //         % SFE_HEXA_GL_125
    //         % SFE_HEXA_216
    //         % SFE_HEXA_GL_216
    //         % SFE_HEXA_343
    //         % SFE_HEXA_GL_343
    cond = true;
  } else {
    cond = false;
  }
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(cond, "");
  //  potentially skip re-tabulating
  //  Compute phy. coordinates of qpoints
  b_sfe->cs_phy.set_size(b_sfe->nqp, xs.size(1));
  i = b_sfe->nqp;
  for (int32_T q{0}; q < i; q++) {
    //  NOTE The following can be optimized efficiently due to the the upper
    //  bound of dimension (i.e., size(xs,2)) is known.
    i1 = xs.size(1);
    for (int32_T k{0}; k < i1; k++) {
      int32_T m;
      // interpolate_shape - Interpolate f with q-th shape function in the table
      //
      //    v = interpolate_shape(shapes, q, f)
      //    v = interpolate_shape(shapes, q, f, k)
      m = b_sfe->shapes_geom.size(1);
      v = b_sfe->shapes_geom[b_sfe->shapes_geom.size(1) * q] * xs[k];
      for (int32_T b_i{2}; b_i <= m; b_i++) {
        v += b_sfe->shapes_geom[(b_i + b_sfe->shapes_geom.size(1) * q) - 1] *
             xs[k + xs.size(1) * (b_i - 1)];
      }
      b_sfe->cs_phy[k + b_sfe->cs_phy.size(1) * q] = v;
    }
  }
  //  Compute Jacobian
  b_sfe->wdetJ.set_size(b_sfe->nqp);
  if ((b_sfe->etypes[1] == 68) || (b_sfe->etypes[1] == 132) ||
      (b_sfe->etypes[1] == 36)) {
    real_T d;
    int32_T geom_dim;
    int32_T n;
    int32_T topo_dim;
    //  A single Jacobian matrix (transpose) is needed for simplex elements
    // compute_jact - Compute Jacobian^T and its determinant from q-th deriv in
    // table
    //
    //    [Jt, d] = compute_jactt(xs, derivs, q)
    //
    //  NOTES
    //  -----
    //  Jt is always shape of 3x3. But only topo_dim-by-geom_dim will be
    //  accessed for computing Jacobian matrix. Note that for 3D surfaces, the
    //  normal direction corresponding to q-th qpiont will be saved to the last
    //  row of J.
    //
    //  In particular, the orientation for the transpose of Jacobian matrix is
    //
    //             [dx/dxi    dy/dxi    dz/dxi  ]
    //        Jt = [dx/deta   dy/deta   dz/deta ]
    //             [dx/dzeta  dy/dzeta  dz/dzeta]
    //
    //  Hence, for surface and curve, Jt has shapes (d-1)xd and 1x3, resp
    //
    //  See also solve_sq
    geom_dim = xs.size(1);
    topo_dim = b_sfe->derivs_geom.size(2);
    std::memset(&dv[0], 0, 9U * sizeof(real_T));
    n = xs.size(0);
    for (int32_T k{0}; k < n; k++) {
      for (int32_T b_i{0}; b_i < topo_dim; b_i++) {
        for (int32_T j{0}; j < geom_dim; j++) {
          i = j + 3 * b_i;
          dv[i] += xs[j + xs.size(1) * k] *
                   b_sfe->derivs_geom[b_i + b_sfe->derivs_geom.size(2) * k];
        }
      }
    }
    if (xs.size(1) == b_sfe->derivs_geom.size(2)) {
      if (xs.size(1) == 1) {
        d = dv[0];
      } else if (xs.size(1) == 2) {
        // det2 - Compute determinant of 2x2 matrix.
        d = dv[0] * dv[4] - dv[1] * dv[3];
      } else {
        // det3 - Compute determinant of 3x3 matrix.
        d = (dv[2] * (dv[3] * dv[7] - dv[4] * dv[6]) +
             dv[5] * (dv[1] * dv[6] - dv[0] * dv[7])) +
            dv[8] * (dv[0] * dv[4] - dv[1] * dv[3]);
      }
    } else if (b_sfe->derivs_geom.size(2) == 1) {
      d = dv[0] * dv[0] + dv[1] * dv[1];
      if (xs.size(1) == 3) {
        d += dv[2] * dv[2];
      }
      d = std::sqrt(d);
    } else {
      //  must be 2x3
      // cross_lastcol - Compute cross(J(1,:),J(2,:)) and store to J(3,:)
      dv[6] = dv[1] * dv[5] - dv[2] * dv[4];
      dv[7] = dv[2] * dv[3] - dv[0] * dv[5];
      dv[8] = dv[0] * dv[4] - dv[1] * dv[3];
      d = std::sqrt((dv[6] * dv[6] + dv[7] * dv[7]) + dv[8] * dv[8]);
    }
    b_sfe->jacTs.set_size(3, 3);
    for (i = 0; i < 9; i++) {
      b_sfe->jacTs[i] = dv[i];
    }
    i = b_sfe->nqp;
    for (int32_T q{0}; q < i; q++) {
      b_sfe->wdetJ[q] = d * b_sfe->ws[q];
    }
  } else {
    int32_T sfe_idx_0;
    //  Super-parametric
    sfe_idx_0 = b_sfe->nqp * 3;
    b_sfe->jacTs.set_size(sfe_idx_0, 3);
    i = b_sfe->nqp;
    for (int32_T q{0}; q < i; q++) {
      int32_T geom_dim;
      int32_T n;
      int32_T topo_dim;
      int32_T y;
      y = q * 3;
      // compute_jact - Compute Jacobian^T and its determinant from q-th deriv
      // in table
      //
      //    [Jt, d] = compute_jactt(xs, derivs, q)
      //
      //  NOTES
      //  -----
      //  Jt is always shape of 3x3. But only topo_dim-by-geom_dim will be
      //  accessed for computing Jacobian matrix. Note that for 3D surfaces, the
      //  normal direction corresponding to q-th qpiont will be saved to the
      //  last row of J.
      //
      //  In particular, the orientation for the transpose of Jacobian matrix is
      //
      //             [dx/dxi    dy/dxi    dz/dxi  ]
      //        Jt = [dx/deta   dy/deta   dz/deta ]
      //             [dx/dzeta  dy/dzeta  dz/dzeta]
      //
      //  Hence, for surface and curve, Jt has shapes (d-1)xd and 1x3, resp
      //
      //  See also solve_sq
      geom_dim = xs.size(1);
      topo_dim = b_sfe->derivs_geom.size(2);
      std::memset(&dv[0], 0, 9U * sizeof(real_T));
      n = xs.size(0);
      for (int32_T k{0}; k < n; k++) {
        for (int32_T b_i{0}; b_i < topo_dim; b_i++) {
          for (int32_T j{0}; j < geom_dim; j++) {
            i1 = j + 3 * b_i;
            dv[i1] +=
                xs[j + xs.size(1) * k] *
                b_sfe->derivs_geom[(b_i + b_sfe->derivs_geom.size(2) * k) +
                                   b_sfe->derivs_geom.size(2) *
                                       b_sfe->derivs_geom.size(1) * q];
          }
        }
      }
      if (xs.size(1) == b_sfe->derivs_geom.size(2)) {
        if (xs.size(1) == 1) {
          v = dv[0];
        } else if (xs.size(1) == 2) {
          // det2 - Compute determinant of 2x2 matrix.
          v = dv[0] * dv[4] - dv[1] * dv[3];
        } else {
          // det3 - Compute determinant of 3x3 matrix.
          v = (dv[2] * (dv[3] * dv[7] - dv[4] * dv[6]) +
               dv[5] * (dv[1] * dv[6] - dv[0] * dv[7])) +
              dv[8] * (dv[0] * dv[4] - dv[1] * dv[3]);
        }
      } else if (b_sfe->derivs_geom.size(2) == 1) {
        v = dv[0] * dv[0] + dv[1] * dv[1];
        if (xs.size(1) == 3) {
          v += dv[2] * dv[2];
        }
        v = std::sqrt(v);
      } else {
        //  must be 2x3
        // cross_lastcol - Compute cross(J(1,:),J(2,:)) and store to J(3,:)
        dv[6] = dv[1] * dv[5] - dv[2] * dv[4];
        dv[7] = dv[2] * dv[3] - dv[0] * dv[5];
        dv[8] = dv[0] * dv[4] - dv[1] * dv[3];
        v = std::sqrt((dv[6] * dv[6] + dv[7] * dv[7]) + dv[8] * dv[8]);
      }
      for (i1 = 0; i1 < 3; i1++) {
        sfe_idx_0 = i1 + y;
        b_sfe->jacTs[3 * sfe_idx_0] = dv[3 * i1];
        b_sfe->jacTs[3 * sfe_idx_0 + 1] = dv[3 * i1 + 1];
        b_sfe->jacTs[3 * sfe_idx_0 + 2] = dv[3 * i1 + 2];
      }
      b_sfe->wdetJ[q] = v;
      b_sfe->wdetJ[q] = b_sfe->wdetJ[q] * b_sfe->ws[q];
    }
  }
}

void sfe_init12(SfeObject *b_sfe, const ::coder::array<real_T, 2U> &xs,
                const ::coder::array<real_T, 2U> &)
{
  int32_T i;
  boolean_T cond;
  // sfe_init - Initialize/reinitialize an sfe object for non-boundary element
  //
  //    sfe = sfe_init(sfe, etypes, xs)
  //    sfe = sfe_init(sfe, etypes, xs, natcoords)
  //    sfe = sfe_init(sfe, etypes, xs, qd)
  //    sfe = sfe_init(sfe, etypes, xs, qd, userquad)
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An SfeObject instance
  //    etypes:     Element type(s), which can be a 2-vector, scalar, or [].
  //                A 2-vector specifies the solution and geometric element
  //                types, and it supports iso-, sub- and super-parametric
  //                elements. If two element types are equal, then one can use a
  //                scalar. An empty array ([]) instructs the function to reuse
  //                the element type and the tabulation stored in the `sfe`
  //                object (typically from a previous call).
  //    xs:         Physical coordinates of the element, which is defined in
  //                the geometric space
  //    qd:         Quadrature degree, a zero value indicate the use of default
  //                quadrature rules based on the element types. If `-1` is
  //                passed in, then the code will assume user-provided
  //                quadrature rule information
  //    userquad:   This field is only accessed if qd=-1. If provided, then
  //    userquad
  //                must be a nqp-by-(1+dim) array, where the first column
  //                vector is is the quadrature weights while the rest are their
  //                corresponding quadrature points, defined in the reference
  //                element.
  //
  //  In particular, the user can pass in specific natural coordinates on which
  //  we will compute shape functions and derivatives. In this situation, we
  //  will skip the computation of Jacobian.
  //
  //    natcoords:  List of natural coordinates defined by the user
  //
  //  EXAMPLES
  //  --------
  //  The following initializes a linear triangular element
  //
  //    >> sfe = sfe_init(SfeObject(0), SFE_TRI_3, xs);
  //
  //  The following initializes a quadratic tetrahedral element but with linear
  //  geometry
  //
  //    >> etypes = [SFE_TET_10; SFE_TET_4];
  //    >> sfe = sfe_init(SfeObject(0), etypes, xs);
  //
  //  The following initializes a bi-linear quadrilateral element with
  //  user-provided gravity quadrature rule
  //
  //    >> gravrule = [1, 0.5, 0.5];
  //    >> sfe = sfe_init(SfeObject(0), SFE_QUAD_4, xs, int32(-1), gravrule);
  //
  //  See also SfeObject, ElementTypes, sfe_init_grad
  //  For clarity
  if ((b_sfe->etypes[0] > 0) && (iv[b_sfe->etypes[0] - 1] != 0)) {
    // obtain_elemnnodes - Obtain number of nodes per element given etype
    //
    //     nnodes = obtain_elemnnodes(etype)
    //
    //  This file was generated from update_nnodes_table
    //         % SFE_NODE_1
    //         % SFE_BAR_GL_2
    //         % SFE_BAR_GL_3
    //         % SFE_BAR_4
    //         % SFE_BAR_GL_4
    //         % SFE_BAR_5
    //         % SFE_BAR_GL_5
    //         % SFE_BAR_6
    //         % SFE_BAR_GL_6
    //         % SFE_BAR_7
    //         % SFE_BAR_GL_7
    //         % SFE_TRI_GL_3
    //         % SFE_TRI_GL_6
    //         % SFE_TRI_10
    //         % SFE_TRI_GL_10
    //         % SFE_TRI_15
    //         % SFE_TRI_GL_15
    //         % SFE_TRI_FEK_15
    //         % SFE_TRI_21
    //         % SFE_TRI_GL_21
    //         % SFE_TRI_FEK_21
    //         % SFE_TRI_28
    //         % SFE_TRI_GL_28
    //         % SFE_TRI_FEK_28
    //         % SFE_QUAD_GL_4
    //         % SFE_QUAD_GL_9
    //         % SFE_QUAD_16
    //         % SFE_QUAD_GL_16
    //         % SFE_QUAD_25
    //         % SFE_QUAD_GL_25
    //         % SFE_QUAD_36
    //         % SFE_QUAD_GL_36
    //         % SFE_QUAD_49
    //         % SFE_QUAD_GL_49
    //         % SFE_TET_GL_4
    //         % SFE_TET_GL_10
    //         % SFE_TET_20
    //         % SFE_TET_GL_20
    //         % SFE_TET_35
    //         % SFE_TET_GL_35
    //         % SFE_TET_FEK_35
    //         % SFE_TET_56
    //         % SFE_TET_GL_56
    //         % SFE_TET_FEK_56
    //         % SFE_TET_84
    //         % SFE_TET_GL_84
    //         % SFE_TET_FEK_84
    //         % SFE_PYRA_GL_5
    //         % SFE_PYRA_GL_14
    //         % SFE_PYRA_30
    //         % SFE_PYRA_GL_30
    //         % SFE_PYRA_55
    //         % SFE_PYRA_GL_55
    //         % SFE_PYRA_FEK_55
    //         % SFE_PYRA_91
    //         % SFE_PRISM_GL_6
    //         % SFE_PRISM_GL_18
    //         % SFE_PRISM_40
    //         % SFE_PRISM_GL_40
    //         % SFE_PRISM_75
    //         % SFE_PRISM_GL_75
    //         % SFE_PRISM_FEK_75
    //         % SFE_PRISM_126
    //         % SFE_PRISM_GL_126
    //         % SFE_PRISM_196
    //         % SFE_HEXA_GL_8
    //         % SFE_HEXA_GL_27
    //         % SFE_HEXA_64
    //         % SFE_HEXA_GL_64
    //         % SFE_HEXA_125
    //         % SFE_HEXA_GL_125
    //         % SFE_HEXA_216
    //         % SFE_HEXA_GL_216
    //         % SFE_HEXA_343
    //         % SFE_HEXA_GL_343
    cond = true;
  } else {
    cond = false;
  }
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(cond, "");
  //  potentially skip re-tabulating
  //  Compute phy. coordinates of qpoints
  b_sfe->cs_phy.set_size(b_sfe->nqp, xs.size(1));
  i = b_sfe->nqp;
  for (int32_T q{0}; q < i; q++) {
    int32_T i1;
    //  NOTE The following can be optimized efficiently due to the the upper
    //  bound of dimension (i.e., size(xs,2)) is known.
    i1 = xs.size(1);
    for (int32_T k{0}; k < i1; k++) {
      real_T v;
      int32_T m;
      // interpolate_shape - Interpolate f with q-th shape function in the table
      //
      //    v = interpolate_shape(shapes, q, f)
      //    v = interpolate_shape(shapes, q, f, k)
      m = b_sfe->shapes_geom.size(1);
      v = b_sfe->shapes_geom[b_sfe->shapes_geom.size(1) * q] * xs[k];
      for (int32_T b_i{2}; b_i <= m; b_i++) {
        v += b_sfe->shapes_geom[(b_i + b_sfe->shapes_geom.size(1) * q) - 1] *
             xs[k + xs.size(1) * (b_i - 1)];
      }
      b_sfe->cs_phy[k + b_sfe->cs_phy.size(1) * q] = v;
    }
  }
  //  Compute Jacobian
}

void sfe_init2(SfeObject *b_sfe, int32_T etypes,
               const ::coder::array<real_T, 2U> &xs, int32_T qd_or_natcoords)
{
  real_T dv[9];
  real_T v;
  int32_T i;
  int32_T i1;
  int32_T qd_or_natcoords_tmp;
  int32_T shape;
  int32_T topo_dim;
  // sfe_init - Initialize/reinitialize an sfe object for non-boundary element
  //
  //    sfe = sfe_init(sfe, etypes, xs)
  //    sfe = sfe_init(sfe, etypes, xs, natcoords)
  //    sfe = sfe_init(sfe, etypes, xs, qd)
  //    sfe = sfe_init(sfe, etypes, xs, qd, userquad)
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An SfeObject instance
  //    etypes:     Element type(s), which can be a 2-vector, scalar, or [].
  //                A 2-vector specifies the solution and geometric element
  //                types, and it supports iso-, sub- and super-parametric
  //                elements. If two element types are equal, then one can use a
  //                scalar. An empty array ([]) instructs the function to reuse
  //                the element type and the tabulation stored in the `sfe`
  //                object (typically from a previous call).
  //    xs:         Physical coordinates of the element, which is defined in
  //                the geometric space
  //    qd:         Quadrature degree, a zero value indicate the use of default
  //                quadrature rules based on the element types. If `-1` is
  //                passed in, then the code will assume user-provided
  //                quadrature rule information
  //    userquad:   This field is only accessed if qd=-1. If provided, then
  //    userquad
  //                must be a nqp-by-(1+dim) array, where the first column
  //                vector is is the quadrature weights while the rest are their
  //                corresponding quadrature points, defined in the reference
  //                element.
  //
  //  In particular, the user can pass in specific natural coordinates on which
  //  we will compute shape functions and derivatives. In this situation, we
  //  will skip the computation of Jacobian.
  //
  //    natcoords:  List of natural coordinates defined by the user
  //
  //  EXAMPLES
  //  --------
  //  The following initializes a linear triangular element
  //
  //    >> sfe = sfe_init(SfeObject(0), SFE_TRI_3, xs);
  //
  //  The following initializes a quadratic tetrahedral element but with linear
  //  geometry
  //
  //    >> etypes = [SFE_TET_10; SFE_TET_4];
  //    >> sfe = sfe_init(SfeObject(0), etypes, xs);
  //
  //  The following initializes a bi-linear quadrilateral element with
  //  user-provided gravity quadrature rule
  //
  //    >> gravrule = [1, 0.5, 0.5];
  //    >> sfe = sfe_init(SfeObject(0), SFE_QUAD_4, xs, int32(-1), gravrule);
  //
  //  See also SfeObject, ElementTypes, sfe_init_grad
  //  For clarity
  //  Determine solution and geometric spaces
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(true, "invalid element combinations");
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  //  Geometric dimension
  //  Topological dimension
  // obtain_elemdim - Obtain the dimension of an element
  //
  //    dim = obtain_elemdim(etype)
  //
  //  See also obtain_elemshape
  // obtain_elemshape - Decode an element geometric shape from etype
  //
  //    shapeid = obtain_elemshape(etype)
  //
  //  RETURN
  //  ------
  //    shapeid:    Integer type of different geometry shapes:
  //                    1 - BAR
  //                    2 - TRI
  //                    3 - QUAD
  //                    4 - TET
  //                    5 - PYRAMID
  //                    6 - PRISM
  //                    7 - HEX
  //
  //  See also obtain_elemdim
  //  shapeid = (etype>>5)&0b111
  shape = etypes >> 5;
  topo_dim = ((shape > 0) + (shape > 1)) + (shape > 3);
  //  Geometric dimension
  if (xs.size(1) < topo_dim) {
    //  m2cError  Throw error and display message in MATLAB or C++
    //
    //     m2cError(format)
    //     m2cError(format,A1,...,An)
    //     m2cError(errID,___)
    //
    //  This function has the same interface as MATLAB's built-in `error`,
    //  except that the `format` must be a constant string during code
    //  generation.
    //
    //  Notes
    //  -----
    //  The format must be a constant string during code-generation time.
    //
    //  See also error, m2cWarning
    m2cErrMsgIdAndTxt("sfe_init:badDim",
                      "geometric dim cannot be smaller than topo dim");
  }
  b_sfe->geom_dim = xs.size(1);
  //  assign geom dimension
  b_sfe->topo_dim = topo_dim;
  //  assign topo dimension
  //  Make sure the coordinate size are the same
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(iv[etypes - 1] == xs.size(0), "nnodes do not match");
  b_sfe->etypes[0] = etypes;
  b_sfe->etypes[1] = etypes;
  //  Get number of nodes per element
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  i = iv[etypes - 1];
  b_sfe->nnodes[0] = i;
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  b_sfe->nnodes[1] = i;
  //  Set up quadrature
  if (qd_or_natcoords != -1) {
    if (qd_or_natcoords == 0) {
      //  trial+test+nonlinear_geom?1:0
      //  NOTE, this might be overkill for gradient
      // obtain_elemdegree - Decode the element degree from etype
      //
      //    deg = obtain_elemdegree(etype)
      //
      //  See also obtain_elemnnodes
      //  deg = (etype>>2)&0b111;
      // obtain_elemdegree - Decode the element degree from etype
      //
      //    deg = obtain_elemdegree(etype)
      //
      //  See also obtain_elemnnodes
      //  deg = (etype>>2)&0b111;
      qd_or_natcoords_tmp = etypes >> 2 & 7;
      qd_or_natcoords =
          ((qd_or_natcoords_tmp << 1) + (qd_or_natcoords_tmp > 1)) +
          (xs.size(1) > topo_dim);
    }
    tabulate_quadratures(etypes, qd_or_natcoords, b_sfe->cs, b_sfe->ws);
    b_sfe->nqp = b_sfe->ws.size(0);
  } else {
    //  m2cError  Throw error and display message in MATLAB or C++
    //
    //     m2cError(format)
    //     m2cError(format,A1,...,An)
    //     m2cError(errID,___)
    //
    //  This function has the same interface as MATLAB's built-in `error`,
    //  except that the `format` must be a constant string during code
    //  generation.
    //
    //  Notes
    //  -----
    //  The format must be a constant string during code-generation time.
    //
    //  See also error, m2cWarning
    m2cErrMsgIdAndTxt("sfe_init:missUserQuad", "missing user quadrature data");
    //  m2cError  Throw error and display message in MATLAB or C++
    //
    //     m2cError(format)
    //     m2cError(format,A1,...,An)
    //     m2cError(errID,___)
    //
    //  This function has the same interface as MATLAB's built-in `error`,
    //  except that the `format` must be a constant string during code
    //  generation.
    //
    //  Notes
    //  -----
    //  The format must be a constant string during code-generation time.
    //
    //  See also error, m2cWarning
    m2cErrMsgIdAndTxt("sfe_init:badUserQuadDim",
                      "bad user quadrature data size");
    b_sfe->nqp = 0;
    b_sfe->ws.set_size(0);
    b_sfe->cs.set_size(0, topo_dim);
  }
  //  Solution space shape functions & derivs
  tabulate_shapefuncs(etypes, b_sfe->cs, b_sfe->shapes_sol, b_sfe->derivs_sol);
  //  Geometry space shape functions & derivs
  qd_or_natcoords_tmp = b_sfe->shapes_sol.size(1) * b_sfe->shapes_sol.size(0);
  b_sfe->shapes_geom.set_size(b_sfe->shapes_sol.size(0),
                              b_sfe->shapes_sol.size(1));
  for (i = 0; i < qd_or_natcoords_tmp; i++) {
    b_sfe->shapes_geom[i] = b_sfe->shapes_sol[i];
  }
  qd_or_natcoords_tmp = b_sfe->derivs_sol.size(2) * b_sfe->derivs_sol.size(1) *
                        b_sfe->derivs_sol.size(0);
  b_sfe->derivs_geom.set_size(b_sfe->derivs_sol.size(0),
                              b_sfe->derivs_sol.size(1),
                              b_sfe->derivs_sol.size(2));
  for (i = 0; i < qd_or_natcoords_tmp; i++) {
    b_sfe->derivs_geom[i] = b_sfe->derivs_sol[i];
  }
  //  potentially skip re-tabulating
  //  Compute phy. coordinates of qpoints
  b_sfe->cs_phy.set_size(b_sfe->nqp, xs.size(1));
  i = b_sfe->nqp;
  for (int32_T q{0}; q < i; q++) {
    //  NOTE The following can be optimized efficiently due to the the upper
    //  bound of dimension (i.e., size(xs,2)) is known.
    i1 = xs.size(1);
    for (int32_T k{0}; k < i1; k++) {
      int32_T m;
      // interpolate_shape - Interpolate f with q-th shape function in the table
      //
      //    v = interpolate_shape(shapes, q, f)
      //    v = interpolate_shape(shapes, q, f, k)
      m = b_sfe->shapes_sol.size(1);
      v = b_sfe->shapes_sol[b_sfe->shapes_sol.size(1) * q] * xs[k];
      for (int32_T b_i{2}; b_i <= m; b_i++) {
        v += b_sfe->shapes_sol[(b_i + b_sfe->shapes_sol.size(1) * q) - 1] *
             xs[k + xs.size(1) * (b_i - 1)];
      }
      b_sfe->cs_phy[k + b_sfe->cs_phy.size(1) * q] = v;
    }
  }
  //  Compute Jacobian
  b_sfe->wdetJ.set_size(b_sfe->nqp);
  if ((etypes == 68) || (etypes == 132) || (etypes == 36)) {
    real_T d;
    int32_T geom_dim;
    int32_T n;
    //  A single Jacobian matrix (transpose) is needed for simplex elements
    // compute_jact - Compute Jacobian^T and its determinant from q-th deriv in
    // table
    //
    //    [Jt, d] = compute_jactt(xs, derivs, q)
    //
    //  NOTES
    //  -----
    //  Jt is always shape of 3x3. But only topo_dim-by-geom_dim will be
    //  accessed for computing Jacobian matrix. Note that for 3D surfaces, the
    //  normal direction corresponding to q-th qpiont will be saved to the last
    //  row of J.
    //
    //  In particular, the orientation for the transpose of Jacobian matrix is
    //
    //             [dx/dxi    dy/dxi    dz/dxi  ]
    //        Jt = [dx/deta   dy/deta   dz/deta ]
    //             [dx/dzeta  dy/dzeta  dz/dzeta]
    //
    //  Hence, for surface and curve, Jt has shapes (d-1)xd and 1x3, resp
    //
    //  See also solve_sq
    geom_dim = xs.size(1);
    topo_dim = b_sfe->derivs_sol.size(2);
    std::memset(&dv[0], 0, 9U * sizeof(real_T));
    n = xs.size(0);
    for (int32_T k{0}; k < n; k++) {
      for (int32_T b_i{0}; b_i < topo_dim; b_i++) {
        for (int32_T j{0}; j < geom_dim; j++) {
          i = j + 3 * b_i;
          dv[i] += xs[j + xs.size(1) * k] *
                   b_sfe->derivs_sol[b_i + b_sfe->derivs_sol.size(2) * k];
        }
      }
    }
    if (xs.size(1) == b_sfe->derivs_sol.size(2)) {
      if (xs.size(1) == 1) {
        d = dv[0];
      } else if (xs.size(1) == 2) {
        // det2 - Compute determinant of 2x2 matrix.
        d = dv[0] * dv[4] - dv[1] * dv[3];
      } else {
        // det3 - Compute determinant of 3x3 matrix.
        d = (dv[2] * (dv[3] * dv[7] - dv[4] * dv[6]) +
             dv[5] * (dv[1] * dv[6] - dv[0] * dv[7])) +
            dv[8] * (dv[0] * dv[4] - dv[1] * dv[3]);
      }
    } else if (b_sfe->derivs_sol.size(2) == 1) {
      d = dv[0] * dv[0] + dv[1] * dv[1];
      if (xs.size(1) == 3) {
        d += dv[2] * dv[2];
      }
      d = std::sqrt(d);
    } else {
      //  must be 2x3
      // cross_lastcol - Compute cross(J(1,:),J(2,:)) and store to J(3,:)
      dv[6] = dv[1] * dv[5] - dv[2] * dv[4];
      dv[7] = dv[2] * dv[3] - dv[0] * dv[5];
      dv[8] = dv[0] * dv[4] - dv[1] * dv[3];
      d = std::sqrt((dv[6] * dv[6] + dv[7] * dv[7]) + dv[8] * dv[8]);
    }
    b_sfe->jacTs.set_size(3, 3);
    for (i = 0; i < 9; i++) {
      b_sfe->jacTs[i] = dv[i];
    }
    i = b_sfe->nqp;
    for (int32_T q{0}; q < i; q++) {
      b_sfe->wdetJ[q] = d * b_sfe->ws[q];
    }
  } else {
    //  Super-parametric
    qd_or_natcoords_tmp = b_sfe->nqp * 3;
    b_sfe->jacTs.set_size(qd_or_natcoords_tmp, 3);
    i = b_sfe->nqp;
    for (int32_T q{0}; q < i; q++) {
      int32_T geom_dim;
      int32_T n;
      int32_T y;
      y = q * 3;
      // compute_jact - Compute Jacobian^T and its determinant from q-th deriv
      // in table
      //
      //    [Jt, d] = compute_jactt(xs, derivs, q)
      //
      //  NOTES
      //  -----
      //  Jt is always shape of 3x3. But only topo_dim-by-geom_dim will be
      //  accessed for computing Jacobian matrix. Note that for 3D surfaces, the
      //  normal direction corresponding to q-th qpiont will be saved to the
      //  last row of J.
      //
      //  In particular, the orientation for the transpose of Jacobian matrix is
      //
      //             [dx/dxi    dy/dxi    dz/dxi  ]
      //        Jt = [dx/deta   dy/deta   dz/deta ]
      //             [dx/dzeta  dy/dzeta  dz/dzeta]
      //
      //  Hence, for surface and curve, Jt has shapes (d-1)xd and 1x3, resp
      //
      //  See also solve_sq
      geom_dim = xs.size(1);
      topo_dim = b_sfe->derivs_sol.size(2);
      std::memset(&dv[0], 0, 9U * sizeof(real_T));
      n = xs.size(0);
      for (int32_T k{0}; k < n; k++) {
        for (int32_T b_i{0}; b_i < topo_dim; b_i++) {
          for (int32_T j{0}; j < geom_dim; j++) {
            i1 = j + 3 * b_i;
            dv[i1] += xs[j + xs.size(1) * k] *
                      b_sfe->derivs_sol[(b_i + b_sfe->derivs_sol.size(2) * k) +
                                        b_sfe->derivs_sol.size(2) *
                                            b_sfe->derivs_sol.size(1) * q];
          }
        }
      }
      if (xs.size(1) == b_sfe->derivs_sol.size(2)) {
        if (xs.size(1) == 1) {
          v = dv[0];
        } else if (xs.size(1) == 2) {
          // det2 - Compute determinant of 2x2 matrix.
          v = dv[0] * dv[4] - dv[1] * dv[3];
        } else {
          // det3 - Compute determinant of 3x3 matrix.
          v = (dv[2] * (dv[3] * dv[7] - dv[4] * dv[6]) +
               dv[5] * (dv[1] * dv[6] - dv[0] * dv[7])) +
              dv[8] * (dv[0] * dv[4] - dv[1] * dv[3]);
        }
      } else if (b_sfe->derivs_sol.size(2) == 1) {
        v = dv[0] * dv[0] + dv[1] * dv[1];
        if (xs.size(1) == 3) {
          v += dv[2] * dv[2];
        }
        v = std::sqrt(v);
      } else {
        //  must be 2x3
        // cross_lastcol - Compute cross(J(1,:),J(2,:)) and store to J(3,:)
        dv[6] = dv[1] * dv[5] - dv[2] * dv[4];
        dv[7] = dv[2] * dv[3] - dv[0] * dv[5];
        dv[8] = dv[0] * dv[4] - dv[1] * dv[3];
        v = std::sqrt((dv[6] * dv[6] + dv[7] * dv[7]) + dv[8] * dv[8]);
      }
      for (i1 = 0; i1 < 3; i1++) {
        qd_or_natcoords_tmp = i1 + y;
        b_sfe->jacTs[3 * qd_or_natcoords_tmp] = dv[3 * i1];
        b_sfe->jacTs[3 * qd_or_natcoords_tmp + 1] = dv[3 * i1 + 1];
        b_sfe->jacTs[3 * qd_or_natcoords_tmp + 2] = dv[3 * i1 + 2];
      }
      b_sfe->wdetJ[q] = v;
      b_sfe->wdetJ[q] = b_sfe->wdetJ[q] * b_sfe->ws[q];
    }
  }
}

void sfe_init3(SfeObject *b_sfe, int32_T etypes,
               const ::coder::array<real_T, 2U> &xs)
{
  real_T dv[9];
  real_T v;
  int32_T i;
  int32_T i1;
  int32_T loop_ub;
  int32_T shape;
  int32_T topo_dim;
  // sfe_init - Initialize/reinitialize an sfe object for non-boundary element
  //
  //    sfe = sfe_init(sfe, etypes, xs)
  //    sfe = sfe_init(sfe, etypes, xs, natcoords)
  //    sfe = sfe_init(sfe, etypes, xs, qd)
  //    sfe = sfe_init(sfe, etypes, xs, qd, userquad)
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An SfeObject instance
  //    etypes:     Element type(s), which can be a 2-vector, scalar, or [].
  //                A 2-vector specifies the solution and geometric element
  //                types, and it supports iso-, sub- and super-parametric
  //                elements. If two element types are equal, then one can use a
  //                scalar. An empty array ([]) instructs the function to reuse
  //                the element type and the tabulation stored in the `sfe`
  //                object (typically from a previous call).
  //    xs:         Physical coordinates of the element, which is defined in
  //                the geometric space
  //    qd:         Quadrature degree, a zero value indicate the use of default
  //                quadrature rules based on the element types. If `-1` is
  //                passed in, then the code will assume user-provided
  //                quadrature rule information
  //    userquad:   This field is only accessed if qd=-1. If provided, then
  //    userquad
  //                must be a nqp-by-(1+dim) array, where the first column
  //                vector is is the quadrature weights while the rest are their
  //                corresponding quadrature points, defined in the reference
  //                element.
  //
  //  In particular, the user can pass in specific natural coordinates on which
  //  we will compute shape functions and derivatives. In this situation, we
  //  will skip the computation of Jacobian.
  //
  //    natcoords:  List of natural coordinates defined by the user
  //
  //  EXAMPLES
  //  --------
  //  The following initializes a linear triangular element
  //
  //    >> sfe = sfe_init(SfeObject(0), SFE_TRI_3, xs);
  //
  //  The following initializes a quadratic tetrahedral element but with linear
  //  geometry
  //
  //    >> etypes = [SFE_TET_10; SFE_TET_4];
  //    >> sfe = sfe_init(SfeObject(0), etypes, xs);
  //
  //  The following initializes a bi-linear quadrilateral element with
  //  user-provided gravity quadrature rule
  //
  //    >> gravrule = [1, 0.5, 0.5];
  //    >> sfe = sfe_init(SfeObject(0), SFE_QUAD_4, xs, int32(-1), gravrule);
  //
  //  See also SfeObject, ElementTypes, sfe_init_grad
  //  For clarity
  //  Determine solution and geometric spaces
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(true, "invalid element combinations");
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  //  Geometric dimension
  //  Topological dimension
  // obtain_elemdim - Obtain the dimension of an element
  //
  //    dim = obtain_elemdim(etype)
  //
  //  See also obtain_elemshape
  // obtain_elemshape - Decode an element geometric shape from etype
  //
  //    shapeid = obtain_elemshape(etype)
  //
  //  RETURN
  //  ------
  //    shapeid:    Integer type of different geometry shapes:
  //                    1 - BAR
  //                    2 - TRI
  //                    3 - QUAD
  //                    4 - TET
  //                    5 - PYRAMID
  //                    6 - PRISM
  //                    7 - HEX
  //
  //  See also obtain_elemdim
  //  shapeid = (etype>>5)&0b111
  shape = etypes >> 5;
  topo_dim = ((shape > 0) + (shape > 1)) + (shape > 3);
  //  Geometric dimension
  if (xs.size(1) < topo_dim) {
    //  m2cError  Throw error and display message in MATLAB or C++
    //
    //     m2cError(format)
    //     m2cError(format,A1,...,An)
    //     m2cError(errID,___)
    //
    //  This function has the same interface as MATLAB's built-in `error`,
    //  except that the `format` must be a constant string during code
    //  generation.
    //
    //  Notes
    //  -----
    //  The format must be a constant string during code-generation time.
    //
    //  See also error, m2cWarning
    m2cErrMsgIdAndTxt("sfe_init:badDim",
                      "geometric dim cannot be smaller than topo dim");
  }
  b_sfe->geom_dim = xs.size(1);
  //  assign geom dimension
  b_sfe->topo_dim = topo_dim;
  //  assign topo dimension
  //  Make sure the coordinate size are the same
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(iv[etypes - 1] == xs.size(0), "nnodes do not match");
  b_sfe->etypes[0] = etypes;
  b_sfe->etypes[1] = etypes;
  //  Get number of nodes per element
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  i = iv[etypes - 1];
  b_sfe->nnodes[0] = i;
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  b_sfe->nnodes[1] = i;
  //  Set up quadrature
  //  trial+test+nonlinear_geom?1:0
  //  NOTE, this might be overkill for gradient
  // obtain_elemdegree - Decode the element degree from etype
  //
  //    deg = obtain_elemdegree(etype)
  //
  //  See also obtain_elemnnodes
  //  deg = (etype>>2)&0b111;
  // obtain_elemdegree - Decode the element degree from etype
  //
  //    deg = obtain_elemdegree(etype)
  //
  //  See also obtain_elemnnodes
  //  deg = (etype>>2)&0b111;
  tabulate_quadratures(etypes,
                       (((etypes >> 2 & 7) << 1) + ((etypes >> 2 & 7) > 1)) +
                           (xs.size(1) > topo_dim),
                       b_sfe->cs, b_sfe->ws);
  b_sfe->nqp = b_sfe->ws.size(0);
  //  Solution space shape functions & derivs
  tabulate_shapefuncs(etypes, b_sfe->cs, b_sfe->shapes_sol, b_sfe->derivs_sol);
  //  Geometry space shape functions & derivs
  loop_ub = b_sfe->shapes_sol.size(1) * b_sfe->shapes_sol.size(0);
  b_sfe->shapes_geom.set_size(b_sfe->shapes_sol.size(0),
                              b_sfe->shapes_sol.size(1));
  for (i = 0; i < loop_ub; i++) {
    b_sfe->shapes_geom[i] = b_sfe->shapes_sol[i];
  }
  loop_ub = b_sfe->derivs_sol.size(2) * b_sfe->derivs_sol.size(1) *
            b_sfe->derivs_sol.size(0);
  b_sfe->derivs_geom.set_size(b_sfe->derivs_sol.size(0),
                              b_sfe->derivs_sol.size(1),
                              b_sfe->derivs_sol.size(2));
  for (i = 0; i < loop_ub; i++) {
    b_sfe->derivs_geom[i] = b_sfe->derivs_sol[i];
  }
  //  potentially skip re-tabulating
  //  Compute phy. coordinates of qpoints
  b_sfe->cs_phy.set_size(b_sfe->nqp, xs.size(1));
  i = b_sfe->nqp;
  for (int32_T q{0}; q < i; q++) {
    //  NOTE The following can be optimized efficiently due to the the upper
    //  bound of dimension (i.e., size(xs,2)) is known.
    i1 = xs.size(1);
    for (int32_T k{0}; k < i1; k++) {
      int32_T m;
      // interpolate_shape - Interpolate f with q-th shape function in the table
      //
      //    v = interpolate_shape(shapes, q, f)
      //    v = interpolate_shape(shapes, q, f, k)
      m = b_sfe->shapes_sol.size(1);
      v = b_sfe->shapes_sol[b_sfe->shapes_sol.size(1) * q] * xs[k];
      for (int32_T b_i{2}; b_i <= m; b_i++) {
        v += b_sfe->shapes_sol[(b_i + b_sfe->shapes_sol.size(1) * q) - 1] *
             xs[k + xs.size(1) * (b_i - 1)];
      }
      b_sfe->cs_phy[k + b_sfe->cs_phy.size(1) * q] = v;
    }
  }
  //  Compute Jacobian
  b_sfe->wdetJ.set_size(b_sfe->nqp);
  if ((etypes == 68) || (etypes == 132) || (etypes == 36)) {
    real_T d;
    int32_T geom_dim;
    int32_T n;
    //  A single Jacobian matrix (transpose) is needed for simplex elements
    // compute_jact - Compute Jacobian^T and its determinant from q-th deriv in
    // table
    //
    //    [Jt, d] = compute_jactt(xs, derivs, q)
    //
    //  NOTES
    //  -----
    //  Jt is always shape of 3x3. But only topo_dim-by-geom_dim will be
    //  accessed for computing Jacobian matrix. Note that for 3D surfaces, the
    //  normal direction corresponding to q-th qpiont will be saved to the last
    //  row of J.
    //
    //  In particular, the orientation for the transpose of Jacobian matrix is
    //
    //             [dx/dxi    dy/dxi    dz/dxi  ]
    //        Jt = [dx/deta   dy/deta   dz/deta ]
    //             [dx/dzeta  dy/dzeta  dz/dzeta]
    //
    //  Hence, for surface and curve, Jt has shapes (d-1)xd and 1x3, resp
    //
    //  See also solve_sq
    geom_dim = xs.size(1);
    topo_dim = b_sfe->derivs_sol.size(2);
    std::memset(&dv[0], 0, 9U * sizeof(real_T));
    n = xs.size(0);
    for (int32_T k{0}; k < n; k++) {
      for (int32_T b_i{0}; b_i < topo_dim; b_i++) {
        for (int32_T j{0}; j < geom_dim; j++) {
          i = j + 3 * b_i;
          dv[i] += xs[j + xs.size(1) * k] *
                   b_sfe->derivs_sol[b_i + b_sfe->derivs_sol.size(2) * k];
        }
      }
    }
    if (xs.size(1) == b_sfe->derivs_sol.size(2)) {
      if (xs.size(1) == 1) {
        d = dv[0];
      } else if (xs.size(1) == 2) {
        // det2 - Compute determinant of 2x2 matrix.
        d = dv[0] * dv[4] - dv[1] * dv[3];
      } else {
        // det3 - Compute determinant of 3x3 matrix.
        d = (dv[2] * (dv[3] * dv[7] - dv[4] * dv[6]) +
             dv[5] * (dv[1] * dv[6] - dv[0] * dv[7])) +
            dv[8] * (dv[0] * dv[4] - dv[1] * dv[3]);
      }
    } else if (b_sfe->derivs_sol.size(2) == 1) {
      d = dv[0] * dv[0] + dv[1] * dv[1];
      if (xs.size(1) == 3) {
        d += dv[2] * dv[2];
      }
      d = std::sqrt(d);
    } else {
      //  must be 2x3
      // cross_lastcol - Compute cross(J(1,:),J(2,:)) and store to J(3,:)
      dv[6] = dv[1] * dv[5] - dv[2] * dv[4];
      dv[7] = dv[2] * dv[3] - dv[0] * dv[5];
      dv[8] = dv[0] * dv[4] - dv[1] * dv[3];
      d = std::sqrt((dv[6] * dv[6] + dv[7] * dv[7]) + dv[8] * dv[8]);
    }
    b_sfe->jacTs.set_size(3, 3);
    for (i = 0; i < 9; i++) {
      b_sfe->jacTs[i] = dv[i];
    }
    i = b_sfe->nqp;
    for (int32_T q{0}; q < i; q++) {
      b_sfe->wdetJ[q] = d * b_sfe->ws[q];
    }
  } else {
    //  Super-parametric
    loop_ub = b_sfe->nqp * 3;
    b_sfe->jacTs.set_size(loop_ub, 3);
    i = b_sfe->nqp;
    for (int32_T q{0}; q < i; q++) {
      int32_T geom_dim;
      int32_T n;
      int32_T y;
      y = q * 3;
      // compute_jact - Compute Jacobian^T and its determinant from q-th deriv
      // in table
      //
      //    [Jt, d] = compute_jactt(xs, derivs, q)
      //
      //  NOTES
      //  -----
      //  Jt is always shape of 3x3. But only topo_dim-by-geom_dim will be
      //  accessed for computing Jacobian matrix. Note that for 3D surfaces, the
      //  normal direction corresponding to q-th qpiont will be saved to the
      //  last row of J.
      //
      //  In particular, the orientation for the transpose of Jacobian matrix is
      //
      //             [dx/dxi    dy/dxi    dz/dxi  ]
      //        Jt = [dx/deta   dy/deta   dz/deta ]
      //             [dx/dzeta  dy/dzeta  dz/dzeta]
      //
      //  Hence, for surface and curve, Jt has shapes (d-1)xd and 1x3, resp
      //
      //  See also solve_sq
      geom_dim = xs.size(1);
      topo_dim = b_sfe->derivs_sol.size(2);
      std::memset(&dv[0], 0, 9U * sizeof(real_T));
      n = xs.size(0);
      for (int32_T k{0}; k < n; k++) {
        for (int32_T b_i{0}; b_i < topo_dim; b_i++) {
          for (int32_T j{0}; j < geom_dim; j++) {
            i1 = j + 3 * b_i;
            dv[i1] += xs[j + xs.size(1) * k] *
                      b_sfe->derivs_sol[(b_i + b_sfe->derivs_sol.size(2) * k) +
                                        b_sfe->derivs_sol.size(2) *
                                            b_sfe->derivs_sol.size(1) * q];
          }
        }
      }
      if (xs.size(1) == b_sfe->derivs_sol.size(2)) {
        if (xs.size(1) == 1) {
          v = dv[0];
        } else if (xs.size(1) == 2) {
          // det2 - Compute determinant of 2x2 matrix.
          v = dv[0] * dv[4] - dv[1] * dv[3];
        } else {
          // det3 - Compute determinant of 3x3 matrix.
          v = (dv[2] * (dv[3] * dv[7] - dv[4] * dv[6]) +
               dv[5] * (dv[1] * dv[6] - dv[0] * dv[7])) +
              dv[8] * (dv[0] * dv[4] - dv[1] * dv[3]);
        }
      } else if (b_sfe->derivs_sol.size(2) == 1) {
        v = dv[0] * dv[0] + dv[1] * dv[1];
        if (xs.size(1) == 3) {
          v += dv[2] * dv[2];
        }
        v = std::sqrt(v);
      } else {
        //  must be 2x3
        // cross_lastcol - Compute cross(J(1,:),J(2,:)) and store to J(3,:)
        dv[6] = dv[1] * dv[5] - dv[2] * dv[4];
        dv[7] = dv[2] * dv[3] - dv[0] * dv[5];
        dv[8] = dv[0] * dv[4] - dv[1] * dv[3];
        v = std::sqrt((dv[6] * dv[6] + dv[7] * dv[7]) + dv[8] * dv[8]);
      }
      for (i1 = 0; i1 < 3; i1++) {
        loop_ub = i1 + y;
        b_sfe->jacTs[3 * loop_ub] = dv[3 * i1];
        b_sfe->jacTs[3 * loop_ub + 1] = dv[3 * i1 + 1];
        b_sfe->jacTs[3 * loop_ub + 2] = dv[3 * i1 + 2];
      }
      b_sfe->wdetJ[q] = v;
      b_sfe->wdetJ[q] = b_sfe->wdetJ[q] * b_sfe->ws[q];
    }
  }
}

void sfe_init4(SfeObject *b_sfe, int32_T etypes,
               const ::coder::array<real_T, 2U> &xs,
               const ::coder::array<real_T, 2U> &qd_or_natcoords)
{
  int32_T i;
  int32_T loop_ub;
  int32_T shape;
  int32_T topo_dim;
  // sfe_init - Initialize/reinitialize an sfe object for non-boundary element
  //
  //    sfe = sfe_init(sfe, etypes, xs)
  //    sfe = sfe_init(sfe, etypes, xs, natcoords)
  //    sfe = sfe_init(sfe, etypes, xs, qd)
  //    sfe = sfe_init(sfe, etypes, xs, qd, userquad)
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An SfeObject instance
  //    etypes:     Element type(s), which can be a 2-vector, scalar, or [].
  //                A 2-vector specifies the solution and geometric element
  //                types, and it supports iso-, sub- and super-parametric
  //                elements. If two element types are equal, then one can use a
  //                scalar. An empty array ([]) instructs the function to reuse
  //                the element type and the tabulation stored in the `sfe`
  //                object (typically from a previous call).
  //    xs:         Physical coordinates of the element, which is defined in
  //                the geometric space
  //    qd:         Quadrature degree, a zero value indicate the use of default
  //                quadrature rules based on the element types. If `-1` is
  //                passed in, then the code will assume user-provided
  //                quadrature rule information
  //    userquad:   This field is only accessed if qd=-1. If provided, then
  //    userquad
  //                must be a nqp-by-(1+dim) array, where the first column
  //                vector is is the quadrature weights while the rest are their
  //                corresponding quadrature points, defined in the reference
  //                element.
  //
  //  In particular, the user can pass in specific natural coordinates on which
  //  we will compute shape functions and derivatives. In this situation, we
  //  will skip the computation of Jacobian.
  //
  //    natcoords:  List of natural coordinates defined by the user
  //
  //  EXAMPLES
  //  --------
  //  The following initializes a linear triangular element
  //
  //    >> sfe = sfe_init(SfeObject(0), SFE_TRI_3, xs);
  //
  //  The following initializes a quadratic tetrahedral element but with linear
  //  geometry
  //
  //    >> etypes = [SFE_TET_10; SFE_TET_4];
  //    >> sfe = sfe_init(SfeObject(0), etypes, xs);
  //
  //  The following initializes a bi-linear quadrilateral element with
  //  user-provided gravity quadrature rule
  //
  //    >> gravrule = [1, 0.5, 0.5];
  //    >> sfe = sfe_init(SfeObject(0), SFE_QUAD_4, xs, int32(-1), gravrule);
  //
  //  See also SfeObject, ElementTypes, sfe_init_grad
  //  For clarity
  //  Determine solution and geometric spaces
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(true, "invalid element combinations");
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  //  Geometric dimension
  //  Topological dimension
  // obtain_elemdim - Obtain the dimension of an element
  //
  //    dim = obtain_elemdim(etype)
  //
  //  See also obtain_elemshape
  // obtain_elemshape - Decode an element geometric shape from etype
  //
  //    shapeid = obtain_elemshape(etype)
  //
  //  RETURN
  //  ------
  //    shapeid:    Integer type of different geometry shapes:
  //                    1 - BAR
  //                    2 - TRI
  //                    3 - QUAD
  //                    4 - TET
  //                    5 - PYRAMID
  //                    6 - PRISM
  //                    7 - HEX
  //
  //  See also obtain_elemdim
  //  shapeid = (etype>>5)&0b111
  shape = etypes >> 5;
  topo_dim = ((shape > 0) + (shape > 1)) + (shape > 3);
  //  Geometric dimension
  if (xs.size(1) < topo_dim) {
    //  m2cError  Throw error and display message in MATLAB or C++
    //
    //     m2cError(format)
    //     m2cError(format,A1,...,An)
    //     m2cError(errID,___)
    //
    //  This function has the same interface as MATLAB's built-in `error`,
    //  except that the `format` must be a constant string during code
    //  generation.
    //
    //  Notes
    //  -----
    //  The format must be a constant string during code-generation time.
    //
    //  See also error, m2cWarning
    m2cErrMsgIdAndTxt("sfe_init:badDim",
                      "geometric dim cannot be smaller than topo dim");
  }
  b_sfe->geom_dim = xs.size(1);
  //  assign geom dimension
  b_sfe->topo_dim = topo_dim;
  //  assign topo dimension
  //  Make sure the coordinate size are the same
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(iv[etypes - 1] == xs.size(0), "nnodes do not match");
  b_sfe->etypes[0] = etypes;
  b_sfe->etypes[1] = etypes;
  //  Get number of nodes per element
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  i = iv[etypes - 1];
  b_sfe->nnodes[0] = i;
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  b_sfe->nnodes[1] = i;
  //  User-input natural coordinates
  b_sfe->nqp = qd_or_natcoords.size(0);
  b_sfe->ws.set_size(qd_or_natcoords.size(0));
  loop_ub = qd_or_natcoords.size(0);
  for (i = 0; i < loop_ub; i++) {
    b_sfe->ws[i] = 1.0;
  }
  //  user ones for dummy quad weights
  b_sfe->cs.set_size(qd_or_natcoords.size(0), topo_dim);
  i = qd_or_natcoords.size(0);
  for (int32_T q{0}; q < i; q++) {
    for (int32_T k{0}; k < topo_dim; k++) {
      b_sfe->cs[k + b_sfe->cs.size(1) * q] =
          qd_or_natcoords[k + qd_or_natcoords.size(1) * q];
    }
  }
  //  Solution space shape functions & derivs
  tabulate_shapefuncs(etypes, b_sfe->cs, b_sfe->shapes_sol, b_sfe->derivs_sol);
  //  Geometry space shape functions & derivs
  loop_ub = b_sfe->shapes_sol.size(1) * b_sfe->shapes_sol.size(0);
  b_sfe->shapes_geom.set_size(b_sfe->shapes_sol.size(0),
                              b_sfe->shapes_sol.size(1));
  for (i = 0; i < loop_ub; i++) {
    b_sfe->shapes_geom[i] = b_sfe->shapes_sol[i];
  }
  loop_ub = b_sfe->derivs_sol.size(2) * b_sfe->derivs_sol.size(1) *
            b_sfe->derivs_sol.size(0);
  b_sfe->derivs_geom.set_size(b_sfe->derivs_sol.size(0),
                              b_sfe->derivs_sol.size(1),
                              b_sfe->derivs_sol.size(2));
  for (i = 0; i < loop_ub; i++) {
    b_sfe->derivs_geom[i] = b_sfe->derivs_sol[i];
  }
  //  potentially skip re-tabulating
  //  Compute phy. coordinates of qpoints
  b_sfe->cs_phy.set_size(qd_or_natcoords.size(0), xs.size(1));
  i = qd_or_natcoords.size(0);
  for (int32_T q{0}; q < i; q++) {
    //  NOTE The following can be optimized efficiently due to the the upper
    //  bound of dimension (i.e., size(xs,2)) is known.
    loop_ub = xs.size(1);
    for (int32_T k{0}; k < loop_ub; k++) {
      real_T v;
      int32_T m;
      // interpolate_shape - Interpolate f with q-th shape function in the table
      //
      //    v = interpolate_shape(shapes, q, f)
      //    v = interpolate_shape(shapes, q, f, k)
      m = b_sfe->shapes_sol.size(1);
      v = b_sfe->shapes_sol[b_sfe->shapes_sol.size(1) * q] * xs[k];
      for (int32_T b_i{2}; b_i <= m; b_i++) {
        v += b_sfe->shapes_sol[(b_i + b_sfe->shapes_sol.size(1) * q) - 1] *
             xs[k + xs.size(1) * (b_i - 1)];
      }
      b_sfe->cs_phy[k + b_sfe->cs_phy.size(1) * q] = v;
    }
  }
  //  Compute Jacobian
}

void sfe_init5(SfeObject *b_sfe, const int32_T etypes[2],
               const ::coder::array<real_T, 2U> &xs, int32_T qd_or_natcoords,
               const ::coder::array<real_T, 2U> &userquad)
{
  real_T dv[9];
  real_T v;
  int32_T geom_etype;
  int32_T i;
  int32_T i1;
  int32_T loop_ub;
  int32_T shape;
  int32_T topo_dim;
  boolean_T flag;
  // sfe_init - Initialize/reinitialize an sfe object for non-boundary element
  //
  //    sfe = sfe_init(sfe, etypes, xs)
  //    sfe = sfe_init(sfe, etypes, xs, natcoords)
  //    sfe = sfe_init(sfe, etypes, xs, qd)
  //    sfe = sfe_init(sfe, etypes, xs, qd, userquad)
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An SfeObject instance
  //    etypes:     Element type(s), which can be a 2-vector, scalar, or [].
  //                A 2-vector specifies the solution and geometric element
  //                types, and it supports iso-, sub- and super-parametric
  //                elements. If two element types are equal, then one can use a
  //                scalar. An empty array ([]) instructs the function to reuse
  //                the element type and the tabulation stored in the `sfe`
  //                object (typically from a previous call).
  //    xs:         Physical coordinates of the element, which is defined in
  //                the geometric space
  //    qd:         Quadrature degree, a zero value indicate the use of default
  //                quadrature rules based on the element types. If `-1` is
  //                passed in, then the code will assume user-provided
  //                quadrature rule information
  //    userquad:   This field is only accessed if qd=-1. If provided, then
  //    userquad
  //                must be a nqp-by-(1+dim) array, where the first column
  //                vector is is the quadrature weights while the rest are their
  //                corresponding quadrature points, defined in the reference
  //                element.
  //
  //  In particular, the user can pass in specific natural coordinates on which
  //  we will compute shape functions and derivatives. In this situation, we
  //  will skip the computation of Jacobian.
  //
  //    natcoords:  List of natural coordinates defined by the user
  //
  //  EXAMPLES
  //  --------
  //  The following initializes a linear triangular element
  //
  //    >> sfe = sfe_init(SfeObject(0), SFE_TRI_3, xs);
  //
  //  The following initializes a quadratic tetrahedral element but with linear
  //  geometry
  //
  //    >> etypes = [SFE_TET_10; SFE_TET_4];
  //    >> sfe = sfe_init(SfeObject(0), etypes, xs);
  //
  //  The following initializes a bi-linear quadrilateral element with
  //  user-provided gravity quadrature rule
  //
  //    >> gravrule = [1, 0.5, 0.5];
  //    >> sfe = sfe_init(SfeObject(0), SFE_QUAD_4, xs, int32(-1), gravrule);
  //
  //  See also SfeObject, ElementTypes, sfe_init_grad
  //  For clarity
  //  Determine solution and geometric spaces
  if (etypes[1] == 0) {
    geom_etype = etypes[0];
  } else {
    geom_etype = etypes[1];
  }
  flag = (etypes[0] == geom_etype);
  if (!flag) {
    //  then the shapes must match
    // obtain_elemshape - Decode an element geometric shape from etype
    //
    //    shapeid = obtain_elemshape(etype)
    //
    //  RETURN
    //  ------
    //    shapeid:    Integer type of different geometry shapes:
    //                    1 - BAR
    //                    2 - TRI
    //                    3 - QUAD
    //                    4 - TET
    //                    5 - PYRAMID
    //                    6 - PRISM
    //                    7 - HEX
    //
    //  See also obtain_elemdim
    //  shapeid = (etype>>5)&0b111
    // obtain_elemshape - Decode an element geometric shape from etype
    //
    //    shapeid = obtain_elemshape(etype)
    //
    //  RETURN
    //  ------
    //    shapeid:    Integer type of different geometry shapes:
    //                    1 - BAR
    //                    2 - TRI
    //                    3 - QUAD
    //                    4 - TET
    //                    5 - PYRAMID
    //                    6 - PRISM
    //                    7 - HEX
    //
    //  See also obtain_elemdim
    //  shapeid = (etype>>5)&0b111
    flag = ((etypes[0] >> 5 & 7) == (geom_etype >> 5 & 7));
  }
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(flag, "invalid element combinations");
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  //  Geometric dimension
  //  Topological dimension
  // obtain_elemdim - Obtain the dimension of an element
  //
  //    dim = obtain_elemdim(etype)
  //
  //  See also obtain_elemshape
  // obtain_elemshape - Decode an element geometric shape from etype
  //
  //    shapeid = obtain_elemshape(etype)
  //
  //  RETURN
  //  ------
  //    shapeid:    Integer type of different geometry shapes:
  //                    1 - BAR
  //                    2 - TRI
  //                    3 - QUAD
  //                    4 - TET
  //                    5 - PYRAMID
  //                    6 - PRISM
  //                    7 - HEX
  //
  //  See also obtain_elemdim
  //  shapeid = (etype>>5)&0b111
  shape = etypes[0] >> 5 & 7;
  topo_dim = ((shape > 0) + (shape > 1)) + (shape > 3);
  //  Geometric dimension
  if (xs.size(1) < topo_dim) {
    //  m2cError  Throw error and display message in MATLAB or C++
    //
    //     m2cError(format)
    //     m2cError(format,A1,...,An)
    //     m2cError(errID,___)
    //
    //  This function has the same interface as MATLAB's built-in `error`,
    //  except that the `format` must be a constant string during code
    //  generation.
    //
    //  Notes
    //  -----
    //  The format must be a constant string during code-generation time.
    //
    //  See also error, m2cWarning
    m2cErrMsgIdAndTxt("sfe_init:badDim",
                      "geometric dim cannot be smaller than topo dim");
  }
  b_sfe->geom_dim = xs.size(1);
  //  assign geom dimension
  b_sfe->topo_dim = topo_dim;
  //  assign topo dimension
  //  Make sure the coordinate size are the same
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(iv[geom_etype - 1] == xs.size(0), "nnodes do not match");
  b_sfe->etypes[0] = etypes[0];
  b_sfe->etypes[1] = geom_etype;
  //  Get number of nodes per element
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  b_sfe->nnodes[0] = iv[etypes[0] - 1];
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  b_sfe->nnodes[1] = iv[geom_etype - 1];
  //  Set up quadrature
  if (qd_or_natcoords != -1) {
    if (qd_or_natcoords == 0) {
      //  trial+test+nonlinear_geom?1:0
      //  NOTE, this might be overkill for gradient
      // obtain_elemdegree - Decode the element degree from etype
      //
      //    deg = obtain_elemdegree(etype)
      //
      //  See also obtain_elemnnodes
      //  deg = (etype>>2)&0b111;
      // obtain_elemdegree - Decode the element degree from etype
      //
      //    deg = obtain_elemdegree(etype)
      //
      //  See also obtain_elemnnodes
      //  deg = (etype>>2)&0b111;
      qd_or_natcoords =
          (((etypes[0] >> 2 & 7) << 1) + ((geom_etype >> 2 & 7) > 1)) +
          (xs.size(1) > topo_dim);
    }
    tabulate_quadratures(etypes[0], qd_or_natcoords, b_sfe->cs, b_sfe->ws);
    b_sfe->nqp = b_sfe->ws.size(0);
  } else {
    if ((userquad.size(0) == 0) || (userquad.size(1) == 0)) {
      //  m2cError  Throw error and display message in MATLAB or C++
      //
      //     m2cError(format)
      //     m2cError(format,A1,...,An)
      //     m2cError(errID,___)
      //
      //  This function has the same interface as MATLAB's built-in `error`,
      //  except that the `format` must be a constant string during code
      //  generation.
      //
      //  Notes
      //  -----
      //  The format must be a constant string during code-generation time.
      //
      //  See also error, m2cWarning
      m2cErrMsgIdAndTxt("sfe_init:missUserQuad",
                        "missing user quadrature data");
    }
    if (userquad.size(1) != topo_dim + 1) {
      //  m2cError  Throw error and display message in MATLAB or C++
      //
      //     m2cError(format)
      //     m2cError(format,A1,...,An)
      //     m2cError(errID,___)
      //
      //  This function has the same interface as MATLAB's built-in `error`,
      //  except that the `format` must be a constant string during code
      //  generation.
      //
      //  Notes
      //  -----
      //  The format must be a constant string during code-generation time.
      //
      //  See also error, m2cWarning
      m2cErrMsgIdAndTxt("sfe_init:badUserQuadDim",
                        "bad user quadrature data size");
    }
    b_sfe->nqp = userquad.size(0);
    b_sfe->ws.set_size(userquad.size(0));
    b_sfe->cs.set_size(userquad.size(0), topo_dim);
    i = userquad.size(0);
    for (int32_T q{0}; q < i; q++) {
      b_sfe->ws[q] = userquad[userquad.size(1) * q];
      for (int32_T k{0}; k < topo_dim; k++) {
        b_sfe->cs[k + b_sfe->cs.size(1) * q] =
            userquad[(k + userquad.size(1) * q) + 1];
      }
    }
  }
  //  Solution space shape functions & derivs
  tabulate_shapefuncs(etypes[0], b_sfe->cs, b_sfe->shapes_geom,
                      b_sfe->derivs_geom);
  loop_ub = b_sfe->shapes_geom.size(1) * b_sfe->shapes_geom.size(0);
  b_sfe->shapes_sol.set_size(b_sfe->shapes_geom.size(0),
                             b_sfe->shapes_geom.size(1));
  for (i = 0; i < loop_ub; i++) {
    b_sfe->shapes_sol[i] = b_sfe->shapes_geom[i];
  }
  loop_ub = b_sfe->derivs_geom.size(2) * b_sfe->derivs_geom.size(1) *
            b_sfe->derivs_geom.size(0);
  b_sfe->derivs_sol.set_size(b_sfe->derivs_geom.size(0),
                             b_sfe->derivs_geom.size(1),
                             b_sfe->derivs_geom.size(2));
  for (i = 0; i < loop_ub; i++) {
    b_sfe->derivs_sol[i] = b_sfe->derivs_geom[i];
  }
  //  Geometry space shape functions & derivs
  if (etypes[0] != geom_etype) {
    tabulate_shapefuncs(geom_etype, b_sfe->cs, b_sfe->shapes_geom,
                        b_sfe->derivs_geom);
  }
  //  potentially skip re-tabulating
  //  Compute phy. coordinates of qpoints
  b_sfe->cs_phy.set_size(b_sfe->nqp, xs.size(1));
  i = b_sfe->nqp;
  for (int32_T q{0}; q < i; q++) {
    //  NOTE The following can be optimized efficiently due to the the upper
    //  bound of dimension (i.e., size(xs,2)) is known.
    i1 = xs.size(1);
    for (int32_T k{0}; k < i1; k++) {
      int32_T m;
      // interpolate_shape - Interpolate f with q-th shape function in the table
      //
      //    v = interpolate_shape(shapes, q, f)
      //    v = interpolate_shape(shapes, q, f, k)
      m = b_sfe->shapes_geom.size(1);
      v = b_sfe->shapes_geom[b_sfe->shapes_geom.size(1) * q] * xs[k];
      for (int32_T b_i{2}; b_i <= m; b_i++) {
        v += b_sfe->shapes_geom[(b_i + b_sfe->shapes_geom.size(1) * q) - 1] *
             xs[k + xs.size(1) * (b_i - 1)];
      }
      b_sfe->cs_phy[k + b_sfe->cs_phy.size(1) * q] = v;
    }
  }
  //  Compute Jacobian
  b_sfe->wdetJ.set_size(b_sfe->nqp);
  if ((geom_etype == 68) || (geom_etype == 132) || (geom_etype == 36)) {
    real_T d;
    int32_T geom_dim;
    int32_T n;
    //  A single Jacobian matrix (transpose) is needed for simplex elements
    // compute_jact - Compute Jacobian^T and its determinant from q-th deriv in
    // table
    //
    //    [Jt, d] = compute_jactt(xs, derivs, q)
    //
    //  NOTES
    //  -----
    //  Jt is always shape of 3x3. But only topo_dim-by-geom_dim will be
    //  accessed for computing Jacobian matrix. Note that for 3D surfaces, the
    //  normal direction corresponding to q-th qpiont will be saved to the last
    //  row of J.
    //
    //  In particular, the orientation for the transpose of Jacobian matrix is
    //
    //             [dx/dxi    dy/dxi    dz/dxi  ]
    //        Jt = [dx/deta   dy/deta   dz/deta ]
    //             [dx/dzeta  dy/dzeta  dz/dzeta]
    //
    //  Hence, for surface and curve, Jt has shapes (d-1)xd and 1x3, resp
    //
    //  See also solve_sq
    geom_dim = xs.size(1);
    topo_dim = b_sfe->derivs_geom.size(2);
    std::memset(&dv[0], 0, 9U * sizeof(real_T));
    n = xs.size(0);
    for (int32_T k{0}; k < n; k++) {
      for (int32_T b_i{0}; b_i < topo_dim; b_i++) {
        for (int32_T j{0}; j < geom_dim; j++) {
          i = j + 3 * b_i;
          dv[i] += xs[j + xs.size(1) * k] *
                   b_sfe->derivs_geom[b_i + b_sfe->derivs_geom.size(2) * k];
        }
      }
    }
    if (xs.size(1) == b_sfe->derivs_geom.size(2)) {
      if (xs.size(1) == 1) {
        d = dv[0];
      } else if (xs.size(1) == 2) {
        // det2 - Compute determinant of 2x2 matrix.
        d = dv[0] * dv[4] - dv[1] * dv[3];
      } else {
        // det3 - Compute determinant of 3x3 matrix.
        d = (dv[2] * (dv[3] * dv[7] - dv[4] * dv[6]) +
             dv[5] * (dv[1] * dv[6] - dv[0] * dv[7])) +
            dv[8] * (dv[0] * dv[4] - dv[1] * dv[3]);
      }
    } else if (b_sfe->derivs_geom.size(2) == 1) {
      d = dv[0] * dv[0] + dv[1] * dv[1];
      if (xs.size(1) == 3) {
        d += dv[2] * dv[2];
      }
      d = std::sqrt(d);
    } else {
      //  must be 2x3
      // cross_lastcol - Compute cross(J(1,:),J(2,:)) and store to J(3,:)
      dv[6] = dv[1] * dv[5] - dv[2] * dv[4];
      dv[7] = dv[2] * dv[3] - dv[0] * dv[5];
      dv[8] = dv[0] * dv[4] - dv[1] * dv[3];
      d = std::sqrt((dv[6] * dv[6] + dv[7] * dv[7]) + dv[8] * dv[8]);
    }
    b_sfe->jacTs.set_size(3, 3);
    for (i = 0; i < 9; i++) {
      b_sfe->jacTs[i] = dv[i];
    }
    i = b_sfe->nqp;
    for (int32_T q{0}; q < i; q++) {
      b_sfe->wdetJ[q] = d * b_sfe->ws[q];
    }
  } else {
    //  Super-parametric
    loop_ub = b_sfe->nqp * 3;
    b_sfe->jacTs.set_size(loop_ub, 3);
    i = b_sfe->nqp;
    for (int32_T q{0}; q < i; q++) {
      int32_T geom_dim;
      int32_T n;
      int32_T y;
      y = q * 3;
      // compute_jact - Compute Jacobian^T and its determinant from q-th deriv
      // in table
      //
      //    [Jt, d] = compute_jactt(xs, derivs, q)
      //
      //  NOTES
      //  -----
      //  Jt is always shape of 3x3. But only topo_dim-by-geom_dim will be
      //  accessed for computing Jacobian matrix. Note that for 3D surfaces, the
      //  normal direction corresponding to q-th qpiont will be saved to the
      //  last row of J.
      //
      //  In particular, the orientation for the transpose of Jacobian matrix is
      //
      //             [dx/dxi    dy/dxi    dz/dxi  ]
      //        Jt = [dx/deta   dy/deta   dz/deta ]
      //             [dx/dzeta  dy/dzeta  dz/dzeta]
      //
      //  Hence, for surface and curve, Jt has shapes (d-1)xd and 1x3, resp
      //
      //  See also solve_sq
      geom_dim = xs.size(1);
      topo_dim = b_sfe->derivs_geom.size(2);
      std::memset(&dv[0], 0, 9U * sizeof(real_T));
      n = xs.size(0);
      for (int32_T k{0}; k < n; k++) {
        for (int32_T b_i{0}; b_i < topo_dim; b_i++) {
          for (int32_T j{0}; j < geom_dim; j++) {
            i1 = j + 3 * b_i;
            dv[i1] +=
                xs[j + xs.size(1) * k] *
                b_sfe->derivs_geom[(b_i + b_sfe->derivs_geom.size(2) * k) +
                                   b_sfe->derivs_geom.size(2) *
                                       b_sfe->derivs_geom.size(1) * q];
          }
        }
      }
      if (xs.size(1) == b_sfe->derivs_geom.size(2)) {
        if (xs.size(1) == 1) {
          v = dv[0];
        } else if (xs.size(1) == 2) {
          // det2 - Compute determinant of 2x2 matrix.
          v = dv[0] * dv[4] - dv[1] * dv[3];
        } else {
          // det3 - Compute determinant of 3x3 matrix.
          v = (dv[2] * (dv[3] * dv[7] - dv[4] * dv[6]) +
               dv[5] * (dv[1] * dv[6] - dv[0] * dv[7])) +
              dv[8] * (dv[0] * dv[4] - dv[1] * dv[3]);
        }
      } else if (b_sfe->derivs_geom.size(2) == 1) {
        v = dv[0] * dv[0] + dv[1] * dv[1];
        if (xs.size(1) == 3) {
          v += dv[2] * dv[2];
        }
        v = std::sqrt(v);
      } else {
        //  must be 2x3
        // cross_lastcol - Compute cross(J(1,:),J(2,:)) and store to J(3,:)
        dv[6] = dv[1] * dv[5] - dv[2] * dv[4];
        dv[7] = dv[2] * dv[3] - dv[0] * dv[5];
        dv[8] = dv[0] * dv[4] - dv[1] * dv[3];
        v = std::sqrt((dv[6] * dv[6] + dv[7] * dv[7]) + dv[8] * dv[8]);
      }
      for (i1 = 0; i1 < 3; i1++) {
        loop_ub = i1 + y;
        b_sfe->jacTs[3 * loop_ub] = dv[3 * i1];
        b_sfe->jacTs[3 * loop_ub + 1] = dv[3 * i1 + 1];
        b_sfe->jacTs[3 * loop_ub + 2] = dv[3 * i1 + 2];
      }
      b_sfe->wdetJ[q] = v;
      b_sfe->wdetJ[q] = b_sfe->wdetJ[q] * b_sfe->ws[q];
    }
  }
}

void sfe_init6(SfeObject *b_sfe, const int32_T etypes[2],
               const ::coder::array<real_T, 2U> &xs, int32_T qd_or_natcoords)
{
  real_T dv[9];
  real_T v;
  int32_T geom_etype;
  int32_T i;
  int32_T i1;
  int32_T loop_ub;
  int32_T shape;
  int32_T topo_dim;
  boolean_T flag;
  // sfe_init - Initialize/reinitialize an sfe object for non-boundary element
  //
  //    sfe = sfe_init(sfe, etypes, xs)
  //    sfe = sfe_init(sfe, etypes, xs, natcoords)
  //    sfe = sfe_init(sfe, etypes, xs, qd)
  //    sfe = sfe_init(sfe, etypes, xs, qd, userquad)
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An SfeObject instance
  //    etypes:     Element type(s), which can be a 2-vector, scalar, or [].
  //                A 2-vector specifies the solution and geometric element
  //                types, and it supports iso-, sub- and super-parametric
  //                elements. If two element types are equal, then one can use a
  //                scalar. An empty array ([]) instructs the function to reuse
  //                the element type and the tabulation stored in the `sfe`
  //                object (typically from a previous call).
  //    xs:         Physical coordinates of the element, which is defined in
  //                the geometric space
  //    qd:         Quadrature degree, a zero value indicate the use of default
  //                quadrature rules based on the element types. If `-1` is
  //                passed in, then the code will assume user-provided
  //                quadrature rule information
  //    userquad:   This field is only accessed if qd=-1. If provided, then
  //    userquad
  //                must be a nqp-by-(1+dim) array, where the first column
  //                vector is is the quadrature weights while the rest are their
  //                corresponding quadrature points, defined in the reference
  //                element.
  //
  //  In particular, the user can pass in specific natural coordinates on which
  //  we will compute shape functions and derivatives. In this situation, we
  //  will skip the computation of Jacobian.
  //
  //    natcoords:  List of natural coordinates defined by the user
  //
  //  EXAMPLES
  //  --------
  //  The following initializes a linear triangular element
  //
  //    >> sfe = sfe_init(SfeObject(0), SFE_TRI_3, xs);
  //
  //  The following initializes a quadratic tetrahedral element but with linear
  //  geometry
  //
  //    >> etypes = [SFE_TET_10; SFE_TET_4];
  //    >> sfe = sfe_init(SfeObject(0), etypes, xs);
  //
  //  The following initializes a bi-linear quadrilateral element with
  //  user-provided gravity quadrature rule
  //
  //    >> gravrule = [1, 0.5, 0.5];
  //    >> sfe = sfe_init(SfeObject(0), SFE_QUAD_4, xs, int32(-1), gravrule);
  //
  //  See also SfeObject, ElementTypes, sfe_init_grad
  //  For clarity
  //  Determine solution and geometric spaces
  if (etypes[1] == 0) {
    geom_etype = etypes[0];
  } else {
    geom_etype = etypes[1];
  }
  flag = (etypes[0] == geom_etype);
  if (!flag) {
    //  then the shapes must match
    // obtain_elemshape - Decode an element geometric shape from etype
    //
    //    shapeid = obtain_elemshape(etype)
    //
    //  RETURN
    //  ------
    //    shapeid:    Integer type of different geometry shapes:
    //                    1 - BAR
    //                    2 - TRI
    //                    3 - QUAD
    //                    4 - TET
    //                    5 - PYRAMID
    //                    6 - PRISM
    //                    7 - HEX
    //
    //  See also obtain_elemdim
    //  shapeid = (etype>>5)&0b111
    // obtain_elemshape - Decode an element geometric shape from etype
    //
    //    shapeid = obtain_elemshape(etype)
    //
    //  RETURN
    //  ------
    //    shapeid:    Integer type of different geometry shapes:
    //                    1 - BAR
    //                    2 - TRI
    //                    3 - QUAD
    //                    4 - TET
    //                    5 - PYRAMID
    //                    6 - PRISM
    //                    7 - HEX
    //
    //  See also obtain_elemdim
    //  shapeid = (etype>>5)&0b111
    flag = ((etypes[0] >> 5 & 7) == (geom_etype >> 5 & 7));
  }
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(flag, "invalid element combinations");
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  //  Geometric dimension
  //  Topological dimension
  // obtain_elemdim - Obtain the dimension of an element
  //
  //    dim = obtain_elemdim(etype)
  //
  //  See also obtain_elemshape
  // obtain_elemshape - Decode an element geometric shape from etype
  //
  //    shapeid = obtain_elemshape(etype)
  //
  //  RETURN
  //  ------
  //    shapeid:    Integer type of different geometry shapes:
  //                    1 - BAR
  //                    2 - TRI
  //                    3 - QUAD
  //                    4 - TET
  //                    5 - PYRAMID
  //                    6 - PRISM
  //                    7 - HEX
  //
  //  See also obtain_elemdim
  //  shapeid = (etype>>5)&0b111
  shape = etypes[0] >> 5 & 7;
  topo_dim = ((shape > 0) + (shape > 1)) + (shape > 3);
  //  Geometric dimension
  if (xs.size(1) < topo_dim) {
    //  m2cError  Throw error and display message in MATLAB or C++
    //
    //     m2cError(format)
    //     m2cError(format,A1,...,An)
    //     m2cError(errID,___)
    //
    //  This function has the same interface as MATLAB's built-in `error`,
    //  except that the `format` must be a constant string during code
    //  generation.
    //
    //  Notes
    //  -----
    //  The format must be a constant string during code-generation time.
    //
    //  See also error, m2cWarning
    m2cErrMsgIdAndTxt("sfe_init:badDim",
                      "geometric dim cannot be smaller than topo dim");
  }
  b_sfe->geom_dim = xs.size(1);
  //  assign geom dimension
  b_sfe->topo_dim = topo_dim;
  //  assign topo dimension
  //  Make sure the coordinate size are the same
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(iv[geom_etype - 1] == xs.size(0), "nnodes do not match");
  b_sfe->etypes[0] = etypes[0];
  b_sfe->etypes[1] = geom_etype;
  //  Get number of nodes per element
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  b_sfe->nnodes[0] = iv[etypes[0] - 1];
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  b_sfe->nnodes[1] = iv[geom_etype - 1];
  //  Set up quadrature
  if (qd_or_natcoords != -1) {
    if (qd_or_natcoords == 0) {
      //  trial+test+nonlinear_geom?1:0
      //  NOTE, this might be overkill for gradient
      // obtain_elemdegree - Decode the element degree from etype
      //
      //    deg = obtain_elemdegree(etype)
      //
      //  See also obtain_elemnnodes
      //  deg = (etype>>2)&0b111;
      // obtain_elemdegree - Decode the element degree from etype
      //
      //    deg = obtain_elemdegree(etype)
      //
      //  See also obtain_elemnnodes
      //  deg = (etype>>2)&0b111;
      qd_or_natcoords =
          (((etypes[0] >> 2 & 7) << 1) + ((geom_etype >> 2 & 7) > 1)) +
          (xs.size(1) > topo_dim);
    }
    tabulate_quadratures(etypes[0], qd_or_natcoords, b_sfe->cs, b_sfe->ws);
    b_sfe->nqp = b_sfe->ws.size(0);
  } else {
    //  m2cError  Throw error and display message in MATLAB or C++
    //
    //     m2cError(format)
    //     m2cError(format,A1,...,An)
    //     m2cError(errID,___)
    //
    //  This function has the same interface as MATLAB's built-in `error`,
    //  except that the `format` must be a constant string during code
    //  generation.
    //
    //  Notes
    //  -----
    //  The format must be a constant string during code-generation time.
    //
    //  See also error, m2cWarning
    m2cErrMsgIdAndTxt("sfe_init:missUserQuad", "missing user quadrature data");
    //  m2cError  Throw error and display message in MATLAB or C++
    //
    //     m2cError(format)
    //     m2cError(format,A1,...,An)
    //     m2cError(errID,___)
    //
    //  This function has the same interface as MATLAB's built-in `error`,
    //  except that the `format` must be a constant string during code
    //  generation.
    //
    //  Notes
    //  -----
    //  The format must be a constant string during code-generation time.
    //
    //  See also error, m2cWarning
    m2cErrMsgIdAndTxt("sfe_init:badUserQuadDim",
                      "bad user quadrature data size");
    b_sfe->nqp = 0;
    b_sfe->ws.set_size(0);
    b_sfe->cs.set_size(0, topo_dim);
  }
  //  Solution space shape functions & derivs
  tabulate_shapefuncs(etypes[0], b_sfe->cs, b_sfe->shapes_geom,
                      b_sfe->derivs_geom);
  loop_ub = b_sfe->shapes_geom.size(1) * b_sfe->shapes_geom.size(0);
  b_sfe->shapes_sol.set_size(b_sfe->shapes_geom.size(0),
                             b_sfe->shapes_geom.size(1));
  for (i = 0; i < loop_ub; i++) {
    b_sfe->shapes_sol[i] = b_sfe->shapes_geom[i];
  }
  loop_ub = b_sfe->derivs_geom.size(2) * b_sfe->derivs_geom.size(1) *
            b_sfe->derivs_geom.size(0);
  b_sfe->derivs_sol.set_size(b_sfe->derivs_geom.size(0),
                             b_sfe->derivs_geom.size(1),
                             b_sfe->derivs_geom.size(2));
  for (i = 0; i < loop_ub; i++) {
    b_sfe->derivs_sol[i] = b_sfe->derivs_geom[i];
  }
  //  Geometry space shape functions & derivs
  if (etypes[0] != geom_etype) {
    tabulate_shapefuncs(geom_etype, b_sfe->cs, b_sfe->shapes_geom,
                        b_sfe->derivs_geom);
  }
  //  potentially skip re-tabulating
  //  Compute phy. coordinates of qpoints
  b_sfe->cs_phy.set_size(b_sfe->nqp, xs.size(1));
  i = b_sfe->nqp;
  for (int32_T q{0}; q < i; q++) {
    //  NOTE The following can be optimized efficiently due to the the upper
    //  bound of dimension (i.e., size(xs,2)) is known.
    i1 = xs.size(1);
    for (int32_T k{0}; k < i1; k++) {
      int32_T m;
      // interpolate_shape - Interpolate f with q-th shape function in the table
      //
      //    v = interpolate_shape(shapes, q, f)
      //    v = interpolate_shape(shapes, q, f, k)
      m = b_sfe->shapes_geom.size(1);
      v = b_sfe->shapes_geom[b_sfe->shapes_geom.size(1) * q] * xs[k];
      for (int32_T b_i{2}; b_i <= m; b_i++) {
        v += b_sfe->shapes_geom[(b_i + b_sfe->shapes_geom.size(1) * q) - 1] *
             xs[k + xs.size(1) * (b_i - 1)];
      }
      b_sfe->cs_phy[k + b_sfe->cs_phy.size(1) * q] = v;
    }
  }
  //  Compute Jacobian
  b_sfe->wdetJ.set_size(b_sfe->nqp);
  if ((geom_etype == 68) || (geom_etype == 132) || (geom_etype == 36)) {
    real_T d;
    int32_T geom_dim;
    int32_T n;
    //  A single Jacobian matrix (transpose) is needed for simplex elements
    // compute_jact - Compute Jacobian^T and its determinant from q-th deriv in
    // table
    //
    //    [Jt, d] = compute_jactt(xs, derivs, q)
    //
    //  NOTES
    //  -----
    //  Jt is always shape of 3x3. But only topo_dim-by-geom_dim will be
    //  accessed for computing Jacobian matrix. Note that for 3D surfaces, the
    //  normal direction corresponding to q-th qpiont will be saved to the last
    //  row of J.
    //
    //  In particular, the orientation for the transpose of Jacobian matrix is
    //
    //             [dx/dxi    dy/dxi    dz/dxi  ]
    //        Jt = [dx/deta   dy/deta   dz/deta ]
    //             [dx/dzeta  dy/dzeta  dz/dzeta]
    //
    //  Hence, for surface and curve, Jt has shapes (d-1)xd and 1x3, resp
    //
    //  See also solve_sq
    geom_dim = xs.size(1);
    topo_dim = b_sfe->derivs_geom.size(2);
    std::memset(&dv[0], 0, 9U * sizeof(real_T));
    n = xs.size(0);
    for (int32_T k{0}; k < n; k++) {
      for (int32_T b_i{0}; b_i < topo_dim; b_i++) {
        for (int32_T j{0}; j < geom_dim; j++) {
          i = j + 3 * b_i;
          dv[i] += xs[j + xs.size(1) * k] *
                   b_sfe->derivs_geom[b_i + b_sfe->derivs_geom.size(2) * k];
        }
      }
    }
    if (xs.size(1) == b_sfe->derivs_geom.size(2)) {
      if (xs.size(1) == 1) {
        d = dv[0];
      } else if (xs.size(1) == 2) {
        // det2 - Compute determinant of 2x2 matrix.
        d = dv[0] * dv[4] - dv[1] * dv[3];
      } else {
        // det3 - Compute determinant of 3x3 matrix.
        d = (dv[2] * (dv[3] * dv[7] - dv[4] * dv[6]) +
             dv[5] * (dv[1] * dv[6] - dv[0] * dv[7])) +
            dv[8] * (dv[0] * dv[4] - dv[1] * dv[3]);
      }
    } else if (b_sfe->derivs_geom.size(2) == 1) {
      d = dv[0] * dv[0] + dv[1] * dv[1];
      if (xs.size(1) == 3) {
        d += dv[2] * dv[2];
      }
      d = std::sqrt(d);
    } else {
      //  must be 2x3
      // cross_lastcol - Compute cross(J(1,:),J(2,:)) and store to J(3,:)
      dv[6] = dv[1] * dv[5] - dv[2] * dv[4];
      dv[7] = dv[2] * dv[3] - dv[0] * dv[5];
      dv[8] = dv[0] * dv[4] - dv[1] * dv[3];
      d = std::sqrt((dv[6] * dv[6] + dv[7] * dv[7]) + dv[8] * dv[8]);
    }
    b_sfe->jacTs.set_size(3, 3);
    for (i = 0; i < 9; i++) {
      b_sfe->jacTs[i] = dv[i];
    }
    i = b_sfe->nqp;
    for (int32_T q{0}; q < i; q++) {
      b_sfe->wdetJ[q] = d * b_sfe->ws[q];
    }
  } else {
    //  Super-parametric
    loop_ub = b_sfe->nqp * 3;
    b_sfe->jacTs.set_size(loop_ub, 3);
    i = b_sfe->nqp;
    for (int32_T q{0}; q < i; q++) {
      int32_T geom_dim;
      int32_T n;
      int32_T y;
      y = q * 3;
      // compute_jact - Compute Jacobian^T and its determinant from q-th deriv
      // in table
      //
      //    [Jt, d] = compute_jactt(xs, derivs, q)
      //
      //  NOTES
      //  -----
      //  Jt is always shape of 3x3. But only topo_dim-by-geom_dim will be
      //  accessed for computing Jacobian matrix. Note that for 3D surfaces, the
      //  normal direction corresponding to q-th qpiont will be saved to the
      //  last row of J.
      //
      //  In particular, the orientation for the transpose of Jacobian matrix is
      //
      //             [dx/dxi    dy/dxi    dz/dxi  ]
      //        Jt = [dx/deta   dy/deta   dz/deta ]
      //             [dx/dzeta  dy/dzeta  dz/dzeta]
      //
      //  Hence, for surface and curve, Jt has shapes (d-1)xd and 1x3, resp
      //
      //  See also solve_sq
      geom_dim = xs.size(1);
      topo_dim = b_sfe->derivs_geom.size(2);
      std::memset(&dv[0], 0, 9U * sizeof(real_T));
      n = xs.size(0);
      for (int32_T k{0}; k < n; k++) {
        for (int32_T b_i{0}; b_i < topo_dim; b_i++) {
          for (int32_T j{0}; j < geom_dim; j++) {
            i1 = j + 3 * b_i;
            dv[i1] +=
                xs[j + xs.size(1) * k] *
                b_sfe->derivs_geom[(b_i + b_sfe->derivs_geom.size(2) * k) +
                                   b_sfe->derivs_geom.size(2) *
                                       b_sfe->derivs_geom.size(1) * q];
          }
        }
      }
      if (xs.size(1) == b_sfe->derivs_geom.size(2)) {
        if (xs.size(1) == 1) {
          v = dv[0];
        } else if (xs.size(1) == 2) {
          // det2 - Compute determinant of 2x2 matrix.
          v = dv[0] * dv[4] - dv[1] * dv[3];
        } else {
          // det3 - Compute determinant of 3x3 matrix.
          v = (dv[2] * (dv[3] * dv[7] - dv[4] * dv[6]) +
               dv[5] * (dv[1] * dv[6] - dv[0] * dv[7])) +
              dv[8] * (dv[0] * dv[4] - dv[1] * dv[3]);
        }
      } else if (b_sfe->derivs_geom.size(2) == 1) {
        v = dv[0] * dv[0] + dv[1] * dv[1];
        if (xs.size(1) == 3) {
          v += dv[2] * dv[2];
        }
        v = std::sqrt(v);
      } else {
        //  must be 2x3
        // cross_lastcol - Compute cross(J(1,:),J(2,:)) and store to J(3,:)
        dv[6] = dv[1] * dv[5] - dv[2] * dv[4];
        dv[7] = dv[2] * dv[3] - dv[0] * dv[5];
        dv[8] = dv[0] * dv[4] - dv[1] * dv[3];
        v = std::sqrt((dv[6] * dv[6] + dv[7] * dv[7]) + dv[8] * dv[8]);
      }
      for (i1 = 0; i1 < 3; i1++) {
        loop_ub = i1 + y;
        b_sfe->jacTs[3 * loop_ub] = dv[3 * i1];
        b_sfe->jacTs[3 * loop_ub + 1] = dv[3 * i1 + 1];
        b_sfe->jacTs[3 * loop_ub + 2] = dv[3 * i1 + 2];
      }
      b_sfe->wdetJ[q] = v;
      b_sfe->wdetJ[q] = b_sfe->wdetJ[q] * b_sfe->ws[q];
    }
  }
}

void sfe_init7(SfeObject *b_sfe, const int32_T etypes[2],
               const ::coder::array<real_T, 2U> &xs)
{
  real_T dv[9];
  real_T v;
  int32_T geom_etype;
  int32_T i;
  int32_T i1;
  int32_T loop_ub;
  int32_T shape;
  int32_T topo_dim;
  boolean_T flag;
  // sfe_init - Initialize/reinitialize an sfe object for non-boundary element
  //
  //    sfe = sfe_init(sfe, etypes, xs)
  //    sfe = sfe_init(sfe, etypes, xs, natcoords)
  //    sfe = sfe_init(sfe, etypes, xs, qd)
  //    sfe = sfe_init(sfe, etypes, xs, qd, userquad)
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An SfeObject instance
  //    etypes:     Element type(s), which can be a 2-vector, scalar, or [].
  //                A 2-vector specifies the solution and geometric element
  //                types, and it supports iso-, sub- and super-parametric
  //                elements. If two element types are equal, then one can use a
  //                scalar. An empty array ([]) instructs the function to reuse
  //                the element type and the tabulation stored in the `sfe`
  //                object (typically from a previous call).
  //    xs:         Physical coordinates of the element, which is defined in
  //                the geometric space
  //    qd:         Quadrature degree, a zero value indicate the use of default
  //                quadrature rules based on the element types. If `-1` is
  //                passed in, then the code will assume user-provided
  //                quadrature rule information
  //    userquad:   This field is only accessed if qd=-1. If provided, then
  //    userquad
  //                must be a nqp-by-(1+dim) array, where the first column
  //                vector is is the quadrature weights while the rest are their
  //                corresponding quadrature points, defined in the reference
  //                element.
  //
  //  In particular, the user can pass in specific natural coordinates on which
  //  we will compute shape functions and derivatives. In this situation, we
  //  will skip the computation of Jacobian.
  //
  //    natcoords:  List of natural coordinates defined by the user
  //
  //  EXAMPLES
  //  --------
  //  The following initializes a linear triangular element
  //
  //    >> sfe = sfe_init(SfeObject(0), SFE_TRI_3, xs);
  //
  //  The following initializes a quadratic tetrahedral element but with linear
  //  geometry
  //
  //    >> etypes = [SFE_TET_10; SFE_TET_4];
  //    >> sfe = sfe_init(SfeObject(0), etypes, xs);
  //
  //  The following initializes a bi-linear quadrilateral element with
  //  user-provided gravity quadrature rule
  //
  //    >> gravrule = [1, 0.5, 0.5];
  //    >> sfe = sfe_init(SfeObject(0), SFE_QUAD_4, xs, int32(-1), gravrule);
  //
  //  See also SfeObject, ElementTypes, sfe_init_grad
  //  For clarity
  //  Determine solution and geometric spaces
  if (etypes[1] == 0) {
    geom_etype = etypes[0];
  } else {
    geom_etype = etypes[1];
  }
  flag = (etypes[0] == geom_etype);
  if (!flag) {
    //  then the shapes must match
    // obtain_elemshape - Decode an element geometric shape from etype
    //
    //    shapeid = obtain_elemshape(etype)
    //
    //  RETURN
    //  ------
    //    shapeid:    Integer type of different geometry shapes:
    //                    1 - BAR
    //                    2 - TRI
    //                    3 - QUAD
    //                    4 - TET
    //                    5 - PYRAMID
    //                    6 - PRISM
    //                    7 - HEX
    //
    //  See also obtain_elemdim
    //  shapeid = (etype>>5)&0b111
    // obtain_elemshape - Decode an element geometric shape from etype
    //
    //    shapeid = obtain_elemshape(etype)
    //
    //  RETURN
    //  ------
    //    shapeid:    Integer type of different geometry shapes:
    //                    1 - BAR
    //                    2 - TRI
    //                    3 - QUAD
    //                    4 - TET
    //                    5 - PYRAMID
    //                    6 - PRISM
    //                    7 - HEX
    //
    //  See also obtain_elemdim
    //  shapeid = (etype>>5)&0b111
    flag = ((etypes[0] >> 5 & 7) == (geom_etype >> 5 & 7));
  }
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(flag, "invalid element combinations");
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  //  Geometric dimension
  //  Topological dimension
  // obtain_elemdim - Obtain the dimension of an element
  //
  //    dim = obtain_elemdim(etype)
  //
  //  See also obtain_elemshape
  // obtain_elemshape - Decode an element geometric shape from etype
  //
  //    shapeid = obtain_elemshape(etype)
  //
  //  RETURN
  //  ------
  //    shapeid:    Integer type of different geometry shapes:
  //                    1 - BAR
  //                    2 - TRI
  //                    3 - QUAD
  //                    4 - TET
  //                    5 - PYRAMID
  //                    6 - PRISM
  //                    7 - HEX
  //
  //  See also obtain_elemdim
  //  shapeid = (etype>>5)&0b111
  shape = etypes[0] >> 5 & 7;
  topo_dim = ((shape > 0) + (shape > 1)) + (shape > 3);
  //  Geometric dimension
  if (xs.size(1) < topo_dim) {
    //  m2cError  Throw error and display message in MATLAB or C++
    //
    //     m2cError(format)
    //     m2cError(format,A1,...,An)
    //     m2cError(errID,___)
    //
    //  This function has the same interface as MATLAB's built-in `error`,
    //  except that the `format` must be a constant string during code
    //  generation.
    //
    //  Notes
    //  -----
    //  The format must be a constant string during code-generation time.
    //
    //  See also error, m2cWarning
    m2cErrMsgIdAndTxt("sfe_init:badDim",
                      "geometric dim cannot be smaller than topo dim");
  }
  b_sfe->geom_dim = xs.size(1);
  //  assign geom dimension
  b_sfe->topo_dim = topo_dim;
  //  assign topo dimension
  //  Make sure the coordinate size are the same
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(iv[geom_etype - 1] == xs.size(0), "nnodes do not match");
  b_sfe->etypes[0] = etypes[0];
  b_sfe->etypes[1] = geom_etype;
  //  Get number of nodes per element
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  b_sfe->nnodes[0] = iv[etypes[0] - 1];
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  b_sfe->nnodes[1] = iv[geom_etype - 1];
  //  Set up quadrature
  //  trial+test+nonlinear_geom?1:0
  //  NOTE, this might be overkill for gradient
  // obtain_elemdegree - Decode the element degree from etype
  //
  //    deg = obtain_elemdegree(etype)
  //
  //  See also obtain_elemnnodes
  //  deg = (etype>>2)&0b111;
  // obtain_elemdegree - Decode the element degree from etype
  //
  //    deg = obtain_elemdegree(etype)
  //
  //  See also obtain_elemnnodes
  //  deg = (etype>>2)&0b111;
  tabulate_quadratures(
      etypes[0],
      (((etypes[0] >> 2 & 7) << 1) + ((geom_etype >> 2 & 7) > 1)) +
          (xs.size(1) > topo_dim),
      b_sfe->cs, b_sfe->ws);
  b_sfe->nqp = b_sfe->ws.size(0);
  //  Solution space shape functions & derivs
  tabulate_shapefuncs(etypes[0], b_sfe->cs, b_sfe->shapes_geom,
                      b_sfe->derivs_geom);
  loop_ub = b_sfe->shapes_geom.size(1) * b_sfe->shapes_geom.size(0);
  b_sfe->shapes_sol.set_size(b_sfe->shapes_geom.size(0),
                             b_sfe->shapes_geom.size(1));
  for (i = 0; i < loop_ub; i++) {
    b_sfe->shapes_sol[i] = b_sfe->shapes_geom[i];
  }
  loop_ub = b_sfe->derivs_geom.size(2) * b_sfe->derivs_geom.size(1) *
            b_sfe->derivs_geom.size(0);
  b_sfe->derivs_sol.set_size(b_sfe->derivs_geom.size(0),
                             b_sfe->derivs_geom.size(1),
                             b_sfe->derivs_geom.size(2));
  for (i = 0; i < loop_ub; i++) {
    b_sfe->derivs_sol[i] = b_sfe->derivs_geom[i];
  }
  //  Geometry space shape functions & derivs
  if (etypes[0] != geom_etype) {
    tabulate_shapefuncs(geom_etype, b_sfe->cs, b_sfe->shapes_geom,
                        b_sfe->derivs_geom);
  }
  //  potentially skip re-tabulating
  //  Compute phy. coordinates of qpoints
  b_sfe->cs_phy.set_size(b_sfe->nqp, xs.size(1));
  i = b_sfe->nqp;
  for (int32_T q{0}; q < i; q++) {
    //  NOTE The following can be optimized efficiently due to the the upper
    //  bound of dimension (i.e., size(xs,2)) is known.
    i1 = xs.size(1);
    for (int32_T k{0}; k < i1; k++) {
      int32_T m;
      // interpolate_shape - Interpolate f with q-th shape function in the table
      //
      //    v = interpolate_shape(shapes, q, f)
      //    v = interpolate_shape(shapes, q, f, k)
      m = b_sfe->shapes_geom.size(1);
      v = b_sfe->shapes_geom[b_sfe->shapes_geom.size(1) * q] * xs[k];
      for (int32_T b_i{2}; b_i <= m; b_i++) {
        v += b_sfe->shapes_geom[(b_i + b_sfe->shapes_geom.size(1) * q) - 1] *
             xs[k + xs.size(1) * (b_i - 1)];
      }
      b_sfe->cs_phy[k + b_sfe->cs_phy.size(1) * q] = v;
    }
  }
  //  Compute Jacobian
  b_sfe->wdetJ.set_size(b_sfe->nqp);
  if ((geom_etype == 68) || (geom_etype == 132) || (geom_etype == 36)) {
    real_T d;
    int32_T geom_dim;
    int32_T n;
    //  A single Jacobian matrix (transpose) is needed for simplex elements
    // compute_jact - Compute Jacobian^T and its determinant from q-th deriv in
    // table
    //
    //    [Jt, d] = compute_jactt(xs, derivs, q)
    //
    //  NOTES
    //  -----
    //  Jt is always shape of 3x3. But only topo_dim-by-geom_dim will be
    //  accessed for computing Jacobian matrix. Note that for 3D surfaces, the
    //  normal direction corresponding to q-th qpiont will be saved to the last
    //  row of J.
    //
    //  In particular, the orientation for the transpose of Jacobian matrix is
    //
    //             [dx/dxi    dy/dxi    dz/dxi  ]
    //        Jt = [dx/deta   dy/deta   dz/deta ]
    //             [dx/dzeta  dy/dzeta  dz/dzeta]
    //
    //  Hence, for surface and curve, Jt has shapes (d-1)xd and 1x3, resp
    //
    //  See also solve_sq
    geom_dim = xs.size(1);
    topo_dim = b_sfe->derivs_geom.size(2);
    std::memset(&dv[0], 0, 9U * sizeof(real_T));
    n = xs.size(0);
    for (int32_T k{0}; k < n; k++) {
      for (int32_T b_i{0}; b_i < topo_dim; b_i++) {
        for (int32_T j{0}; j < geom_dim; j++) {
          i = j + 3 * b_i;
          dv[i] += xs[j + xs.size(1) * k] *
                   b_sfe->derivs_geom[b_i + b_sfe->derivs_geom.size(2) * k];
        }
      }
    }
    if (xs.size(1) == b_sfe->derivs_geom.size(2)) {
      if (xs.size(1) == 1) {
        d = dv[0];
      } else if (xs.size(1) == 2) {
        // det2 - Compute determinant of 2x2 matrix.
        d = dv[0] * dv[4] - dv[1] * dv[3];
      } else {
        // det3 - Compute determinant of 3x3 matrix.
        d = (dv[2] * (dv[3] * dv[7] - dv[4] * dv[6]) +
             dv[5] * (dv[1] * dv[6] - dv[0] * dv[7])) +
            dv[8] * (dv[0] * dv[4] - dv[1] * dv[3]);
      }
    } else if (b_sfe->derivs_geom.size(2) == 1) {
      d = dv[0] * dv[0] + dv[1] * dv[1];
      if (xs.size(1) == 3) {
        d += dv[2] * dv[2];
      }
      d = std::sqrt(d);
    } else {
      //  must be 2x3
      // cross_lastcol - Compute cross(J(1,:),J(2,:)) and store to J(3,:)
      dv[6] = dv[1] * dv[5] - dv[2] * dv[4];
      dv[7] = dv[2] * dv[3] - dv[0] * dv[5];
      dv[8] = dv[0] * dv[4] - dv[1] * dv[3];
      d = std::sqrt((dv[6] * dv[6] + dv[7] * dv[7]) + dv[8] * dv[8]);
    }
    b_sfe->jacTs.set_size(3, 3);
    for (i = 0; i < 9; i++) {
      b_sfe->jacTs[i] = dv[i];
    }
    i = b_sfe->nqp;
    for (int32_T q{0}; q < i; q++) {
      b_sfe->wdetJ[q] = d * b_sfe->ws[q];
    }
  } else {
    //  Super-parametric
    loop_ub = b_sfe->nqp * 3;
    b_sfe->jacTs.set_size(loop_ub, 3);
    i = b_sfe->nqp;
    for (int32_T q{0}; q < i; q++) {
      int32_T geom_dim;
      int32_T n;
      int32_T y;
      y = q * 3;
      // compute_jact - Compute Jacobian^T and its determinant from q-th deriv
      // in table
      //
      //    [Jt, d] = compute_jactt(xs, derivs, q)
      //
      //  NOTES
      //  -----
      //  Jt is always shape of 3x3. But only topo_dim-by-geom_dim will be
      //  accessed for computing Jacobian matrix. Note that for 3D surfaces, the
      //  normal direction corresponding to q-th qpiont will be saved to the
      //  last row of J.
      //
      //  In particular, the orientation for the transpose of Jacobian matrix is
      //
      //             [dx/dxi    dy/dxi    dz/dxi  ]
      //        Jt = [dx/deta   dy/deta   dz/deta ]
      //             [dx/dzeta  dy/dzeta  dz/dzeta]
      //
      //  Hence, for surface and curve, Jt has shapes (d-1)xd and 1x3, resp
      //
      //  See also solve_sq
      geom_dim = xs.size(1);
      topo_dim = b_sfe->derivs_geom.size(2);
      std::memset(&dv[0], 0, 9U * sizeof(real_T));
      n = xs.size(0);
      for (int32_T k{0}; k < n; k++) {
        for (int32_T b_i{0}; b_i < topo_dim; b_i++) {
          for (int32_T j{0}; j < geom_dim; j++) {
            i1 = j + 3 * b_i;
            dv[i1] +=
                xs[j + xs.size(1) * k] *
                b_sfe->derivs_geom[(b_i + b_sfe->derivs_geom.size(2) * k) +
                                   b_sfe->derivs_geom.size(2) *
                                       b_sfe->derivs_geom.size(1) * q];
          }
        }
      }
      if (xs.size(1) == b_sfe->derivs_geom.size(2)) {
        if (xs.size(1) == 1) {
          v = dv[0];
        } else if (xs.size(1) == 2) {
          // det2 - Compute determinant of 2x2 matrix.
          v = dv[0] * dv[4] - dv[1] * dv[3];
        } else {
          // det3 - Compute determinant of 3x3 matrix.
          v = (dv[2] * (dv[3] * dv[7] - dv[4] * dv[6]) +
               dv[5] * (dv[1] * dv[6] - dv[0] * dv[7])) +
              dv[8] * (dv[0] * dv[4] - dv[1] * dv[3]);
        }
      } else if (b_sfe->derivs_geom.size(2) == 1) {
        v = dv[0] * dv[0] + dv[1] * dv[1];
        if (xs.size(1) == 3) {
          v += dv[2] * dv[2];
        }
        v = std::sqrt(v);
      } else {
        //  must be 2x3
        // cross_lastcol - Compute cross(J(1,:),J(2,:)) and store to J(3,:)
        dv[6] = dv[1] * dv[5] - dv[2] * dv[4];
        dv[7] = dv[2] * dv[3] - dv[0] * dv[5];
        dv[8] = dv[0] * dv[4] - dv[1] * dv[3];
        v = std::sqrt((dv[6] * dv[6] + dv[7] * dv[7]) + dv[8] * dv[8]);
      }
      for (i1 = 0; i1 < 3; i1++) {
        loop_ub = i1 + y;
        b_sfe->jacTs[3 * loop_ub] = dv[3 * i1];
        b_sfe->jacTs[3 * loop_ub + 1] = dv[3 * i1 + 1];
        b_sfe->jacTs[3 * loop_ub + 2] = dv[3 * i1 + 2];
      }
      b_sfe->wdetJ[q] = v;
      b_sfe->wdetJ[q] = b_sfe->wdetJ[q] * b_sfe->ws[q];
    }
  }
}

void sfe_init8(SfeObject *b_sfe, const int32_T etypes[2],
               const ::coder::array<real_T, 2U> &xs,
               const ::coder::array<real_T, 2U> &qd_or_natcoords)
{
  int32_T geom_etype;
  int32_T i;
  int32_T loop_ub;
  int32_T shape;
  int32_T topo_dim;
  boolean_T flag;
  // sfe_init - Initialize/reinitialize an sfe object for non-boundary element
  //
  //    sfe = sfe_init(sfe, etypes, xs)
  //    sfe = sfe_init(sfe, etypes, xs, natcoords)
  //    sfe = sfe_init(sfe, etypes, xs, qd)
  //    sfe = sfe_init(sfe, etypes, xs, qd, userquad)
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An SfeObject instance
  //    etypes:     Element type(s), which can be a 2-vector, scalar, or [].
  //                A 2-vector specifies the solution and geometric element
  //                types, and it supports iso-, sub- and super-parametric
  //                elements. If two element types are equal, then one can use a
  //                scalar. An empty array ([]) instructs the function to reuse
  //                the element type and the tabulation stored in the `sfe`
  //                object (typically from a previous call).
  //    xs:         Physical coordinates of the element, which is defined in
  //                the geometric space
  //    qd:         Quadrature degree, a zero value indicate the use of default
  //                quadrature rules based on the element types. If `-1` is
  //                passed in, then the code will assume user-provided
  //                quadrature rule information
  //    userquad:   This field is only accessed if qd=-1. If provided, then
  //    userquad
  //                must be a nqp-by-(1+dim) array, where the first column
  //                vector is is the quadrature weights while the rest are their
  //                corresponding quadrature points, defined in the reference
  //                element.
  //
  //  In particular, the user can pass in specific natural coordinates on which
  //  we will compute shape functions and derivatives. In this situation, we
  //  will skip the computation of Jacobian.
  //
  //    natcoords:  List of natural coordinates defined by the user
  //
  //  EXAMPLES
  //  --------
  //  The following initializes a linear triangular element
  //
  //    >> sfe = sfe_init(SfeObject(0), SFE_TRI_3, xs);
  //
  //  The following initializes a quadratic tetrahedral element but with linear
  //  geometry
  //
  //    >> etypes = [SFE_TET_10; SFE_TET_4];
  //    >> sfe = sfe_init(SfeObject(0), etypes, xs);
  //
  //  The following initializes a bi-linear quadrilateral element with
  //  user-provided gravity quadrature rule
  //
  //    >> gravrule = [1, 0.5, 0.5];
  //    >> sfe = sfe_init(SfeObject(0), SFE_QUAD_4, xs, int32(-1), gravrule);
  //
  //  See also SfeObject, ElementTypes, sfe_init_grad
  //  For clarity
  //  Determine solution and geometric spaces
  if (etypes[1] == 0) {
    geom_etype = etypes[0];
  } else {
    geom_etype = etypes[1];
  }
  flag = (etypes[0] == geom_etype);
  if (!flag) {
    //  then the shapes must match
    // obtain_elemshape - Decode an element geometric shape from etype
    //
    //    shapeid = obtain_elemshape(etype)
    //
    //  RETURN
    //  ------
    //    shapeid:    Integer type of different geometry shapes:
    //                    1 - BAR
    //                    2 - TRI
    //                    3 - QUAD
    //                    4 - TET
    //                    5 - PYRAMID
    //                    6 - PRISM
    //                    7 - HEX
    //
    //  See also obtain_elemdim
    //  shapeid = (etype>>5)&0b111
    // obtain_elemshape - Decode an element geometric shape from etype
    //
    //    shapeid = obtain_elemshape(etype)
    //
    //  RETURN
    //  ------
    //    shapeid:    Integer type of different geometry shapes:
    //                    1 - BAR
    //                    2 - TRI
    //                    3 - QUAD
    //                    4 - TET
    //                    5 - PYRAMID
    //                    6 - PRISM
    //                    7 - HEX
    //
    //  See also obtain_elemdim
    //  shapeid = (etype>>5)&0b111
    flag = ((etypes[0] >> 5 & 7) == (geom_etype >> 5 & 7));
  }
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(flag, "invalid element combinations");
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  //  Geometric dimension
  //  Topological dimension
  // obtain_elemdim - Obtain the dimension of an element
  //
  //    dim = obtain_elemdim(etype)
  //
  //  See also obtain_elemshape
  // obtain_elemshape - Decode an element geometric shape from etype
  //
  //    shapeid = obtain_elemshape(etype)
  //
  //  RETURN
  //  ------
  //    shapeid:    Integer type of different geometry shapes:
  //                    1 - BAR
  //                    2 - TRI
  //                    3 - QUAD
  //                    4 - TET
  //                    5 - PYRAMID
  //                    6 - PRISM
  //                    7 - HEX
  //
  //  See also obtain_elemdim
  //  shapeid = (etype>>5)&0b111
  shape = etypes[0] >> 5 & 7;
  topo_dim = ((shape > 0) + (shape > 1)) + (shape > 3);
  //  Geometric dimension
  if (xs.size(1) < topo_dim) {
    //  m2cError  Throw error and display message in MATLAB or C++
    //
    //     m2cError(format)
    //     m2cError(format,A1,...,An)
    //     m2cError(errID,___)
    //
    //  This function has the same interface as MATLAB's built-in `error`,
    //  except that the `format` must be a constant string during code
    //  generation.
    //
    //  Notes
    //  -----
    //  The format must be a constant string during code-generation time.
    //
    //  See also error, m2cWarning
    m2cErrMsgIdAndTxt("sfe_init:badDim",
                      "geometric dim cannot be smaller than topo dim");
  }
  b_sfe->geom_dim = xs.size(1);
  //  assign geom dimension
  b_sfe->topo_dim = topo_dim;
  //  assign topo dimension
  //  Make sure the coordinate size are the same
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(iv[geom_etype - 1] == xs.size(0), "nnodes do not match");
  b_sfe->etypes[0] = etypes[0];
  b_sfe->etypes[1] = geom_etype;
  //  Get number of nodes per element
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  b_sfe->nnodes[0] = iv[etypes[0] - 1];
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  b_sfe->nnodes[1] = iv[geom_etype - 1];
  //  User-input natural coordinates
  b_sfe->nqp = qd_or_natcoords.size(0);
  b_sfe->ws.set_size(qd_or_natcoords.size(0));
  loop_ub = qd_or_natcoords.size(0);
  for (i = 0; i < loop_ub; i++) {
    b_sfe->ws[i] = 1.0;
  }
  //  user ones for dummy quad weights
  b_sfe->cs.set_size(qd_or_natcoords.size(0), topo_dim);
  i = qd_or_natcoords.size(0);
  for (int32_T q{0}; q < i; q++) {
    for (int32_T k{0}; k < topo_dim; k++) {
      b_sfe->cs[k + b_sfe->cs.size(1) * q] =
          qd_or_natcoords[k + qd_or_natcoords.size(1) * q];
    }
  }
  //  Solution space shape functions & derivs
  tabulate_shapefuncs(etypes[0], b_sfe->cs, b_sfe->shapes_geom,
                      b_sfe->derivs_geom);
  loop_ub = b_sfe->shapes_geom.size(1) * b_sfe->shapes_geom.size(0);
  b_sfe->shapes_sol.set_size(b_sfe->shapes_geom.size(0),
                             b_sfe->shapes_geom.size(1));
  for (i = 0; i < loop_ub; i++) {
    b_sfe->shapes_sol[i] = b_sfe->shapes_geom[i];
  }
  loop_ub = b_sfe->derivs_geom.size(2) * b_sfe->derivs_geom.size(1) *
            b_sfe->derivs_geom.size(0);
  b_sfe->derivs_sol.set_size(b_sfe->derivs_geom.size(0),
                             b_sfe->derivs_geom.size(1),
                             b_sfe->derivs_geom.size(2));
  for (i = 0; i < loop_ub; i++) {
    b_sfe->derivs_sol[i] = b_sfe->derivs_geom[i];
  }
  //  Geometry space shape functions & derivs
  if (etypes[0] != geom_etype) {
    tabulate_shapefuncs(geom_etype, b_sfe->cs, b_sfe->shapes_geom,
                        b_sfe->derivs_geom);
  }
  //  potentially skip re-tabulating
  //  Compute phy. coordinates of qpoints
  b_sfe->cs_phy.set_size(qd_or_natcoords.size(0), xs.size(1));
  i = qd_or_natcoords.size(0);
  for (int32_T q{0}; q < i; q++) {
    //  NOTE The following can be optimized efficiently due to the the upper
    //  bound of dimension (i.e., size(xs,2)) is known.
    loop_ub = xs.size(1);
    for (int32_T k{0}; k < loop_ub; k++) {
      real_T v;
      int32_T m;
      // interpolate_shape - Interpolate f with q-th shape function in the table
      //
      //    v = interpolate_shape(shapes, q, f)
      //    v = interpolate_shape(shapes, q, f, k)
      m = b_sfe->shapes_geom.size(1);
      v = b_sfe->shapes_geom[b_sfe->shapes_geom.size(1) * q] * xs[k];
      for (int32_T b_i{2}; b_i <= m; b_i++) {
        v += b_sfe->shapes_geom[(b_i + b_sfe->shapes_geom.size(1) * q) - 1] *
             xs[k + xs.size(1) * (b_i - 1)];
      }
      b_sfe->cs_phy[k + b_sfe->cs_phy.size(1) * q] = v;
    }
  }
  //  Compute Jacobian
}

void sfe_init9(SfeObject *b_sfe, const ::coder::array<real_T, 2U> &xs, int32_T,
               const ::coder::array<real_T, 2U> &)
{
  real_T dv[9];
  real_T v;
  int32_T i;
  int32_T i1;
  boolean_T cond;
  // sfe_init - Initialize/reinitialize an sfe object for non-boundary element
  //
  //    sfe = sfe_init(sfe, etypes, xs)
  //    sfe = sfe_init(sfe, etypes, xs, natcoords)
  //    sfe = sfe_init(sfe, etypes, xs, qd)
  //    sfe = sfe_init(sfe, etypes, xs, qd, userquad)
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An SfeObject instance
  //    etypes:     Element type(s), which can be a 2-vector, scalar, or [].
  //                A 2-vector specifies the solution and geometric element
  //                types, and it supports iso-, sub- and super-parametric
  //                elements. If two element types are equal, then one can use a
  //                scalar. An empty array ([]) instructs the function to reuse
  //                the element type and the tabulation stored in the `sfe`
  //                object (typically from a previous call).
  //    xs:         Physical coordinates of the element, which is defined in
  //                the geometric space
  //    qd:         Quadrature degree, a zero value indicate the use of default
  //                quadrature rules based on the element types. If `-1` is
  //                passed in, then the code will assume user-provided
  //                quadrature rule information
  //    userquad:   This field is only accessed if qd=-1. If provided, then
  //    userquad
  //                must be a nqp-by-(1+dim) array, where the first column
  //                vector is is the quadrature weights while the rest are their
  //                corresponding quadrature points, defined in the reference
  //                element.
  //
  //  In particular, the user can pass in specific natural coordinates on which
  //  we will compute shape functions and derivatives. In this situation, we
  //  will skip the computation of Jacobian.
  //
  //    natcoords:  List of natural coordinates defined by the user
  //
  //  EXAMPLES
  //  --------
  //  The following initializes a linear triangular element
  //
  //    >> sfe = sfe_init(SfeObject(0), SFE_TRI_3, xs);
  //
  //  The following initializes a quadratic tetrahedral element but with linear
  //  geometry
  //
  //    >> etypes = [SFE_TET_10; SFE_TET_4];
  //    >> sfe = sfe_init(SfeObject(0), etypes, xs);
  //
  //  The following initializes a bi-linear quadrilateral element with
  //  user-provided gravity quadrature rule
  //
  //    >> gravrule = [1, 0.5, 0.5];
  //    >> sfe = sfe_init(SfeObject(0), SFE_QUAD_4, xs, int32(-1), gravrule);
  //
  //  See also SfeObject, ElementTypes, sfe_init_grad
  //  For clarity
  if ((b_sfe->etypes[0] > 0) && (iv[b_sfe->etypes[0] - 1] != 0)) {
    // obtain_elemnnodes - Obtain number of nodes per element given etype
    //
    //     nnodes = obtain_elemnnodes(etype)
    //
    //  This file was generated from update_nnodes_table
    //         % SFE_NODE_1
    //         % SFE_BAR_GL_2
    //         % SFE_BAR_GL_3
    //         % SFE_BAR_4
    //         % SFE_BAR_GL_4
    //         % SFE_BAR_5
    //         % SFE_BAR_GL_5
    //         % SFE_BAR_6
    //         % SFE_BAR_GL_6
    //         % SFE_BAR_7
    //         % SFE_BAR_GL_7
    //         % SFE_TRI_GL_3
    //         % SFE_TRI_GL_6
    //         % SFE_TRI_10
    //         % SFE_TRI_GL_10
    //         % SFE_TRI_15
    //         % SFE_TRI_GL_15
    //         % SFE_TRI_FEK_15
    //         % SFE_TRI_21
    //         % SFE_TRI_GL_21
    //         % SFE_TRI_FEK_21
    //         % SFE_TRI_28
    //         % SFE_TRI_GL_28
    //         % SFE_TRI_FEK_28
    //         % SFE_QUAD_GL_4
    //         % SFE_QUAD_GL_9
    //         % SFE_QUAD_16
    //         % SFE_QUAD_GL_16
    //         % SFE_QUAD_25
    //         % SFE_QUAD_GL_25
    //         % SFE_QUAD_36
    //         % SFE_QUAD_GL_36
    //         % SFE_QUAD_49
    //         % SFE_QUAD_GL_49
    //         % SFE_TET_GL_4
    //         % SFE_TET_GL_10
    //         % SFE_TET_20
    //         % SFE_TET_GL_20
    //         % SFE_TET_35
    //         % SFE_TET_GL_35
    //         % SFE_TET_FEK_35
    //         % SFE_TET_56
    //         % SFE_TET_GL_56
    //         % SFE_TET_FEK_56
    //         % SFE_TET_84
    //         % SFE_TET_GL_84
    //         % SFE_TET_FEK_84
    //         % SFE_PYRA_GL_5
    //         % SFE_PYRA_GL_14
    //         % SFE_PYRA_30
    //         % SFE_PYRA_GL_30
    //         % SFE_PYRA_55
    //         % SFE_PYRA_GL_55
    //         % SFE_PYRA_FEK_55
    //         % SFE_PYRA_91
    //         % SFE_PRISM_GL_6
    //         % SFE_PRISM_GL_18
    //         % SFE_PRISM_40
    //         % SFE_PRISM_GL_40
    //         % SFE_PRISM_75
    //         % SFE_PRISM_GL_75
    //         % SFE_PRISM_FEK_75
    //         % SFE_PRISM_126
    //         % SFE_PRISM_GL_126
    //         % SFE_PRISM_196
    //         % SFE_HEXA_GL_8
    //         % SFE_HEXA_GL_27
    //         % SFE_HEXA_64
    //         % SFE_HEXA_GL_64
    //         % SFE_HEXA_125
    //         % SFE_HEXA_GL_125
    //         % SFE_HEXA_216
    //         % SFE_HEXA_GL_216
    //         % SFE_HEXA_343
    //         % SFE_HEXA_GL_343
    cond = true;
  } else {
    cond = false;
  }
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(cond, "");
  //  potentially skip re-tabulating
  //  Compute phy. coordinates of qpoints
  b_sfe->cs_phy.set_size(b_sfe->nqp, xs.size(1));
  i = b_sfe->nqp;
  for (int32_T q{0}; q < i; q++) {
    //  NOTE The following can be optimized efficiently due to the the upper
    //  bound of dimension (i.e., size(xs,2)) is known.
    i1 = xs.size(1);
    for (int32_T k{0}; k < i1; k++) {
      int32_T m;
      // interpolate_shape - Interpolate f with q-th shape function in the table
      //
      //    v = interpolate_shape(shapes, q, f)
      //    v = interpolate_shape(shapes, q, f, k)
      m = b_sfe->shapes_geom.size(1);
      v = b_sfe->shapes_geom[b_sfe->shapes_geom.size(1) * q] * xs[k];
      for (int32_T b_i{2}; b_i <= m; b_i++) {
        v += b_sfe->shapes_geom[(b_i + b_sfe->shapes_geom.size(1) * q) - 1] *
             xs[k + xs.size(1) * (b_i - 1)];
      }
      b_sfe->cs_phy[k + b_sfe->cs_phy.size(1) * q] = v;
    }
  }
  //  Compute Jacobian
  b_sfe->wdetJ.set_size(b_sfe->nqp);
  if ((b_sfe->etypes[1] == 68) || (b_sfe->etypes[1] == 132) ||
      (b_sfe->etypes[1] == 36)) {
    real_T d;
    int32_T geom_dim;
    int32_T n;
    int32_T topo_dim;
    //  A single Jacobian matrix (transpose) is needed for simplex elements
    // compute_jact - Compute Jacobian^T and its determinant from q-th deriv in
    // table
    //
    //    [Jt, d] = compute_jactt(xs, derivs, q)
    //
    //  NOTES
    //  -----
    //  Jt is always shape of 3x3. But only topo_dim-by-geom_dim will be
    //  accessed for computing Jacobian matrix. Note that for 3D surfaces, the
    //  normal direction corresponding to q-th qpiont will be saved to the last
    //  row of J.
    //
    //  In particular, the orientation for the transpose of Jacobian matrix is
    //
    //             [dx/dxi    dy/dxi    dz/dxi  ]
    //        Jt = [dx/deta   dy/deta   dz/deta ]
    //             [dx/dzeta  dy/dzeta  dz/dzeta]
    //
    //  Hence, for surface and curve, Jt has shapes (d-1)xd and 1x3, resp
    //
    //  See also solve_sq
    geom_dim = xs.size(1);
    topo_dim = b_sfe->derivs_geom.size(2);
    std::memset(&dv[0], 0, 9U * sizeof(real_T));
    n = xs.size(0);
    for (int32_T k{0}; k < n; k++) {
      for (int32_T b_i{0}; b_i < topo_dim; b_i++) {
        for (int32_T j{0}; j < geom_dim; j++) {
          i = j + 3 * b_i;
          dv[i] += xs[j + xs.size(1) * k] *
                   b_sfe->derivs_geom[b_i + b_sfe->derivs_geom.size(2) * k];
        }
      }
    }
    if (xs.size(1) == b_sfe->derivs_geom.size(2)) {
      if (xs.size(1) == 1) {
        d = dv[0];
      } else if (xs.size(1) == 2) {
        // det2 - Compute determinant of 2x2 matrix.
        d = dv[0] * dv[4] - dv[1] * dv[3];
      } else {
        // det3 - Compute determinant of 3x3 matrix.
        d = (dv[2] * (dv[3] * dv[7] - dv[4] * dv[6]) +
             dv[5] * (dv[1] * dv[6] - dv[0] * dv[7])) +
            dv[8] * (dv[0] * dv[4] - dv[1] * dv[3]);
      }
    } else if (b_sfe->derivs_geom.size(2) == 1) {
      d = dv[0] * dv[0] + dv[1] * dv[1];
      if (xs.size(1) == 3) {
        d += dv[2] * dv[2];
      }
      d = std::sqrt(d);
    } else {
      //  must be 2x3
      // cross_lastcol - Compute cross(J(1,:),J(2,:)) and store to J(3,:)
      dv[6] = dv[1] * dv[5] - dv[2] * dv[4];
      dv[7] = dv[2] * dv[3] - dv[0] * dv[5];
      dv[8] = dv[0] * dv[4] - dv[1] * dv[3];
      d = std::sqrt((dv[6] * dv[6] + dv[7] * dv[7]) + dv[8] * dv[8]);
    }
    b_sfe->jacTs.set_size(3, 3);
    for (i = 0; i < 9; i++) {
      b_sfe->jacTs[i] = dv[i];
    }
    i = b_sfe->nqp;
    for (int32_T q{0}; q < i; q++) {
      b_sfe->wdetJ[q] = d * b_sfe->ws[q];
    }
  } else {
    int32_T sfe_idx_0;
    //  Super-parametric
    sfe_idx_0 = b_sfe->nqp * 3;
    b_sfe->jacTs.set_size(sfe_idx_0, 3);
    i = b_sfe->nqp;
    for (int32_T q{0}; q < i; q++) {
      int32_T geom_dim;
      int32_T n;
      int32_T topo_dim;
      int32_T y;
      y = q * 3;
      // compute_jact - Compute Jacobian^T and its determinant from q-th deriv
      // in table
      //
      //    [Jt, d] = compute_jactt(xs, derivs, q)
      //
      //  NOTES
      //  -----
      //  Jt is always shape of 3x3. But only topo_dim-by-geom_dim will be
      //  accessed for computing Jacobian matrix. Note that for 3D surfaces, the
      //  normal direction corresponding to q-th qpiont will be saved to the
      //  last row of J.
      //
      //  In particular, the orientation for the transpose of Jacobian matrix is
      //
      //             [dx/dxi    dy/dxi    dz/dxi  ]
      //        Jt = [dx/deta   dy/deta   dz/deta ]
      //             [dx/dzeta  dy/dzeta  dz/dzeta]
      //
      //  Hence, for surface and curve, Jt has shapes (d-1)xd and 1x3, resp
      //
      //  See also solve_sq
      geom_dim = xs.size(1);
      topo_dim = b_sfe->derivs_geom.size(2);
      std::memset(&dv[0], 0, 9U * sizeof(real_T));
      n = xs.size(0);
      for (int32_T k{0}; k < n; k++) {
        for (int32_T b_i{0}; b_i < topo_dim; b_i++) {
          for (int32_T j{0}; j < geom_dim; j++) {
            i1 = j + 3 * b_i;
            dv[i1] +=
                xs[j + xs.size(1) * k] *
                b_sfe->derivs_geom[(b_i + b_sfe->derivs_geom.size(2) * k) +
                                   b_sfe->derivs_geom.size(2) *
                                       b_sfe->derivs_geom.size(1) * q];
          }
        }
      }
      if (xs.size(1) == b_sfe->derivs_geom.size(2)) {
        if (xs.size(1) == 1) {
          v = dv[0];
        } else if (xs.size(1) == 2) {
          // det2 - Compute determinant of 2x2 matrix.
          v = dv[0] * dv[4] - dv[1] * dv[3];
        } else {
          // det3 - Compute determinant of 3x3 matrix.
          v = (dv[2] * (dv[3] * dv[7] - dv[4] * dv[6]) +
               dv[5] * (dv[1] * dv[6] - dv[0] * dv[7])) +
              dv[8] * (dv[0] * dv[4] - dv[1] * dv[3]);
        }
      } else if (b_sfe->derivs_geom.size(2) == 1) {
        v = dv[0] * dv[0] + dv[1] * dv[1];
        if (xs.size(1) == 3) {
          v += dv[2] * dv[2];
        }
        v = std::sqrt(v);
      } else {
        //  must be 2x3
        // cross_lastcol - Compute cross(J(1,:),J(2,:)) and store to J(3,:)
        dv[6] = dv[1] * dv[5] - dv[2] * dv[4];
        dv[7] = dv[2] * dv[3] - dv[0] * dv[5];
        dv[8] = dv[0] * dv[4] - dv[1] * dv[3];
        v = std::sqrt((dv[6] * dv[6] + dv[7] * dv[7]) + dv[8] * dv[8]);
      }
      for (i1 = 0; i1 < 3; i1++) {
        sfe_idx_0 = i1 + y;
        b_sfe->jacTs[3 * sfe_idx_0] = dv[3 * i1];
        b_sfe->jacTs[3 * sfe_idx_0 + 1] = dv[3 * i1 + 1];
        b_sfe->jacTs[3 * sfe_idx_0 + 2] = dv[3 * i1 + 2];
      }
      b_sfe->wdetJ[q] = v;
      b_sfe->wdetJ[q] = b_sfe->wdetJ[q] * b_sfe->ws[q];
    }
  }
}

void sfe_init_grad1(SfeObject *b_sfe, int32_T q)
{
  real_T Jt[9];
  int32_T dim;
  int32_T n;
  // sfe_grad - Compute gradients of shape functions in physical space
  //
  //    sfe = sfe_init_grad(sfe, q)
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An SfeObject instance
  //    q:          Quadrature point index
  //
  //  See also SfeObject, sfe_init, sfe_elem_stiff
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(b_sfe->geom_dim == b_sfe->topo_dim, "not implemented");
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(q <= b_sfe->nqp, "out of bound of qpoint range");
  if (b_sfe->jacTs.size(0) == 3) {
    for (int32_T i{0}; i < 3; i++) {
      Jt[3 * i] = b_sfe->jacTs[3 * i];
      Jt[3 * i + 1] = b_sfe->jacTs[3 * i + 1];
      Jt[3 * i + 2] = b_sfe->jacTs[3 * i + 2];
    }
  } else {
    int32_T y;
    y = (q - 1) * 3;
    for (int32_T i{0}; i < 3; i++) {
      int32_T Jt_tmp;
      Jt_tmp = i + y;
      Jt[3 * i] = b_sfe->jacTs[3 * Jt_tmp];
      Jt[3 * i + 1] = b_sfe->jacTs[3 * Jt_tmp + 1];
      Jt[3 * i + 2] = b_sfe->jacTs[3 * Jt_tmp + 2];
    }
  }
  dim = b_sfe->derivs_sol.size(2);
  n = b_sfe->derivs_sol.size(1);
  b_sfe->grads_sol.set_size(b_sfe->derivs_sol.size(1),
                            b_sfe->derivs_sol.size(2));
  for (int32_T b_i{0}; b_i < n; b_i++) {
    for (int32_T d{0}; d < dim; d++) {
      b_sfe->grads_sol[d + b_sfe->grads_sol.size(1) * b_i] =
          b_sfe->derivs_sol[(d + b_sfe->derivs_sol.size(2) * b_i) +
                            b_sfe->derivs_sol.size(2) *
                                b_sfe->derivs_sol.size(1) * (q - 1)];
    }
  }
  if (b_sfe->geom_dim == b_sfe->topo_dim) {
    boolean_T info;
    info = solve_sq(Jt, b_sfe->geom_dim, b_sfe->grads_sol);
    //  m2cAssert  Throw error if condition false at runtime
    //
    //    m2cAssert(cond)
    //    m2cAssert(cond,msg)
    //    m2cAssert(cond,msg,A1,...,An)
    //    m2cAssert(cond,errID,msg)
    //    m2cAssert(cond,errID,msg,A1,...,An)
    //
    //  The interface of `m2cAssert` is compatible with MATLAB's built-in
    //  `assert`,  but it generates runtime assertion instead of compile-time
    //  assertion.
    //
    //  Note
    //  ----
    //  The MATLAB built-in `assert` is mostly used for compile-time error
    //  checking, and it has no effect for runtime error checking in LIB mode.
    //  Use `m2cAssert` instead for runtime error checking. Like the built-in
    //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
    //  into a code-generation-time character string. If you want to use both
    //  code-generation-time and runtime assertions, it is recommended to put
    //  `m2cAssert` before the built-in `assert`.
    //
    //  See also assert, m2cError, m2cWarning
    m2cAssert(!info, "singular Jacobian");
  }
}

void sfe_init_linear1(SfeObject *b_sfe, int32_T etypes,
                      const ::coder::array<real_T, 2U> &xs)
{
  real_T dv[9];
  real_T v;
  int32_T i;
  int32_T i1;
  int32_T loop_ub;
  int32_T shape;
  int32_T topo_dim;
  // sfe_init_linear - Initialize/reinitialize an sfe object for non-boundary
  // linear element
  //
  //    sfe = sfe_init_linear(sfe, etypes, xs)
  //
  //  PARAMETERS
  //  ----------
  //    sfe:        An SfeObject instance
  //    etypes:     Element type(s), which must be a scalar.
  //    xs:         Physical coordinates of the element, which is defined in
  //                the geometric space
  //  EXAMPLES
  //  --------
  //  The following initializes a linear triangular element
  //
  //    >> sfe = sfe_init_linear(SfeObject(0), SFE_TRI_3, xs);
  //
  //  The following initializes a quadratic tetrahedral element but with linear
  //  geometry
  //
  //    >> etypes = [SFE_TET_10; SFE_TET_4];
  //    >> sfe = sfe_init_linear(SfeObject(0), etypes, xs);
  //
  //  See also SfeObject, sfe_init, ElementTypes, sfe_init_grad
  //  For clarity
  //  Determine solution and geometric spaces
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(true, "invalid element combinations");
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  //  Geometric dimension
  //  Topological dimension
  // obtain_elemdim - Obtain the dimension of an element
  //
  //    dim = obtain_elemdim(etype)
  //
  //  See also obtain_elemshape
  // obtain_elemshape - Decode an element geometric shape from etype
  //
  //    shapeid = obtain_elemshape(etype)
  //
  //  RETURN
  //  ------
  //    shapeid:    Integer type of different geometry shapes:
  //                    1 - BAR
  //                    2 - TRI
  //                    3 - QUAD
  //                    4 - TET
  //                    5 - PYRAMID
  //                    6 - PRISM
  //                    7 - HEX
  //
  //  See also obtain_elemdim
  //  shapeid = (etype>>5)&0b111
  shape = etypes >> 5;
  topo_dim = ((shape > 0) + (shape > 1)) + (shape > 3);
  //  Geometric dimension
  if (xs.size(1) < topo_dim) {
    //  m2cError  Throw error and display message in MATLAB or C++
    //
    //     m2cError(format)
    //     m2cError(format,A1,...,An)
    //     m2cError(errID,___)
    //
    //  This function has the same interface as MATLAB's built-in `error`,
    //  except that the `format` must be a constant string during code
    //  generation.
    //
    //  Notes
    //  -----
    //  The format must be a constant string during code-generation time.
    //
    //  See also error, m2cWarning
    m2cErrMsgIdAndTxt("sfe_init_linear:badDim",
                      "geometric dim cannot be smaller than topo dim");
  }
  b_sfe->geom_dim = xs.size(1);
  //  assign geom dimension
  b_sfe->topo_dim = topo_dim;
  //  assign topo dimension
  //  Make sure the coordinate size are the same
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  //  m2cAssert  Throw error if condition false at runtime
  //
  //    m2cAssert(cond)
  //    m2cAssert(cond,msg)
  //    m2cAssert(cond,msg,A1,...,An)
  //    m2cAssert(cond,errID,msg)
  //    m2cAssert(cond,errID,msg,A1,...,An)
  //
  //  The interface of `m2cAssert` is compatible with MATLAB's built-in
  //  `assert`,  but it generates runtime assertion instead of compile-time
  //  assertion.
  //
  //  Note
  //  ----
  //  The MATLAB built-in `assert` is mostly used for compile-time error
  //  checking, and it has no effect for runtime error checking in LIB mode.
  //  Use `m2cAssert` instead for runtime error checking. Like the built-in
  //  `assert`, the combination of `sprintf(msg,A1,...,An)` must translate
  //  into a code-generation-time character string. If you want to use both
  //  code-generation-time and runtime assertions, it is recommended to put
  //  `m2cAssert` before the built-in `assert`.
  //
  //  See also assert, m2cError, m2cWarning
  m2cAssert(iv[etypes - 1] == xs.size(0), "nnodes do not match");
  b_sfe->etypes[0] = etypes;
  b_sfe->etypes[1] = etypes;
  //  Get number of nodes per element
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  i = iv[etypes - 1];
  b_sfe->nnodes[0] = i;
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  b_sfe->nnodes[1] = i;
  tabulate_quadratures_deg_1(etypes, b_sfe->cs, b_sfe->ws);
  b_sfe->nqp = b_sfe->ws.size(0);
  //  Solution space shape functions & derivs
  tabulate_shapefuncs_deg_1(etypes, b_sfe->cs, b_sfe->shapes_sol,
                            b_sfe->derivs_sol);
  loop_ub = b_sfe->shapes_sol.size(1) * b_sfe->shapes_sol.size(0);
  b_sfe->shapes_geom.set_size(b_sfe->shapes_sol.size(0),
                              b_sfe->shapes_sol.size(1));
  for (i = 0; i < loop_ub; i++) {
    b_sfe->shapes_geom[i] = b_sfe->shapes_sol[i];
  }
  loop_ub = b_sfe->derivs_sol.size(2) * b_sfe->derivs_sol.size(1) *
            b_sfe->derivs_sol.size(0);
  b_sfe->derivs_geom.set_size(b_sfe->derivs_sol.size(0),
                              b_sfe->derivs_sol.size(1),
                              b_sfe->derivs_sol.size(2));
  for (i = 0; i < loop_ub; i++) {
    b_sfe->derivs_geom[i] = b_sfe->derivs_sol[i];
  }
  //  potentially skip re-tabulating
  //  Compute phy. coordinates of qpoints
  b_sfe->cs_phy.set_size(b_sfe->nqp, xs.size(1));
  i = b_sfe->nqp;
  for (int32_T q{0}; q < i; q++) {
    //  NOTE The following can be optimized efficiently due to the the upper
    //  bound of dimension (i.e., size(xs,2)) is known.
    i1 = xs.size(1);
    for (int32_T k{0}; k < i1; k++) {
      int32_T m;
      // interpolate_shape - Interpolate f with q-th shape function in the table
      //
      //    v = interpolate_shape(shapes, q, f)
      //    v = interpolate_shape(shapes, q, f, k)
      m = b_sfe->shapes_sol.size(1);
      v = b_sfe->shapes_sol[b_sfe->shapes_sol.size(1) * q] * xs[k];
      for (int32_T b_i{2}; b_i <= m; b_i++) {
        v += b_sfe->shapes_sol[(b_i + b_sfe->shapes_sol.size(1) * q) - 1] *
             xs[k + xs.size(1) * (b_i - 1)];
      }
      b_sfe->cs_phy[k + b_sfe->cs_phy.size(1) * q] = v;
    }
  }
  //  Compute Jacobian
  b_sfe->wdetJ.set_size(b_sfe->nqp);
  if ((etypes == 68) || (etypes == 132) || (etypes == 36)) {
    real_T d;
    int32_T geom_dim;
    int32_T n;
    //  A single Jacobian matrix (transpose) is needed for simplex elements
    // compute_jact - Compute Jacobian^T and its determinant from q-th deriv in
    // table
    //
    //    [Jt, d] = compute_jactt(xs, derivs, q)
    //
    //  NOTES
    //  -----
    //  Jt is always shape of 3x3. But only topo_dim-by-geom_dim will be
    //  accessed for computing Jacobian matrix. Note that for 3D surfaces, the
    //  normal direction corresponding to q-th qpiont will be saved to the last
    //  row of J.
    //
    //  In particular, the orientation for the transpose of Jacobian matrix is
    //
    //             [dx/dxi    dy/dxi    dz/dxi  ]
    //        Jt = [dx/deta   dy/deta   dz/deta ]
    //             [dx/dzeta  dy/dzeta  dz/dzeta]
    //
    //  Hence, for surface and curve, Jt has shapes (d-1)xd and 1x3, resp
    //
    //  See also solve_sq
    geom_dim = xs.size(1);
    topo_dim = b_sfe->derivs_sol.size(2);
    std::memset(&dv[0], 0, 9U * sizeof(real_T));
    n = xs.size(0);
    for (int32_T k{0}; k < n; k++) {
      for (int32_T b_i{0}; b_i < topo_dim; b_i++) {
        for (int32_T j{0}; j < geom_dim; j++) {
          i = j + 3 * b_i;
          dv[i] += xs[j + xs.size(1) * k] *
                   b_sfe->derivs_sol[b_i + b_sfe->derivs_sol.size(2) * k];
        }
      }
    }
    if (xs.size(1) == b_sfe->derivs_sol.size(2)) {
      if (xs.size(1) == 1) {
        d = dv[0];
      } else if (xs.size(1) == 2) {
        // det2 - Compute determinant of 2x2 matrix.
        d = dv[0] * dv[4] - dv[1] * dv[3];
      } else {
        // det3 - Compute determinant of 3x3 matrix.
        d = (dv[2] * (dv[3] * dv[7] - dv[4] * dv[6]) +
             dv[5] * (dv[1] * dv[6] - dv[0] * dv[7])) +
            dv[8] * (dv[0] * dv[4] - dv[1] * dv[3]);
      }
    } else if (b_sfe->derivs_sol.size(2) == 1) {
      d = dv[0] * dv[0] + dv[1] * dv[1];
      if (xs.size(1) == 3) {
        d += dv[2] * dv[2];
      }
      d = std::sqrt(d);
    } else {
      //  must be 2x3
      // cross_lastcol - Compute cross(J(1,:),J(2,:)) and store to J(3,:)
      dv[6] = dv[1] * dv[5] - dv[2] * dv[4];
      dv[7] = dv[2] * dv[3] - dv[0] * dv[5];
      dv[8] = dv[0] * dv[4] - dv[1] * dv[3];
      d = std::sqrt((dv[6] * dv[6] + dv[7] * dv[7]) + dv[8] * dv[8]);
    }
    b_sfe->jacTs.set_size(3, 3);
    for (i = 0; i < 9; i++) {
      b_sfe->jacTs[i] = dv[i];
    }
    i = b_sfe->nqp;
    for (int32_T q{0}; q < i; q++) {
      b_sfe->wdetJ[q] = d * b_sfe->ws[q];
    }
  } else {
    //  Super-parametric
    loop_ub = b_sfe->nqp * 3;
    b_sfe->jacTs.set_size(loop_ub, 3);
    i = b_sfe->nqp;
    for (int32_T q{0}; q < i; q++) {
      int32_T geom_dim;
      int32_T n;
      int32_T y;
      y = q * 3;
      // compute_jact - Compute Jacobian^T and its determinant from q-th deriv
      // in table
      //
      //    [Jt, d] = compute_jactt(xs, derivs, q)
      //
      //  NOTES
      //  -----
      //  Jt is always shape of 3x3. But only topo_dim-by-geom_dim will be
      //  accessed for computing Jacobian matrix. Note that for 3D surfaces, the
      //  normal direction corresponding to q-th qpiont will be saved to the
      //  last row of J.
      //
      //  In particular, the orientation for the transpose of Jacobian matrix is
      //
      //             [dx/dxi    dy/dxi    dz/dxi  ]
      //        Jt = [dx/deta   dy/deta   dz/deta ]
      //             [dx/dzeta  dy/dzeta  dz/dzeta]
      //
      //  Hence, for surface and curve, Jt has shapes (d-1)xd and 1x3, resp
      //
      //  See also solve_sq
      geom_dim = xs.size(1);
      topo_dim = b_sfe->derivs_sol.size(2);
      std::memset(&dv[0], 0, 9U * sizeof(real_T));
      n = xs.size(0);
      for (int32_T k{0}; k < n; k++) {
        for (int32_T b_i{0}; b_i < topo_dim; b_i++) {
          for (int32_T j{0}; j < geom_dim; j++) {
            i1 = j + 3 * b_i;
            dv[i1] += xs[j + xs.size(1) * k] *
                      b_sfe->derivs_sol[(b_i + b_sfe->derivs_sol.size(2) * k) +
                                        b_sfe->derivs_sol.size(2) *
                                            b_sfe->derivs_sol.size(1) * q];
          }
        }
      }
      if (xs.size(1) == b_sfe->derivs_sol.size(2)) {
        if (xs.size(1) == 1) {
          v = dv[0];
        } else if (xs.size(1) == 2) {
          // det2 - Compute determinant of 2x2 matrix.
          v = dv[0] * dv[4] - dv[1] * dv[3];
        } else {
          // det3 - Compute determinant of 3x3 matrix.
          v = (dv[2] * (dv[3] * dv[7] - dv[4] * dv[6]) +
               dv[5] * (dv[1] * dv[6] - dv[0] * dv[7])) +
              dv[8] * (dv[0] * dv[4] - dv[1] * dv[3]);
        }
      } else if (b_sfe->derivs_sol.size(2) == 1) {
        v = dv[0] * dv[0] + dv[1] * dv[1];
        if (xs.size(1) == 3) {
          v += dv[2] * dv[2];
        }
        v = std::sqrt(v);
      } else {
        //  must be 2x3
        // cross_lastcol - Compute cross(J(1,:),J(2,:)) and store to J(3,:)
        dv[6] = dv[1] * dv[5] - dv[2] * dv[4];
        dv[7] = dv[2] * dv[3] - dv[0] * dv[5];
        dv[8] = dv[0] * dv[4] - dv[1] * dv[3];
        v = std::sqrt((dv[6] * dv[6] + dv[7] * dv[7]) + dv[8] * dv[8]);
      }
      for (i1 = 0; i1 < 3; i1++) {
        loop_ub = i1 + y;
        b_sfe->jacTs[3 * loop_ub] = dv[3 * i1];
        b_sfe->jacTs[3 * loop_ub + 1] = dv[3 * i1 + 1];
        b_sfe->jacTs[3 * loop_ub + 2] = dv[3 * i1 + 2];
      }
      b_sfe->wdetJ[q] = v;
      b_sfe->wdetJ[q] = b_sfe->wdetJ[q] * b_sfe->ws[q];
    }
  }
}

void sfe_internal_initialize()
{
  omp_init_nest_lock(&sfe_bnd_init1_nestLockGlobal);
}

void sfe_internal_terminate()
{
  omp_destroy_nest_lock(&sfe_bnd_init1_nestLockGlobal);
}

void sfe_raisebyfacet1(::coder::array<real_T, 2U> &xsloc, int32_T etype,
                       int32_T etype_new,
                       const ::coder::array<uint8_T, 1U> &facet,
                       const ::coder::array<real_T, 2U> &bndxsloc,
                       const ::coder::array<int32_T, 1U> &ftype_bnd)
{
  ::coder::array<real_T, 2U> natcoords_;
  ::coder::array<real_T, 2U> natcoords_facet_;
  ::coder::array<int16_T, 1U> npe_lin_;
  ::coder::array<uint8_T, 1U> ftype_lin_;
  SfeObject b_sfe;
  SfeObject sfe_facet;
  real_T bndxsloc__data[1029];
  int32_T bndxsloc__size[2];
  int32_T degree;
  int32_T degree_hi;
  int32_T etype_hi;
  int32_T etype_low;
  int32_T i;
  int32_T lids_size;
  int32_T loop_ub;
  int32_T ndims;
  int32_T nfaces;
  int32_T npe;
  int16_T lids_data[50];
  uint8_T ftype;
  // sfe_raisebyfacet - Raise the coordinates of an element to one of higher
  // order
  //
  //    [xsloc,bndxsloc] =
  //    sfe_raisebyfacet(xsloc,etype,etype_new,facet,bndxsloc,ftype_bnd)
  //
  //  PARAMETERS
  //  ----------
  //    xsloc:  nodal positions for element
  //    etype:  current element type
  //    etype_new: raised element type
  //    facet:  facet on the boundary
  //    bndxsloc: nodal positions for high order boundary facet
  //    ftype_bnd: element type for boundary
  //
  //  RETURNS
  //  -------
  //    xsloc:       New nodal positions
  //    bndxsloc:    passed by reference
  //  determining element information
  ndims = xsloc.size(1);
  nfaces = facet.size(0) - 1;
  // obtain_elemdegree - Decode the element degree from etype
  //
  //    deg = obtain_elemdegree(etype)
  //
  //  See also obtain_elemnnodes
  //  deg = (etype>>2)&0b111;
  degree = etype >> 2 & 7;
  // obtain_elemshape - Decode an element geometric shape from etype
  //
  //    shapeid = obtain_elemshape(etype)
  //
  //  RETURN
  //  ------
  //    shapeid:    Integer type of different geometry shapes:
  //                    1 - BAR
  //                    2 - TRI
  //                    3 - QUAD
  //                    4 - TET
  //                    5 - PYRAMID
  //                    6 - PRISM
  //                    7 - HEX
  //
  //  See also obtain_elemdim
  //  shapeid = (etype>>5)&0b111
  // obtain_elemnodepos - Decode nodal position types, e.g., equidistance, GL
  //
  //    postype = obtain_elemnodepos(etype)
  //
  //  RETURNS
  //  -------
  //    postype:    Position type tag:
  //                    0: equidistance
  //                    1: GL
  //                    2: ...
  //
  //  See also obtain_elemdegree
  //  postype = etype&0b11
  ftype_lin_.set_size(facet.size(0));
  for (int32_T f{0}; f <= nfaces; f++) {
    // obtain_elemshape - Decode an element geometric shape from etype
    //
    //    shapeid = obtain_elemshape(etype)
    //
    //  RETURN
    //  ------
    //    shapeid:    Integer type of different geometry shapes:
    //                    1 - BAR
    //                    2 - TRI
    //                    3 - QUAD
    //                    4 - TET
    //                    5 - PYRAMID
    //                    6 - PRISM
    //                    7 - HEX
    //
    //  See also obtain_elemdim
    //  shapeid = (etype>>5)&0b111
    // encode_elemtype - Encode an element type from shape, degree, nodal
    // position
    //
    //    etype = encode_elemtype(shape, degree, depos)
    //
    ftype_lin_[f] = static_cast<uint8_T>(((ftype_bnd[f] >> 5 & 7) << 5) + 4);
  }
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  npe_lin_.set_size(ftype_lin_.size(0));
  loop_ub = ftype_lin_.size(0);
  for (i = 0; i < loop_ub; i++) {
    npe_lin_[i] = iv[ftype_lin_[i] - 1];
  }
  // obtain_elemdegree - Decode the element degree from etype
  //
  //    deg = obtain_elemdegree(etype)
  //
  //  See also obtain_elemnnodes
  //  deg = (etype>>2)&0b111;
  degree_hi = ftype_bnd[0] >> 2 & 7;
  // SfeObject - The core object in sfelib
  //
  //    sfe = SfeObject  * returns a MATLAB Coder declaration of the C struct
  //    sfe = SfeObject(etype)
  //
  //  PARAMETERS
  //  ----------
  //    etype:          Element type ID. For construction of SfeObject, the
  //                    uniform element type is assigned for simplicity. Note
  //                    that they can be changed in sfe_init
  //
  //  RETURN
  //  ------
  //    sfe:            The core object in sfelib, which contains buffer spaces
  //                    for computing SFE
  //
  //  NOTES
  //  -----
  //  Regarding internal memory management, the layout is optimized for
  //  row-major, assuming the code will be converted in C++ in row-major.
  //  In addition, this object unifies iso-, super-, and sub-parametric elements
  //  in later assembly processes.
  //
  //  See also sfe_init, sfe_init_grad
  //  assertions need to be performed here
  b_sfe.etypes[0] = etype;
  b_sfe.etypes[1] = etype;
  b_sfe.nnodes[0] = 0;
  b_sfe.nnodes[1] = 0;
  b_sfe.geom_dim = 0;
  b_sfe.topo_dim = 0;
  b_sfe.facetid = 0;
  b_sfe.nqp = 0;
  b_sfe.ws.set_size(0);
  b_sfe.cs.set_size(0, 0);
  b_sfe.shapes_sol.set_size(0, 0);
  b_sfe.shapes_geom.set_size(0, 0);
  b_sfe.derivs_sol.set_size(0, 0, 0);
  b_sfe.derivs_geom.set_size(0, 0, 0);
  b_sfe.cs_phy.set_size(0, 0);
  b_sfe.grads_sol.set_size(0, 0);
  b_sfe.grads_geom.set_size(0, 0);
  b_sfe.jacTs.set_size(0, 3);
  b_sfe.wdetJ.set_size(0);
  b_sfe.dwork1.set_size(0, 0);
  b_sfe.dwork2.set_size(0, 0);
  b_sfe.xswork.set_size(0, 0);
  b_sfe.iwork.set_size(0, 0);
  etype_low = etype;
  etype_hi = etype;
  i = degree + 1;
  if (degree + 1 <= degree_hi) {
    boolean_T b;
    if ((degree > 2) && (degree < 6) && ((etype & 3) != 0)) {
      b = true;
    } else {
      b = false;
    }
    etype_hi = (((etype >> 5 & 7) << 5) + (degree << 2)) + b;
    npe = iv[etype_hi - 1];
  }
  if ((i <= degree_hi) && (nfaces >= 0)) {
    bndxsloc__size[1] = ndims;
  }
  for (int32_T deg{i}; deg <= degree_hi; deg++) {
    int32_T iplace;
    // encode_elemtype - Encode an element type from shape, degree, nodal
    // position
    //
    //    etype = encode_elemtype(shape, degree, depos)
    //
    obtain_natcoords(etype_hi, natcoords_);
    // obtain_elemnnodes - Obtain number of nodes per element given etype
    //
    //     nnodes = obtain_elemnnodes(etype)
    //
    //  This file was generated from update_nnodes_table
    //         % SFE_NODE_1
    //         % SFE_BAR_GL_2
    //         % SFE_BAR_GL_3
    //         % SFE_BAR_4
    //         % SFE_BAR_GL_4
    //         % SFE_BAR_5
    //         % SFE_BAR_GL_5
    //         % SFE_BAR_6
    //         % SFE_BAR_GL_6
    //         % SFE_BAR_7
    //         % SFE_BAR_GL_7
    //         % SFE_TRI_GL_3
    //         % SFE_TRI_GL_6
    //         % SFE_TRI_10
    //         % SFE_TRI_GL_10
    //         % SFE_TRI_15
    //         % SFE_TRI_GL_15
    //         % SFE_TRI_FEK_15
    //         % SFE_TRI_21
    //         % SFE_TRI_GL_21
    //         % SFE_TRI_FEK_21
    //         % SFE_TRI_28
    //         % SFE_TRI_GL_28
    //         % SFE_TRI_FEK_28
    //         % SFE_QUAD_GL_4
    //         % SFE_QUAD_GL_9
    //         % SFE_QUAD_16
    //         % SFE_QUAD_GL_16
    //         % SFE_QUAD_25
    //         % SFE_QUAD_GL_25
    //         % SFE_QUAD_36
    //         % SFE_QUAD_GL_36
    //         % SFE_QUAD_49
    //         % SFE_QUAD_GL_49
    //         % SFE_TET_GL_4
    //         % SFE_TET_GL_10
    //         % SFE_TET_20
    //         % SFE_TET_GL_20
    //         % SFE_TET_35
    //         % SFE_TET_GL_35
    //         % SFE_TET_FEK_35
    //         % SFE_TET_56
    //         % SFE_TET_GL_56
    //         % SFE_TET_FEK_56
    //         % SFE_TET_84
    //         % SFE_TET_GL_84
    //         % SFE_TET_FEK_84
    //         % SFE_PYRA_GL_5
    //         % SFE_PYRA_GL_14
    //         % SFE_PYRA_30
    //         % SFE_PYRA_GL_30
    //         % SFE_PYRA_55
    //         % SFE_PYRA_GL_55
    //         % SFE_PYRA_FEK_55
    //         % SFE_PYRA_91
    //         % SFE_PRISM_GL_6
    //         % SFE_PRISM_GL_18
    //         % SFE_PRISM_40
    //         % SFE_PRISM_GL_40
    //         % SFE_PRISM_75
    //         % SFE_PRISM_GL_75
    //         % SFE_PRISM_FEK_75
    //         % SFE_PRISM_126
    //         % SFE_PRISM_GL_126
    //         % SFE_PRISM_196
    //         % SFE_HEXA_GL_8
    //         % SFE_HEXA_GL_27
    //         % SFE_HEXA_64
    //         % SFE_HEXA_GL_64
    //         % SFE_HEXA_125
    //         % SFE_HEXA_GL_125
    //         % SFE_HEXA_216
    //         % SFE_HEXA_GL_216
    //         % SFE_HEXA_343
    //         % SFE_HEXA_GL_343
    //  raising element to higher degree
    // SfeObject - The core object in sfelib
    //
    //    sfe = SfeObject  * returns a MATLAB Coder declaration of the C struct
    //    sfe = SfeObject(etype)
    //
    //  PARAMETERS
    //  ----------
    //    etype:          Element type ID. For construction of SfeObject, the
    //                    uniform element type is assigned for simplicity. Note
    //                    that they can be changed in sfe_init
    //
    //  RETURN
    //  ------
    //    sfe:            The core object in sfelib, which contains buffer
    //    spaces
    //                    for computing SFE
    //
    //  NOTES
    //  -----
    //  Regarding internal memory management, the layout is optimized for
    //  row-major, assuming the code will be converted in C++ in row-major.
    //  In addition, this object unifies iso-, super-, and sub-parametric
    //  elements in later assembly processes.
    //
    //  See also sfe_init, sfe_init_grad
    //  assertions need to be performed here
    b_sfe.etypes[0] = etype_low;
    b_sfe.etypes[1] = etype_low;
    b_sfe.nnodes[0] = 0;
    b_sfe.nnodes[1] = 0;
    b_sfe.geom_dim = 0;
    b_sfe.topo_dim = 0;
    b_sfe.facetid = 0;
    b_sfe.nqp = 0;
    b_sfe.ws.set_size(0);
    b_sfe.cs.set_size(0, 0);
    b_sfe.shapes_sol.set_size(0, 0);
    b_sfe.shapes_geom.set_size(0, 0);
    b_sfe.derivs_sol.set_size(0, 0, 0);
    b_sfe.derivs_geom.set_size(0, 0, 0);
    b_sfe.cs_phy.set_size(0, 0);
    b_sfe.grads_sol.set_size(0, 0);
    b_sfe.grads_geom.set_size(0, 0);
    b_sfe.jacTs.set_size(0, 3);
    b_sfe.wdetJ.set_size(0);
    b_sfe.dwork1.set_size(0, 0);
    b_sfe.dwork2.set_size(0, 0);
    b_sfe.xswork.set_size(0, 0);
    b_sfe.iwork.set_size(0, 0);
    sfe_init(&b_sfe, etype_low, xsloc, natcoords_);
    xsloc.set_size(static_cast<int32_T>(iv[etype_hi - 1]), ndims);
    for (int32_T nn{0}; nn < npe; nn++) {
      for (int32_T jj{0}; jj < ndims; jj++) {
        xsloc[jj + xsloc.size(1) * nn] =
            b_sfe.cs_phy[jj + b_sfe.cs_phy.size(1) * nn];
      }
    }
    //  using high order boundary element to get high order nodal positions
    //  along facet side
    iplace = 0;
    for (int32_T f{0}; f <= nfaces; f++) {
      // SfeObject - The core object in sfelib
      //
      //    sfe = SfeObject  * returns a MATLAB Coder declaration of the C
      //    struct sfe = SfeObject(etype)
      //
      //  PARAMETERS
      //  ----------
      //    etype:          Element type ID. For construction of SfeObject, the
      //                    uniform element type is assigned for simplicity.
      //                    Note that they can be changed in sfe_init
      //
      //  RETURN
      //  ------
      //    sfe:            The core object in sfelib, which contains buffer
      //    spaces
      //                    for computing SFE
      //
      //  NOTES
      //  -----
      //  Regarding internal memory management, the layout is optimized for
      //  row-major, assuming the code will be converted in C++ in row-major.
      //  In addition, this object unifies iso-, super-, and sub-parametric
      //  elements in later assembly processes.
      //
      //  See also sfe_init, sfe_init_grad
      //  assertions need to be performed here
      sfe_facet.etypes[0] = ftype_bnd[f];
      sfe_facet.etypes[1] = ftype_bnd[f];
      sfe_facet.nnodes[0] = 0;
      sfe_facet.nnodes[1] = 0;
      sfe_facet.geom_dim = 0;
      sfe_facet.topo_dim = 0;
      sfe_facet.facetid = 0;
      sfe_facet.nqp = 0;
      sfe_facet.ws.set_size(0);
      sfe_facet.cs.set_size(0, 0);
      sfe_facet.shapes_sol.set_size(0, 0);
      sfe_facet.shapes_geom.set_size(0, 0);
      sfe_facet.derivs_sol.set_size(0, 0, 0);
      sfe_facet.derivs_geom.set_size(0, 0, 0);
      sfe_facet.cs_phy.set_size(0, 0);
      sfe_facet.grads_sol.set_size(0, 0);
      sfe_facet.grads_geom.set_size(0, 0);
      sfe_facet.jacTs.set_size(0, 3);
      sfe_facet.wdetJ.set_size(0);
      sfe_facet.dwork1.set_size(0, 0);
      sfe_facet.dwork2.set_size(0, 0);
      sfe_facet.xswork.set_size(0, 0);
      sfe_facet.iwork.set_size(0, 0);
      obtain_facets(etype_hi, facet[f], &ftype, lids_data, &lids_size);
      // obtain_elemnnodes - Obtain number of nodes per element given etype
      //
      //     nnodes = obtain_elemnnodes(etype)
      //
      //  This file was generated from update_nnodes_table
      //         % SFE_NODE_1
      //         % SFE_BAR_GL_2
      //         % SFE_BAR_GL_3
      //         % SFE_BAR_4
      //         % SFE_BAR_GL_4
      //         % SFE_BAR_5
      //         % SFE_BAR_GL_5
      //         % SFE_BAR_6
      //         % SFE_BAR_GL_6
      //         % SFE_BAR_7
      //         % SFE_BAR_GL_7
      //         % SFE_TRI_GL_3
      //         % SFE_TRI_GL_6
      //         % SFE_TRI_10
      //         % SFE_TRI_GL_10
      //         % SFE_TRI_15
      //         % SFE_TRI_GL_15
      //         % SFE_TRI_FEK_15
      //         % SFE_TRI_21
      //         % SFE_TRI_GL_21
      //         % SFE_TRI_FEK_21
      //         % SFE_TRI_28
      //         % SFE_TRI_GL_28
      //         % SFE_TRI_FEK_28
      //         % SFE_QUAD_GL_4
      //         % SFE_QUAD_GL_9
      //         % SFE_QUAD_16
      //         % SFE_QUAD_GL_16
      //         % SFE_QUAD_25
      //         % SFE_QUAD_GL_25
      //         % SFE_QUAD_36
      //         % SFE_QUAD_GL_36
      //         % SFE_QUAD_49
      //         % SFE_QUAD_GL_49
      //         % SFE_TET_GL_4
      //         % SFE_TET_GL_10
      //         % SFE_TET_20
      //         % SFE_TET_GL_20
      //         % SFE_TET_35
      //         % SFE_TET_GL_35
      //         % SFE_TET_FEK_35
      //         % SFE_TET_56
      //         % SFE_TET_GL_56
      //         % SFE_TET_FEK_56
      //         % SFE_TET_84
      //         % SFE_TET_GL_84
      //         % SFE_TET_FEK_84
      //         % SFE_PYRA_GL_5
      //         % SFE_PYRA_GL_14
      //         % SFE_PYRA_30
      //         % SFE_PYRA_GL_30
      //         % SFE_PYRA_55
      //         % SFE_PYRA_GL_55
      //         % SFE_PYRA_FEK_55
      //         % SFE_PYRA_91
      //         % SFE_PRISM_GL_6
      //         % SFE_PRISM_GL_18
      //         % SFE_PRISM_40
      //         % SFE_PRISM_GL_40
      //         % SFE_PRISM_75
      //         % SFE_PRISM_GL_75
      //         % SFE_PRISM_FEK_75
      //         % SFE_PRISM_126
      //         % SFE_PRISM_GL_126
      //         % SFE_PRISM_196
      //         % SFE_HEXA_GL_8
      //         % SFE_HEXA_GL_27
      //         % SFE_HEXA_64
      //         % SFE_HEXA_GL_64
      //         % SFE_HEXA_125
      //         % SFE_HEXA_GL_125
      //         % SFE_HEXA_216
      //         % SFE_HEXA_GL_216
      //         % SFE_HEXA_343
      //         % SFE_HEXA_GL_343
      loop_ub = iv[ftype_bnd[f] - 1];
      obtain_natcoords(ftype, natcoords_facet_);
      bndxsloc__size[0] = loop_ub;
      for (int32_T ii{0}; ii < loop_ub; ii++) {
        for (int32_T jj{0}; jj < ndims; jj++) {
          bndxsloc__data[jj + ndims * ii] =
              bndxsloc[jj + bndxsloc.size(1) * (iplace + ii)];
        }
      }
      sfe_init(&sfe_facet, ftype_bnd, bndxsloc__data, bndxsloc__size,
               natcoords_facet_);
      loop_ub = npe_lin_[f] + 1;
      for (int32_T nn{loop_ub}; nn <= lids_size; nn++) {
        for (int32_T jj{0}; jj < ndims; jj++) {
          xsloc[jj + xsloc.size(1) * (lids_data[nn - 1] - 1)] =
              sfe_facet.cs_phy[jj + sfe_facet.cs_phy.size(1) * (nn - 1)];
        }
      }
      iplace += lids_size;
    }
    etype_low = etype_hi;
  }
  obtain_natcoords(etype_new, natcoords_);
  sfe_init(&b_sfe, etype_hi, xsloc, natcoords_);
  // obtain_elemnnodes - Obtain number of nodes per element given etype
  //
  //     nnodes = obtain_elemnnodes(etype)
  //
  //  This file was generated from update_nnodes_table
  //         % SFE_NODE_1
  //         % SFE_BAR_GL_2
  //         % SFE_BAR_GL_3
  //         % SFE_BAR_4
  //         % SFE_BAR_GL_4
  //         % SFE_BAR_5
  //         % SFE_BAR_GL_5
  //         % SFE_BAR_6
  //         % SFE_BAR_GL_6
  //         % SFE_BAR_7
  //         % SFE_BAR_GL_7
  //         % SFE_TRI_GL_3
  //         % SFE_TRI_GL_6
  //         % SFE_TRI_10
  //         % SFE_TRI_GL_10
  //         % SFE_TRI_15
  //         % SFE_TRI_GL_15
  //         % SFE_TRI_FEK_15
  //         % SFE_TRI_21
  //         % SFE_TRI_GL_21
  //         % SFE_TRI_FEK_21
  //         % SFE_TRI_28
  //         % SFE_TRI_GL_28
  //         % SFE_TRI_FEK_28
  //         % SFE_QUAD_GL_4
  //         % SFE_QUAD_GL_9
  //         % SFE_QUAD_16
  //         % SFE_QUAD_GL_16
  //         % SFE_QUAD_25
  //         % SFE_QUAD_GL_25
  //         % SFE_QUAD_36
  //         % SFE_QUAD_GL_36
  //         % SFE_QUAD_49
  //         % SFE_QUAD_GL_49
  //         % SFE_TET_GL_4
  //         % SFE_TET_GL_10
  //         % SFE_TET_20
  //         % SFE_TET_GL_20
  //         % SFE_TET_35
  //         % SFE_TET_GL_35
  //         % SFE_TET_FEK_35
  //         % SFE_TET_56
  //         % SFE_TET_GL_56
  //         % SFE_TET_FEK_56
  //         % SFE_TET_84
  //         % SFE_TET_GL_84
  //         % SFE_TET_FEK_84
  //         % SFE_PYRA_GL_5
  //         % SFE_PYRA_GL_14
  //         % SFE_PYRA_30
  //         % SFE_PYRA_GL_30
  //         % SFE_PYRA_55
  //         % SFE_PYRA_GL_55
  //         % SFE_PYRA_FEK_55
  //         % SFE_PYRA_91
  //         % SFE_PRISM_GL_6
  //         % SFE_PRISM_GL_18
  //         % SFE_PRISM_40
  //         % SFE_PRISM_GL_40
  //         % SFE_PRISM_75
  //         % SFE_PRISM_GL_75
  //         % SFE_PRISM_FEK_75
  //         % SFE_PRISM_126
  //         % SFE_PRISM_GL_126
  //         % SFE_PRISM_196
  //         % SFE_HEXA_GL_8
  //         % SFE_HEXA_GL_27
  //         % SFE_HEXA_64
  //         % SFE_HEXA_GL_64
  //         % SFE_HEXA_125
  //         % SFE_HEXA_GL_125
  //         % SFE_HEXA_216
  //         % SFE_HEXA_GL_216
  //         % SFE_HEXA_343
  //         % SFE_HEXA_GL_343
  loop_ub = iv[etype_new - 1];
  xsloc.set_size(loop_ub, ndims);
  for (int32_T nn{0}; nn < loop_ub; nn++) {
    for (int32_T jj{0}; jj < ndims; jj++) {
      xsloc[jj + xsloc.size(1) * nn] =
          b_sfe.cs_phy[jj + b_sfe.cs_phy.size(1) * nn];
    }
  }
}

} // namespace sfe

// End of code generation (sfe_internal.cpp)
